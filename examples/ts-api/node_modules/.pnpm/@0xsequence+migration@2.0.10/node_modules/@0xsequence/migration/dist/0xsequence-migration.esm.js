import { commons, v2 } from '@0xsequence/core';
import { ethers } from 'ethers';
import { walletContracts } from '@0xsequence/abi';

function counterfactualVersion(address, firstImageHash, versions) {
  for (let i = 0; i < versions.length; i++) {
    if (commons.context.addressOf(versions[i], firstImageHash) === address) {
      return versions[i].version;
    }
  }

  // if we can't find the version then either the address is invalid,
  // the version is not in VersionedContext, or the firstImageHash is not correct
  throw new Error('Could not find version for counterfactual address');
}

var version = /*#__PURE__*/Object.freeze({
  __proto__: null,
  counterfactualVersion: counterfactualVersion
});

class Migration_v1v2 {
  constructor() {
    this.version = 2;
    this.configCoder = v2.config.ConfigCoder;
    this.signatureCoder = v2.signature.SignatureCoder;
  }
  buildTransaction(address, contexts, newConfig) {
    // If new config is not v2, then we need to convert it to v2
    if (!v2.config.ConfigCoder.isWalletConfig(newConfig)) {
      const v2Config = v2.config.toWalletConfig({
        threshold: newConfig.threshold,
        members: newConfig.signers,
        checkpoint: 0
      });
      return this.buildTransaction(address, contexts, v2Config);
    }
    const context = contexts[2];
    const contract = new ethers.Interface(walletContracts.mainModule.abi);

    // WARNING: v1 wallets CAN NOT use v2 configurations so we ALWAYS need to update
    // both the implementation and the configuration at the same time

    const updateBundle = v2.config.ConfigCoder.update.buildTransaction(address, newConfig, context, 'first');
    const tx = {
      entrypoint: address,
      nonce: commons.transaction.encodeNonce(MIGRATION_NONCE_SPACE, 0),
      transactions: [{
        to: address,
        value: 0,
        gasLimit: 0,
        revertOnError: true,
        delegateCall: false,
        data: contract.encodeFunctionData(contract.getFunction('updateImplementation'), [context.mainModuleUpgradable])
      }, ...updateBundle.transactions]
    };
    return {
      tx,
      fromVersion: this.version - 1,
      toVersion: this.version,
      toConfig: newConfig
    };
  }
  decodeTransaction(tx, contexts) {
    const address = tx.entrypoint;
    if (tx.transactions.length < 2) {
      throw new Error('Invalid transaction bundle size');
    }
    if (!tx.nonce || commons.transaction.encodeNonce(MIGRATION_NONCE_SPACE, 0) !== BigInt(tx.nonce)) {
      throw new Error('Invalid transaction bundle nonce');
    }
    if (tx.transactions[0].to !== address || tx.transactions[1].to !== address || tx.transactions[0].delegateCall || tx.transactions[1].delegateCall || !tx.transactions[0].revertOnError || !tx.transactions[1].revertOnError || tx.transactions[0].value && BigInt(tx.transactions[0].value) !== 0n || tx.transactions[1].value && BigInt(tx.transactions[1].value) !== 0n || tx.transactions[0].gasLimit && BigInt(tx.transactions[0].gasLimit) !== 0n || tx.transactions[1].gasLimit && BigInt(tx.transactions[1].gasLimit) !== 0n) {
      throw new Error('Invalid transaction bundle format');
    }
    const context = contexts[2];
    const contract = new ethers.Interface(walletContracts.mainModule.abi);
    const data1 = ethers.hexlify(tx.transactions[0].data || new Uint8Array());
    const expectData1 = ethers.hexlify(contract.encodeFunctionData(contract.getFunction('updateImplementation'), [context.mainModuleUpgradable]));
    if (data1 !== expectData1) {
      throw new Error('Invalid new implementation on transaction');
    }
    const decoded2 = v2.config.ConfigCoder.update.decodeTransaction({
      entrypoint: address,
      transactions: [tx.transactions[1]]
    });
    if (decoded2.address !== address) {
      throw new Error('Invalid transaction bundle address');
    }
    return decoded2;
  }
}

//                                 = uint160(keccak256("org.sequence.sdk.migration.space.nonce"))
const MIGRATION_NONCE_SPACE = '0xa04263acf755e8bd19c0d7e20eea39a9ff3729eb';
const v1v2 = new Migration_v1v2();

var index = /*#__PURE__*/Object.freeze({
  __proto__: null,
  MIGRATION_NONCE_SPACE: MIGRATION_NONCE_SPACE,
  v1v2: v1v2
});

function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}

function validateMigrations(migrations) {
  for (const [version, migration] of Object.entries(migrations)) {
    if (version !== String(migration.version - 1)) {
      throw new Error(`Migration with key ${version} has version ${migration.version}, expected version to be key + 1`);
    }
  }
}
class Migrator {
  constructor(tracker, migrations, contexts) {
    this.tracker = tracker;
    this.migrations = migrations;
    this.contexts = contexts;
    validateMigrations(migrations);
  }
  lastMigration() {
    let last;
    for (const migration of Object.values(this.migrations)) {
      if (last === undefined || migration.version > last.version) {
        last = migration;
      }
    }
    if (last === undefined) {
      throw new Error('No migrations');
    }
    return last;
  }
  async getAllMigratePresignedTransaction(args) {
    const {
      address,
      fromImageHash,
      fromVersion,
      chainId
    } = args;
    let fih = fromImageHash;
    let fversion = fromVersion;
    const versions = Object.values(this.contexts);
    const migs = [];
    for (let i = 1; i < versions.length; i++) {
      const mig = await this.tracker.getMigration(address, fih, fversion, chainId);
      if (!mig) return {
        signedMigrations: migs,
        missing: true,
        lastImageHash: fih,
        lastVersion: fversion
      };
      migs.push(mig);
      const migration = this.migrations[fversion];
      if (!migration) {
        throw new Error(`No migration found for version ${fversion}`);
      }
      const decoded = migration.decodeTransaction(mig.tx, this.contexts);
      if (decoded.address !== address) {
        throw new Error(`Migration transaction address does not match expected address`);
      }
      fih = decoded.newImageHash;
      fversion += 1;
    }
    return {
      signedMigrations: migs,
      missing: false,
      lastImageHash: fih,
      lastVersion: fversion
    };
  }
  async signNextMigration(address, fromVersion, wallet, nextConfig) {
    const migration = this.migrations[fromVersion];
    if (!migration) {
      return undefined;
    }
    const unsignedMigration = migration.buildTransaction(address, this.contexts, nextConfig);
    const signedBundle = await wallet.signTransactionBundle(unsignedMigration.tx);
    return _extends({}, unsignedMigration, {
      tx: signedBundle
    });
  }
}

var migrator = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Migrator: Migrator
});

const DefaultMigrations = {
  1: v1v2
};

var defaults = /*#__PURE__*/Object.freeze({
  __proto__: null,
  DefaultMigrations: DefaultMigrations
});

export { defaults, index as migration, migrator, version };
