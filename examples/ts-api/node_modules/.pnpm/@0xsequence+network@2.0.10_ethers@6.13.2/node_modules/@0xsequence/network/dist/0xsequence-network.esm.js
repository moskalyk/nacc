import { networks, ChainId } from '../constants/dist/0xsequence-network-constants.esm.js';
export { ChainId, NetworkType, networks } from '../constants/dist/0xsequence-network-constants.esm.js';
import { isBigNumberish, logger } from '@0xsequence/utils';
import { ethers } from 'ethers';

function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}

function isNetworkConfig(cand) {
  return cand && cand.chainId !== undefined && cand.name !== undefined && cand.rpcUrl !== undefined && cand.relayer !== undefined;
}
const getChainId = chainId => {
  if (typeof chainId === 'number') {
    return chainId;
  }
  if (chainId.chainId) {
    return chainId.chainId;
  }
  return Number(chainId);
};
const maybeChainId = chainId => {
  if (!chainId) return undefined;
  return getChainId(chainId);
};
const isValidNetworkConfig = (networkConfig, raise = false, skipRelayerCheck = false) => {
  if (!networkConfig) throw new Error(`invalid network config: empty config`);
  const configs = [];
  if (Array.isArray(networkConfig)) {
    configs.push(...networkConfig);
  } else {
    configs.push(networkConfig);
  }
  if (configs.length === 0) {
    if (raise) throw new Error(`invalid network config: empty config`);
    return false;
  }

  // Ensure distinct chainId configs
  const chainIds = configs.map(c => c.chainId).sort();
  const dupes = chainIds.filter((c, i) => chainIds.indexOf(c) !== i);
  if (dupes.length > 0) {
    if (raise) throw new Error(`invalid network config: duplicate chainIds ${dupes}`);
    return false;
  }

  // Downcase all network names
  configs.forEach(c => c.name = c.name.toLowerCase());

  // Ensure distinct network names
  const names = configs.map(c => c.name).sort();
  const nameDupes = names.filter((c, i) => names.indexOf(c) !== i);
  if (nameDupes.length > 0) {
    if (raise) throw new Error(`invalid network config: duplicate network names ${nameDupes}`);
    return false;
  }

  // Ensure rpcUrl or provider is specified
  // Ensure relayerUrl or relayer is specified
  // Ensure one default chain
  // Ensure one auth chain
  let defaultChain = false;
  for (let i = 0; i < configs.length; i++) {
    const c = configs[i];
    if ((!c.rpcUrl || c.rpcUrl === '') && !c.provider) {
      if (raise) throw new Error(`invalid network config for chainId ${c.chainId}: rpcUrl or provider must be provided`);
      return false;
    }
    if (!skipRelayerCheck) {
      if (!c.relayer) {
        if (raise) throw new Error(`invalid network config for chainId ${c.chainId}: relayer must be provided`);
        return false;
      }
    }
    if (c.isDefaultChain) {
      if (defaultChain) {
        if (raise) throw new Error(`invalid network config for chainId ${c.chainId}: DefaultChain is already set by another config`);
        return false;
      }
      defaultChain = true;
    }
  }
  if (!defaultChain) {
    if (raise) throw new Error(`invalid network config: DefaultChain must be set`);
    return false;
  }
  return true;
};
const ensureValidNetworks = (networks, skipRelayerCheck = false) => {
  isValidNetworkConfig(networks, true, skipRelayerCheck);
  return networks;
};
const ensureUniqueNetworks = (networks, raise = true) => {
  const chainIds = networks.map(c => c.chainId).sort();
  const dupes = chainIds.filter((c, i) => chainIds.indexOf(c) !== i);
  if (dupes.length > 0) {
    if (raise) throw new Error(`invalid network config: duplicate chainIds ${dupes}`);
    return false;
  }
  return true;
};
const updateNetworkConfig = (src, dest) => {
  if (!src || !dest) return;
  if (!src.chainId && !src.name) {
    throw new Error('failed to update network config: source config is missing chainId or name');
  }
  if (src.chainId !== dest.chainId && src.name !== dest.name) {
    throw new Error('failed to update network config: one of chainId or name must match');
  }
  if (src.rpcUrl) {
    dest.rpcUrl = src.rpcUrl;
    dest.provider = undefined;
  }
  if (src.provider) {
    dest.provider = src.provider;
  }
  if (src.relayer) {
    dest.relayer = src.relayer;
  }
};
const validateAndSortNetworks = networks => {
  return ensureValidNetworks(sortNetworks(networks));
};
const findNetworkConfig = (networks, chainId) => {
  if (typeof chainId === 'string') {
    if (chainId.startsWith('0x')) {
      const id = Number(chainId);
      return networks.find(n => n.chainId === id);
    } else {
      return networks.find(n => n.name === chainId || `${n.chainId}` === chainId);
    }
  } else if (typeof chainId === 'number') {
    return networks.find(n => n.chainId === chainId);
  } else if (chainId.chainId) {
    return networks.find(n => n.chainId === chainId.chainId);
  } else if (typeof chainId === 'bigint') {
    const id = Number(chainId);
    return networks.find(n => n.chainId === id);
  } else {
    return undefined;
  }
};
const checkNetworkConfig = (network, chainId) => {
  if (!network) return false;
  if (network.name === chainId) return true;
  if (network.chainId === chainId) return true;
  return false;
};
const networksIndex = networks => {
  const index = {};
  for (let i = 0; i < networks.length; i++) {
    index[networks[i].name] = networks[i];
  }
  return index;
};

// TODO: we should remove sortNetworks in the future but this is a breaking change for dapp integrations on older versions <-> wallet
// sortNetworks orders the network config list by: defaultChain, authChain, ..rest by chainId ascending numbers
const sortNetworks = networks => {
  if (!networks) {
    return [];
  }
  const config = networks.sort((a, b) => {
    if (a.chainId === b.chainId) return 0;
    return a.chainId < b.chainId ? -1 : 1;
  });

  // DefaultChain goes first
  const defaultConfigIdx = config.findIndex(c => c.isDefaultChain);
  if (defaultConfigIdx > 0) config.splice(0, 0, config.splice(defaultConfigIdx, 1)[0]);
  return config;
};
const stringTemplate = (sTemplate, mData) => {
  if (typeof sTemplate === 'string') {
    mData = mData ? mData : {};
    return sTemplate.replace(/\$\{\s*([$#@\-\d\w]+)\s*\}/gim, function (fullMath, grp) {
      let val = mData[grp];
      if (typeof val === 'function') {
        val = val();
      } else if (val === null || val === undefined) {
        val = '';
      } else if (typeof val === 'object' || typeof val === 'symbol') {
        val = val.toString();
      } else {
        val = val.valueOf();
      }
      return val;
    });
  }
  return '';
};

const indexerURL = network => stringTemplate('https://${network}-indexer.sequence.app', {
  network
});
const relayerURL = network => stringTemplate('https://${network}-relayer.sequence.app', {
  network
});
const nodesURL = network => stringTemplate('https://nodes.sequence.app/${network}', {
  network
});
function findSupportedNetwork(chainIdOrName) {
  return findNetworkConfig(allNetworks, chainIdOrName);
}
function toChainIdNumber(chainIdLike) {
  if (typeof chainIdLike === 'bigint') {
    return chainIdLike;
  }
  if (isBigNumberish(chainIdLike)) {
    return BigInt(chainIdLike);
  }
  return BigInt(chainIdLike.chainId);
}
const createNetworkConfig = (chainId, options) => {
  const network = networks[chainId];
  if (!network) {
    throw new Error(`Network with chainId ${chainId} not found`);
  }
  const rpcUrl = nodesURL(network.name);
  return _extends({}, network, {
    rpcUrl,
    indexerUrl: indexerURL(network.name),
    relayer: {
      url: relayerURL(network.name),
      provider: {
        url: rpcUrl
      }
    }
  }, options);
};
const hardhatNetworks = [_extends({}, networks[ChainId.HARDHAT], {
  rpcUrl: 'http://localhost:8545',
  relayer: {
    url: 'http://localhost:3000',
    provider: {
      url: 'http://localhost:8545'
    }
  }
}), _extends({}, networks[ChainId.HARDHAT_2], {
  rpcUrl: 'http://localhost:9545',
  relayer: {
    url: 'http://localhost:3000',
    provider: {
      url: 'http://localhost:9545'
    }
  }
})];
const allNetworks = validateAndSortNetworks([_extends({}, createNetworkConfig(ChainId.POLYGON), {
  isDefaultChain: true,
  isAuthChain: true
}), createNetworkConfig(ChainId.MAINNET), createNetworkConfig(ChainId.BSC), createNetworkConfig(ChainId.AVALANCHE), createNetworkConfig(ChainId.ARBITRUM), createNetworkConfig(ChainId.ARBITRUM_NOVA), createNetworkConfig(ChainId.OPTIMISM), createNetworkConfig(ChainId.OPTIMISM_SEPOLIA), createNetworkConfig(ChainId.POLYGON_ZKEVM), createNetworkConfig(ChainId.GNOSIS), createNetworkConfig(ChainId.RINKEBY, {
  disabled: true
}), createNetworkConfig(ChainId.GOERLI, {
  disabled: true
}), createNetworkConfig(ChainId.SEPOLIA), createNetworkConfig(ChainId.POLYGON_MUMBAI, {
  disabled: true
}), createNetworkConfig(ChainId.POLYGON_AMOY), createNetworkConfig(ChainId.BSC_TESTNET), createNetworkConfig(ChainId.ARBITRUM_SEPOLIA), createNetworkConfig(ChainId.BASE), createNetworkConfig(ChainId.BASE_SEPOLIA), createNetworkConfig(ChainId.HOMEVERSE), createNetworkConfig(ChainId.HOMEVERSE_TESTNET), createNetworkConfig(ChainId.XAI), createNetworkConfig(ChainId.XAI_SEPOLIA), createNetworkConfig(ChainId.AVALANCHE_TESTNET), createNetworkConfig(ChainId.ASTAR_ZKEVM), createNetworkConfig(ChainId.ASTAR_ZKYOTO), createNetworkConfig(ChainId.XR_SEPOLIA), createNetworkConfig(ChainId.B3_SEPOLIA), createNetworkConfig(ChainId.APECHAIN_TESTNET), createNetworkConfig(ChainId.BLAST), createNetworkConfig(ChainId.BLAST_SEPOLIA), createNetworkConfig(ChainId.TELOS), createNetworkConfig(ChainId.BORNE_TESTNET), createNetworkConfig(ChainId.SKALE_NEBULA_TESTNET), createNetworkConfig(ChainId.SONEIUM_MINATO), ...hardhatNetworks]);

class JsonRpcRouter {
  constructor(middlewares, sender) {
    this.sender = void 0;
    this.handler = void 0;
    this.sender = sender;
    if (middlewares) {
      this.setMiddleware(middlewares);
    }
  }
  setMiddleware(middlewares) {
    this.handler = createJsonRpcMiddlewareStack(middlewares, this.sender);
  }
  request(request) {
    return this.handler.request(request);
  }
}
const createJsonRpcMiddlewareStack = (middlewares, handler) => {
  if (middlewares.length === 0) return handler;
  const toMiddleware = v => {
    if (v.requestHandler) {
      return v.requestHandler;
    } else {
      return v;
    }
  };
  let chain;
  chain = toMiddleware(middlewares[middlewares.length - 1])(handler.request);
  for (let i = middlewares.length - 2; i >= 0; i--) {
    chain = toMiddleware(middlewares[i])(chain);
  }
  return {
    request: chain
  };
};

// TODOXXX: review..
function isJsonRpcProvider(cand) {
  return cand !== undefined && cand.send !== undefined && cand.constructor.defaultUrl !== undefined && cand.detectNetwork !== undefined && cand.getSigner !== undefined && cand.perform !== undefined;
}
function isJsonRpcSender(cand) {
  return cand !== undefined && cand.send !== undefined;
}

class JsonRpcHandler {
  constructor(provider, defaultChainId) {
    this.provider = void 0;
    this.defaultChainId = void 0;
    this.request = request => {
      if (!request.chainId) {
        request.chainId = this.defaultChainId;
      }
      return this.provider(request);
    };
    if (isJsonRpcSender(provider)) {
      this.provider = request => {
        return provider.send(request.method, request.params, request.chainId);
      };
    } else if (isJsonRpcProvider(provider)) {
      this.provider = request => {
        return provider.send(request.method, request.params || []);
      };
    } else {
      this.provider = provider;
    }
    this.defaultChainId = defaultChainId;
  }
  send(method, params, chainId) {
    const request = {
      method,
      params,
      chainId
    };
    return this.request(request);
  }
}

class AllowProvider {
  constructor(isAllowedFunc) {
    this.requestHandler = void 0;
    this.isAllowedFunc = void 0;
    if (isAllowedFunc) {
      this.isAllowedFunc = isAllowedFunc;
    } else {
      this.isAllowedFunc = request => true;
    }
    this.requestHandler = allowProviderMiddleware(this.isAllowedFunc);
  }
  setIsAllowedFunc(fn) {
    this.isAllowedFunc = fn;
    this.requestHandler = allowProviderMiddleware(this.isAllowedFunc);
  }
}
const allowProviderMiddleware = isAllowed => next => {
  return request => {
    // ensure precondition is met or do not allow the request to continue
    if (!isAllowed(request)) {
      throw new Error('allowProvider middleware precondition is unmet.');
    }

    // request is allowed. keep going..
    return next(request);
  };
};

class CachedProvider {
  constructor(options) {
    var _this = this;
    // cachableJsonRpcMethods which can be permanently cached for lifetime
    // of the provider.
    this.cachableJsonRpcMethods = ['net_version', 'eth_chainId', 'eth_accounts', 'sequence_getWalletContext', 'sequence_getNetworks'];
    // cachableJsonRpcMethodsByBlock which can be temporarily cached for a short
    // period of time, essentially by block time. As we support chains fast blocks,
    // we keep the values here cachable only for 1.5 seconds. This is still useful to
    // memoize the calls within app-code that calls out to fetch these values within
    // a short period of time.
    this.cachableJsonRpcMethodsByBlock = ['eth_call', 'eth_getCode'];
    // cache for life-time of provider (unless explicitly cleared)
    this.cache = void 0;
    // cache by block, simulated by using a 1 second life-time
    this.cacheByBlock = void 0;
    this.cacheByBlockResetLock = false;
    // onUpdateCallback callback to be notified when cache values are set.
    this.onUpdateCallback = void 0;
    // defaultChainId is used for default chain select with used with multi-chain provider
    this.defaultChainId = void 0;
    this.requestHandler = next => {
      return async function (request) {
        // Respond early with cached result
        if (_this.cachableJsonRpcMethods.includes(request.method) || _this.cachableJsonRpcMethodsByBlock.includes(request.method)) {
          const key = _this.cacheKey(request.method, request.params, request.chainId || _this.defaultChainId);
          const _result = _this.getCacheValue(key);
          if (_result && _result !== '') {
            return {
              id: request.id,
              result: _result
            };
          }
        }

        // Continue down the handler chain
        const result = await next(request);

        // Store result in cache and continue
        if (_this.cachableJsonRpcMethods.includes(request.method) || _this.cachableJsonRpcMethodsByBlock.includes(request.method)) {
          if (result && _this.shouldCacheResponse(request, result)) {
            // cache the value
            const key = _this.cacheKey(request.method, request.params, request.chainId || _this.defaultChainId);
            if (_this.cachableJsonRpcMethods.includes(request.method)) {
              _this.setCacheValue(key, result);
            } else {
              _this.setCacheByBlockValue(key, result);
            }
          }
        }
        return result;
      };
    };
    this.cacheKey = (method, params, chainId) => {
      let key = '';
      if (chainId) {
        key = `${chainId}:${method}:`;
      } else {
        key = `:${method}:`;
      }
      if (!params || params.length === 0) {
        return key + '[]';
      }
      return key + JSON.stringify(params);
    };
    this.getCache = () => this.cache;
    this.setCache = cache => {
      this.cache = cache;
      if (this.onUpdateCallback) {
        this.onUpdateCallback();
      }
    };
    this.getCacheValue = key => {
      if (this.cache[key]) {
        return this.cache[key];
      }
      if (this.cacheByBlock[key]) {
        return this.cacheByBlock[key];
      }
      return undefined;
    };
    this.setCacheValue = (key, value) => {
      this.cache[key] = value;
      if (this.onUpdateCallback) {
        this.onUpdateCallback(key, value);
      }
    };
    this.setCacheByBlockValue = (key, value) => {
      this.cacheByBlock[key] = value;

      // clear the cacheByBlock once every X period of time
      if (!this.cacheByBlockResetLock) {
        this.cacheByBlockResetLock = true;
        setTimeout(() => {
          this.cacheByBlockResetLock = false;
          this.cacheByBlock = {};
        }, 1500); // 1.5 second cache lifetime
      }
    };
    this.shouldCacheResponse = (request, result) => {
      // skip if we do not have response result
      if (!result) {
        return false;
      }

      // skip caching eth_getCode where resposne value is '0x' or empty
      if (request.method === 'eth_getCode' && result.length <= 2) {
        return false;
      }

      // all good -- signal to cache the result
      return true;
    };
    this.clearCache = () => {
      this.cache = {};
      this.cacheByBlock = {};
    };
    this.cache = {};
    this.cacheByBlock = {};
    this.defaultChainId = options == null ? void 0 : options.defaultChainId;
    if (!(options != null && options.blockCache)) {
      this.cachableJsonRpcMethodsByBlock = [];
    } else if ((options == null ? void 0 : options.blockCache) !== true) {
      this.cachableJsonRpcMethodsByBlock = options == null ? void 0 : options.blockCache;
    }
  }
  onUpdate(callback) {
    this.onUpdateCallback = callback;
  }
}

// EagerProvider will eagerly respond to a provider request from pre-initialized data values.
//
// This is useful for saving a few remote calls for responses we're already expecting when
// communicating to a specific network provider.

class EagerProvider {
  constructor(options) {
    var _this = this;
    this.options = void 0;
    this.requestHandler = next => {
      return async function (request) {
        switch (request.method) {
          case 'net_version':
            if (_this.options.chainId) {
              return `${_this.options.chainId}`;
            }
            break;
          case 'eth_chainId':
            if (_this.options.chainId) {
              return ethers.toQuantity(_this.options.chainId);
            }
            break;
          case 'eth_accounts':
            if (_this.options.accountAddress) {
              return [ethers.getAddress(_this.options.accountAddress)];
            }
            break;
          case 'sequence_getWalletContext':
            if (_this.options.walletContext) {
              return _this.options.walletContext;
            }
            break;
        }
        return next(request);
      };
    };
    this.options = options;
  }
}

const exceptionProviderMiddleware = next => {
  return async request => {
    try {
      return await next(request);
    } catch (error) {
      if (typeof error === 'string') {
        throw new Error(error);
      } else {
        throw new Error(error.message);
      }
    }
  };
};

// TODO: rename to loggerMiddleware
const loggingProviderMiddleware = next => {
  return async request => {
    const chainIdLabel = request.chainId ? ` chainId:${request.chainId}` : '';
    logger.info(`[provider request]${chainIdLabel} id:${request.id} method:${request.method} params:`, request.params);
    try {
      const result = await next(request);
      logger.info(`[provider response]${chainIdLabel} id:${request.id} method:${request.method} params:`, request.params, `result:`, result);
      return result;
    } catch (error) {
      logger.warn(`[provider response]${chainIdLabel} id:${request.id} method:${request.method} params:`, request.params, `error:`, error);
    }
  };
};

const networkProviderMiddleware = getChainId => next => {
  return async request => {
    const networkChainId = getChainId(request);
    switch (request.method) {
      case 'net_version':
        {
          return `${networkChainId}`;
        }
      case 'eth_chainId':
        {
          return ethers.toQuantity(networkChainId);
        }
    }

    // request is allowed. keep going..
    return next(request);
  };
};

const SignerJsonRpcMethods = ['personal_sign', 'eth_sign', 'eth_signTypedData', 'eth_signTypedData_v4', 'eth_sendTransaction', 'eth_sendRawTransaction', 'sequence_sign',
// sequence-aware personal_sign
'sequence_signTypedData_v4',
// sequence-aware eth_signTypedData_v4

'sequence_getWalletContext', 'sequence_getWalletConfig', 'sequence_getWalletState', 'sequence_getNetworks', 'sequence_updateConfig', 'sequence_publishConfig', 'sequence_gasRefundOptions', 'sequence_getNonce', 'sequence_relay', 'eth_decrypt', 'eth_getEncryptionPublicKey', 'wallet_addEthereumChain', 'wallet_switchEthereumChain', 'wallet_registerOnboarding', 'wallet_watchAsset', 'wallet_scanQRCode'];
class SigningProvider {
  constructor(provider) {
    this.provider = void 0;
    this.requestHandler = next => {
      return request => {
        // Forward signing requests to the signing provider
        if (SignerJsonRpcMethods.includes(request.method)) {
          return this.provider.request(request);
        }

        // Continue to next handler
        return next(request);
      };
    };
    this.provider = provider;
  }
}

class PublicProvider {
  constructor(rpcUrl) {
    this.privateJsonRpcMethods = ['net_version', 'eth_chainId', 'eth_accounts', ...SignerJsonRpcMethods];
    this.provider = void 0;
    this.rpcUrl = void 0;
    this.requestHandler = next => {
      return request => {
        // When provider is configured, send non-private methods to our local public provider
        if (this.provider && !this.privateJsonRpcMethods.includes(request.method)) {
          return this.provider.send(request.method, request.params || []);
        }

        // Continue to next handler
        logger.debug('[public-provider] sending request to signer window', request.method);
        return next(request);
      };
    };
    if (rpcUrl) {
      this.setRpcUrl(rpcUrl);
    }
  }
  getRpcUrl() {
    return this.rpcUrl;
  }
  setRpcUrl(rpcUrl) {
    if (!rpcUrl || rpcUrl === '') {
      this.rpcUrl = undefined;
      this.provider = undefined;
    } else {
      this.rpcUrl = rpcUrl;
      // TODO: maybe use @0xsequence/network JsonRpcProvider here instead,
      // which supports better caching.
      this.provider = new ethers.JsonRpcProvider(rpcUrl);
    }
  }
}

class SingleflightMiddleware {
  constructor() {
    var _this = this;
    this.singleflightJsonRpcMethods = ['eth_chainId', 'net_version', 'eth_call', 'eth_getCode', 'eth_blockNumber', 'eth_getBalance', 'eth_getStorageAt', 'eth_getTransactionCount', 'eth_getBlockTransactionCountByHash', 'eth_getBlockTransactionCountByNumber', 'eth_getUncleCountByBlockHash', 'eth_getUncleCountByBlockNumber', 'eth_getBlockByHash', 'eth_getBlockByNumber', 'eth_getTransactionByHash', 'eth_getTransactionByBlockHashAndIndex', 'eth_getTransactionByBlockNumberAndIndex', 'eth_getTransactionReceipt', 'eth_getUncleByBlockHashAndIndex', 'eth_getUncleByBlockNumberAndIndex', 'eth_getLogs'];
    this.inflight = void 0;
    this.requestHandler = next => {
      return async function (request) {
        // continue to next handler if method isn't part of methods list
        if (!_this.singleflightJsonRpcMethods.includes(request.method)) {
          return next(request);
        }
        const key = _this.requestKey(request.method, request.params || [], request.chainId);
        if (!_this.inflight[key]) {
          // first request -- init the empty list
          _this.inflight[key] = [];
        } else {
          // already in-flight, add the callback to the list and return
          return new Promise((resolve, reject) => {
            _this.inflight[key].push({
              id: request.id,
              callback: (error, response) => {
                if (error) {
                  reject(error);
                } else {
                  resolve(response);
                }
              }
            });
          });
        }

        // Continue down the handler chain
        try {
          // Exec the handler, and on success resolve all other promises
          const response = await next(request);
          _this.inflight[key].forEach(({
            callback
          }) => callback(undefined, response));
          return response;
        } catch (error) {
          // If the request fails, reject all queued promises.
          _this.inflight[key].forEach(({
            callback
          }) => callback(error, undefined));
          throw error;
        } finally {
          delete _this.inflight[key];
        }
      };
    };
    this.requestKey = (method, params, chainId) => {
      let key = '';
      if (chainId) {
        key = `${chainId}:${method}:`;
      } else {
        key = `:${method}:`;
      }
      if (!params || params.length === 0) {
        return key + '[]';
      }
      return key + JSON.stringify(params);
    };
    this.inflight = {};
  }
}

function _classPrivateFieldBase(receiver, privateKey) {
  if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
    throw new TypeError("attempted to use private field on non-instance");
  }
  return receiver;
}

var id = 0;
function _classPrivateFieldKey(name) {
  return "__private_" + id++ + "_" + name;
}

var _chainId = /*#__PURE__*/_classPrivateFieldKey("chainId");
var _nextId = /*#__PURE__*/_classPrivateFieldKey("nextId");
var _sender = /*#__PURE__*/_classPrivateFieldKey("sender");
// JsonRpcProvider with a middleware stack. By default it will use a simple caching middleware.
class JsonRpcProvider extends ethers.JsonRpcProvider {
  constructor(url, options, jsonRpcApiProviderOptions) {
    var _this;
    super(url, options == null ? void 0 : options.chainId, jsonRpcApiProviderOptions);
    _this = this;
    this.url = url;
    Object.defineProperty(this, _chainId, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _nextId, {
      writable: true,
      value: 1
    });
    Object.defineProperty(this, _sender, {
      writable: true,
      value: void 0
    });
    this.fetch = async function (request) {
      if (_this.url === undefined) {
        throw new Error('missing provider URL');
      }
      const {
        method,
        params
      } = request;
      const jsonRpcRequest = {
        method,
        params,
        id: _classPrivateFieldBase(_this, _nextId)[_nextId]++,
        jsonrpc: '2.0'
      };

      // const result = ethers.fetchJson(this.connection, JSON.stringify(request), getResult).then(
      //   result => {
      //     return result
      //   },
      //   error => {
      //     throw error
      //   }
      // )

      const fetchRequest = typeof _this.url === 'string' ? new ethers.FetchRequest(_this.url) : _this.url;
      fetchRequest.body = JSON.stringify(jsonRpcRequest);

      // TODOXXX: what about headers, etc..?
      // we probably need these in the options of the construtor, etc..

      try {
        const res = await fetchRequest.send();
        if (res.body) {
          try {
            const result = JSON.parse(ethers.toUtf8String(res.body));

            // TODO: Process result

            return getResult(result);
          } catch (err) {
            throw new Error('invalid JSON response');
          }
        }
        return null;
      } catch (err) {
        // TODO - error handling
        throw err;
      }
    };
    const chainId = options == null ? void 0 : options.chainId;
    const middlewares = options == null ? void 0 : options.middlewares;
    const blockCache = options == null ? void 0 : options.blockCache;
    _classPrivateFieldBase(this, _chainId)[_chainId] = chainId;

    // NOTE: it will either use the middleware stack passed to the constructor
    // or it will use the default caching middleware provider. It does not concat them,
    // so if you set middlewares, make sure you set the caching middleware yourself if you'd
    // like to keep using it.
    const router = new JsonRpcRouter(middlewares != null ? middlewares : [
    // loggingProviderMiddleware,
    new EagerProvider({
      chainId
    }), new SingleflightMiddleware(), new CachedProvider({
      defaultChainId: chainId,
      blockCache: blockCache
    })], new JsonRpcHandler(this.fetch, chainId));
    _classPrivateFieldBase(this, _sender)[_sender] = router;
  }
  async request(request) {
    return _classPrivateFieldBase(this, _sender)[_sender].request(request);
  }
  async send(method, params, chainId) {
    return this.request({
      method,
      params: params,
      chainId
    });
  }
  async getNetwork() {
    const chainId = _classPrivateFieldBase(this, _chainId)[_chainId];
    if (chainId) {
      const network = networks[chainId];
      const name = (network == null ? void 0 : network.name) || '';
      const ensAddress = network == null ? void 0 : network.ensAddress;
      return ethers.Network.from({
        name,
        chainId,
        ensAddress
      });
    } else {
      const chainIdHex = await this.send('eth_chainId', []);
      _classPrivateFieldBase(this, _chainId)[_chainId] = Number(chainIdHex);
      return this.getNetwork();
    }
  }
}
function getResult(payload) {
  if (payload.error) {
    // @TODO: not any
    const error = new Error(payload.error.message);
    error.code = payload.error.code;
    error.data = payload.error.data;
    throw error;
  }
  return payload.result;
}

export { AllowProvider, CachedProvider, EagerProvider, JsonRpcHandler, JsonRpcProvider, JsonRpcRouter, PublicProvider, SigningProvider, SingleflightMiddleware, allNetworks, allowProviderMiddleware, checkNetworkConfig, createJsonRpcMiddlewareStack, ensureUniqueNetworks, ensureValidNetworks, exceptionProviderMiddleware, findNetworkConfig, findSupportedNetwork, getChainId, hardhatNetworks, indexerURL, isJsonRpcProvider, isJsonRpcSender, isNetworkConfig, isValidNetworkConfig, loggingProviderMiddleware, maybeChainId, networkProviderMiddleware, networksIndex, nodesURL, relayerURL, sortNetworks, stringTemplate, toChainIdNumber, updateNetworkConfig, validateAndSortNetworks };
