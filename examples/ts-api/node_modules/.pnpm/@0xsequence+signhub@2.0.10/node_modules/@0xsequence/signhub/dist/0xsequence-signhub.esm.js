import { ethers } from 'ethers';

function isSapientSigner(signer) {
  return signer.getAddress !== undefined && signer.buildDeployTransaction !== undefined && signer.predecorateSignedTransactions !== undefined && signer.decorateTransactions !== undefined && signer.sign !== undefined && signer.notifyStatusChange !== undefined;
}

class SignerWrapper {
  constructor(signer, eoa = true) {
    this.signer = signer;
    this.eoa = eoa;
  }
  getAddress() {
    return this.signer.getAddress();
  }
  async buildDeployTransaction(_metadata) {
    // Wrapped signers don't require deployment
    return;
  }
  async predecorateSignedTransactions(_metadata) {
    return [];
  }
  async decorateTransactions(bundle, _metadata) {
    return bundle;
  }
  sign(message) {
    return this.signer.signMessage(message);
  }
  notifyStatusChange(_i, _s, _m) {}
  suffix() {
    return new Uint8Array([2]);
  }
}

var index = /*#__PURE__*/Object.freeze({
  __proto__: null,
  isSapientSigner: isSapientSigner,
  SignerWrapper: SignerWrapper
});

let SignerState = /*#__PURE__*/function (SignerState) {
  SignerState[SignerState["INITIAL"] = 0] = "INITIAL";
  SignerState[SignerState["SIGNING"] = 1] = "SIGNING";
  SignerState[SignerState["SIGNED"] = 2] = "SIGNED";
  SignerState[SignerState["ERROR"] = 3] = "ERROR";
  return SignerState;
}({});
function isSignerStatusPending(status) {
  return status === undefined || status.state === SignerState.INITIAL || status.state === SignerState.SIGNING;
}
/**
 * Orchestrates actions of collective signers.
 * This includes the signing of a single digests and transactions by multiple signers.
 * It can provide internal visibility of the signing process, and it also
 * provides the internal signers with additional information about the
 * message being signed. Transaction decoration can be used to ensure on-chain state
 * is correctly managed during the signing process.
 */
class Orchestrator {
  constructor(signers, tag = Orchestrator.randomTag()) {
    this.tag = tag;
    this.observers = [];
    this.signers = [];
    this.count = 0;
    this.setSigners(signers);
  }
  static randomTag() {
    return `default-${ethers.hexlify(ethers.randomBytes(8)).slice(2)}`;
  }
  pullId() {
    return `${this.tag}-${this.count++}`;
  }
  setSigners(signers) {
    this.signers = signers.map(s => isSapientSigner(s) ? s : new SignerWrapper(s));
  }
  async getSigners() {
    return Promise.all(this.signers.map(async function (s) {
      return s.getAddress();
    }));
  }
  subscribe(observer) {
    this.observers.push(observer);
    return () => {
      this.observers = this.observers.filter(o => o !== observer);
    };
  }
  async notifyObservers(id, status, metadata) {
    await Promise.all([...this.signers.map(async function (signer) {
      return signer.notifyStatusChange(id, status, metadata);
    }), ...this.observers.map(async function (observer) {
      return observer(status, metadata);
    })]);
  }
  async buildDeployTransaction(metadata) {
    let bundle;
    for (const signer of this.signers) {
      const newBundle = await signer.buildDeployTransaction(metadata);
      if (bundle === undefined) {
        // Use first bundle as base
        bundle = newBundle;
      } else if (newBundle != null && newBundle.transactions) {
        // Combine deploy transactions
        bundle.transactions = newBundle.transactions.concat(bundle.transactions);
      }
    }
    return bundle;
  }
  async predecorateSignedTransactions(metadata) {
    const output = [];
    for (const signer of this.signers) {
      output.push(...(await signer.predecorateSignedTransactions(metadata != null ? metadata : {})));
    }
    return output;
  }
  async decorateTransactions(bundle, metadata) {
    for (const signer of this.signers) {
      bundle = await signer.decorateTransactions(bundle, metadata != null ? metadata : {});
    }
    return bundle;
  }
  signMessage(args) {
    var _this = this;
    const id = this.pullId();
    return new Promise(async function (resolve) {
      const {
        message,
        metadata,
        callback,
        candidates
      } = args;
      const status = {
        ended: false,
        message,
        signers: {}
      };
      let lastMetadata = metadata != null ? metadata : {};
      const onNewMetadata = newMetadata => {
        lastMetadata = newMetadata;
        _this.notifyObservers(id, status, lastMetadata);
      };
      const onStatusUpdate = () => {
        try {
          _this.notifyObservers(id, status, lastMetadata);
          const pending = Object.entries(status.signers).filter(([_, s]) => isSignerStatusPending(s));
          if (callback && callback(status, onNewMetadata) || pending.length === 0) {
            status.ended = true;
            resolve(status);
            _this.notifyObservers(id, status, lastMetadata);
            return;
          }
        } catch (e) {
          console.error('Error while notifying observers', e);
        }
      };

      // we only call signers that are found in `candidates`
      // if `candidates` is undefined, we call all signers
      let signers = _this.signers;
      if (candidates) {
        const addresses = await Promise.all(_this.signers.map(async function (s) {
          return s.getAddress();
        }));
        signers = _this.signers.filter((_, i) => candidates.includes(addresses[i]));
      }

      // build callbacks object
      const accepted = await Promise.allSettled(signers.map(async function (s) {
        const saddr = await s.getAddress();
        status.signers[saddr] = {
          state: SignerState.SIGNING,
          request: s.sign(message, metadata != null ? metadata : {}).then(signature => {
            const suffix = s.suffix();
            status.signers[saddr] = {
              state: SignerState.SIGNED,
              signature,
              suffix
            };
            onStatusUpdate();
            return signature;
          }).catch(error => {
            status.signers[saddr] = {
              state: SignerState.ERROR,
              error
            };
            onStatusUpdate();
            throw error;
          })
        };
      }));
      for (let i = 0; i < accepted.length; i++) {
        const signer = _this.signers[i];
        const promise = accepted[i];
        if (promise.status === 'rejected') {
          const address = await signer.getAddress();
          console.warn(`signer ${address} rejected the request: ${promise.reason}`);
          status.signers[address] = {
            state: SignerState.ERROR,
            error: new Error(`signer ${address} rejected the request: ${promise.reason}`)
          };
        }
      }
      onStatusUpdate();
    });
  }
}

export { Orchestrator, SignerState, isSignerStatusPending, index as signers };
