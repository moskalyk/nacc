import { ethers } from 'ethers';
import { commons } from '@0xsequence/core';
import { SapientSigner } from "./signers/signer.js";
export type Status = {
    ended: boolean;
    message: ethers.BytesLike;
    signers: {
        [signer: string]: SignerStatus;
    };
};
export declare enum SignerState {
    INITIAL = 0,
    SIGNING = 1,
    SIGNED = 2,
    ERROR = 3
}
export type SignerStatus = {
    state: SignerState.INITIAL;
} | {
    state: SignerState.SIGNING;
    request: Promise<ethers.BytesLike>;
} | {
    state: SignerState.SIGNED;
    signature: ethers.BytesLike;
    suffix: ethers.BytesLike;
} | {
    state: SignerState.ERROR;
    error: any;
};
export declare function isSignerStatusPending(status?: SignerStatus): status is undefined | {
    state: SignerState.INITIAL;
} | {
    state: SignerState.SIGNING;
    request: Promise<ethers.BytesLike>;
};
export interface SignatureOrchestrator {
    getSigners(): Promise<string[]>;
    signMessage(args: {
        candidates: string[];
        message: ethers.BytesLike;
        metadata: object;
        callback: (status: Status, onNewMetadata: (metadata: object) => void) => boolean;
    }): Promise<Status>;
    buildDeployTransaction(metadata: object): Promise<commons.transaction.TransactionBundle | undefined>;
    predecorateSignedTransactions(metadata?: object): Promise<commons.transaction.SignedTransactionBundle[]>;
    decorateTransactions(bundle: commons.transaction.IntendedTransactionBundle, metadata?: object): Promise<commons.transaction.IntendedTransactionBundle>;
}
/**
 * Orchestrates actions of collective signers.
 * This includes the signing of a single digests and transactions by multiple signers.
 * It can provide internal visibility of the signing process, and it also
 * provides the internal signers with additional information about the
 * message being signed. Transaction decoration can be used to ensure on-chain state
 * is correctly managed during the signing process.
 */
export declare class Orchestrator {
    tag: string;
    private observers;
    private signers;
    private count;
    constructor(signers: (ethers.Signer | SapientSigner)[], tag?: string);
    private static randomTag;
    private pullId;
    setSigners(signers: (ethers.Signer | SapientSigner)[]): void;
    getSigners(): Promise<string[]>;
    subscribe(observer: (status: Status, metadata: object) => void): () => void;
    private notifyObservers;
    buildDeployTransaction(metadata: object): Promise<commons.transaction.TransactionBundle | undefined>;
    predecorateSignedTransactions(metadata?: object): Promise<commons.transaction.SignedTransactionBundle[]>;
    decorateTransactions(bundle: commons.transaction.IntendedTransactionBundle, metadata?: object): Promise<commons.transaction.IntendedTransactionBundle>;
    signMessage(args: {
        candidates?: string[];
        message: ethers.BytesLike;
        metadata?: object;
        callback?: (status: Status, onNewMetadata: (metadata: object) => void) => boolean;
    }): Promise<Status>;
}
