// src/rpc/proto/databeat.gen.ts
var Databeat = class {
  hostname;
  fetch;
  path = "/rpc/Databeat/";
  constructor(hostname, fetch) {
    this.hostname = hostname;
    this.fetch = (input, init) => fetch(input, init);
  }
  url(name) {
    return this.hostname + this.path + name;
  }
  ping = (headers, signal) => {
    return this.fetch(
      this.url("Ping"),
      createHTTPRequest({}, headers, signal)
    ).then((res) => {
      return buildResponse(res).then((_data) => {
        return {
          status: _data.status
        };
      });
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ""}` });
    });
  };
  version = (headers, signal) => {
    return this.fetch(
      this.url("Version"),
      createHTTPRequest({}, headers, signal)
    ).then((res) => {
      return buildResponse(res).then((_data) => {
        return {
          version: _data.version
        };
      });
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ""}` });
    });
  };
  runtimeStatus = (headers, signal) => {
    return this.fetch(
      this.url("RuntimeStatus"),
      createHTTPRequest({}, headers, signal)
    ).then((res) => {
      return buildResponse(res).then((_data) => {
        return {
          status: _data.status
        };
      });
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ""}` });
    });
  };
  tick = (args, headers, signal) => {
    return this.fetch(
      this.url("Tick"),
      createHTTPRequest(args, headers, signal)
    ).then((res) => {
      return buildResponse(res).then((_data) => {
        return {
          ok: _data.ok
        };
      });
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ""}` });
    });
  };
  rawEvents = (args, headers, signal) => {
    return this.fetch(
      this.url("RawEvents"),
      createHTTPRequest(args, headers, signal)
    ).then((res) => {
      return buildResponse(res).then((_data) => {
        return {
          ok: _data.ok
        };
      });
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error.message || ""}` });
    });
  };
};
var createHTTPRequest = (body = {}, headers = {}, signal = null) => {
  return {
    method: "POST",
    headers: { ...headers, "Content-Type": "application/json" },
    body: JSON.stringify(body || {}),
    signal
  };
};
var buildResponse = (res) => {
  return res.text().then((text) => {
    let data;
    try {
      data = JSON.parse(text);
    } catch (error) {
      let message = "";
      if (error instanceof Error) {
        message = error.message;
      }
      throw WebrpcBadResponseError.new(
        {
          status: res.status,
          cause: `JSON.parse(): ${message}: response text: ${text}`
        }
      );
    }
    if (!res.ok) {
      const code = typeof data.code === "number" ? data.code : 0;
      throw (webrpcErrorByCode[code] || WebrpcError).new(data);
    }
    return data;
  });
};
var WebrpcError = class _WebrpcError extends Error {
  name;
  code;
  message;
  status;
  cause;
  /** @deprecated Use message instead of msg. Deprecated in webrpc v0.11.0. */
  msg;
  constructor(name, code, message, status, cause) {
    super(message);
    this.name = name || "WebrpcError";
    this.code = typeof code === "number" ? code : 0;
    this.message = message || `endpoint error ${this.code}`;
    this.msg = this.message;
    this.status = typeof status === "number" ? status : 0;
    this.cause = cause;
    Object.setPrototypeOf(this, _WebrpcError.prototype);
  }
  static new(payload) {
    return new this(payload.error, payload.code, payload.message || payload.msg, payload.status, payload.cause);
  }
};
var WebrpcEndpointError = class _WebrpcEndpointError extends WebrpcError {
  constructor(name = "WebrpcEndpoint", code = 0, message = "endpoint error", status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, _WebrpcEndpointError.prototype);
  }
};
var WebrpcRequestFailedError = class _WebrpcRequestFailedError extends WebrpcError {
  constructor(name = "WebrpcRequestFailed", code = -1, message = "request failed", status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, _WebrpcRequestFailedError.prototype);
  }
};
var WebrpcBadRouteError = class _WebrpcBadRouteError extends WebrpcError {
  constructor(name = "WebrpcBadRoute", code = -2, message = "bad route", status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, _WebrpcBadRouteError.prototype);
  }
};
var WebrpcBadMethodError = class _WebrpcBadMethodError extends WebrpcError {
  constructor(name = "WebrpcBadMethod", code = -3, message = "bad method", status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, _WebrpcBadMethodError.prototype);
  }
};
var WebrpcBadRequestError = class _WebrpcBadRequestError extends WebrpcError {
  constructor(name = "WebrpcBadRequest", code = -4, message = "bad request", status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, _WebrpcBadRequestError.prototype);
  }
};
var WebrpcBadResponseError = class _WebrpcBadResponseError extends WebrpcError {
  constructor(name = "WebrpcBadResponse", code = -5, message = "bad response", status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, _WebrpcBadResponseError.prototype);
  }
};
var WebrpcServerPanicError = class _WebrpcServerPanicError extends WebrpcError {
  constructor(name = "WebrpcServerPanic", code = -6, message = "server panic", status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, _WebrpcServerPanicError.prototype);
  }
};
var WebrpcInternalErrorError = class _WebrpcInternalErrorError extends WebrpcError {
  constructor(name = "WebrpcInternalError", code = -7, message = "internal error", status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, _WebrpcInternalErrorError.prototype);
  }
};
var WebrpcClientDisconnectedError = class _WebrpcClientDisconnectedError extends WebrpcError {
  constructor(name = "WebrpcClientDisconnected", code = -8, message = "client disconnected", status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, _WebrpcClientDisconnectedError.prototype);
  }
};
var WebrpcStreamLostError = class _WebrpcStreamLostError extends WebrpcError {
  constructor(name = "WebrpcStreamLost", code = -9, message = "stream lost", status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, _WebrpcStreamLostError.prototype);
  }
};
var WebrpcStreamFinishedError = class _WebrpcStreamFinishedError extends WebrpcError {
  constructor(name = "WebrpcStreamFinished", code = -10, message = "stream finished", status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, _WebrpcStreamFinishedError.prototype);
  }
};
var UnauthorizedError = class _UnauthorizedError extends WebrpcError {
  constructor(name = "Unauthorized", code = 1e3, message = "Unauthorized access", status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, _UnauthorizedError.prototype);
  }
};
var PermissionDeniedError = class _PermissionDeniedError extends WebrpcError {
  constructor(name = "PermissionDenied", code = 2e3, message = "Permission denied", status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, _PermissionDeniedError.prototype);
  }
};
var SessionExpiredError = class _SessionExpiredError extends WebrpcError {
  constructor(name = "SessionExpired", code = 2001, message = "Session expired", status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, _SessionExpiredError.prototype);
  }
};
var NotFoundError = class _NotFoundError extends WebrpcError {
  constructor(name = "NotFound", code = 3e3, message = "Resource not found", status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, _NotFoundError.prototype);
  }
};
var InvalidAppKeyError = class _InvalidAppKeyError extends WebrpcError {
  constructor(name = "InvalidAppKey", code = 4e3, message = "Invalid app key", status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, _InvalidAppKeyError.prototype);
  }
};
var QueryFailedError = class _QueryFailedError extends WebrpcError {
  constructor(name = "QueryFailed", code = 4001, message = "DB query failed", status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, _QueryFailedError.prototype);
  }
};
var InvalidProjectIdError = class _InvalidProjectIdError extends WebrpcError {
  constructor(name = "InvalidProjectId", code = 4002, message = "Invalid project id", status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, _InvalidProjectIdError.prototype);
  }
};
var webrpcErrorByCode = {
  [0]: WebrpcEndpointError,
  [-1]: WebrpcRequestFailedError,
  [-2]: WebrpcBadRouteError,
  [-3]: WebrpcBadMethodError,
  [-4]: WebrpcBadRequestError,
  [-5]: WebrpcBadResponseError,
  [-6]: WebrpcServerPanicError,
  [-7]: WebrpcInternalErrorError,
  [-8]: WebrpcClientDisconnectedError,
  [-9]: WebrpcStreamLostError,
  [-10]: WebrpcStreamFinishedError,
  [1e3]: UnauthorizedError,
  [2e3]: PermissionDeniedError,
  [2001]: SessionExpiredError,
  [3e3]: NotFoundError,
  [4e3]: InvalidAppKeyError,
  [4001]: QueryFailedError,
  [4002]: InvalidProjectIdError
};

// src/rpc/proto/index.ts
var DatabeatRpcClient = class extends Databeat {
  constructor(hostname, auth) {
    const globalFetch = globalThis.fetch.bind(globalThis);
    super(hostname.endsWith("/") ? hostname.slice(0, -1) : hostname, globalFetch);
    this.auth = auth;
    this._globalFetch = globalFetch;
    this.fetch = this._fetch;
  }
  _globalFetch;
  _fetch = (input, init) => {
    if (this.auth) {
      let headers = {};
      if (this.auth.jwt?.length > 0) {
        headers["Authorization"] = `BEARER ${this.auth.jwt}`;
      }
      if (this.auth.headers) {
        headers = { ...headers, ...this.auth.headers };
      }
      init.headers = { ...init.headers, ...headers };
    }
    return this._globalFetch(input, init);
  };
};

// src/index.ts
import { sha256 } from "@noble/hashes/sha256";
import { bytesToHex } from "@noble/hashes/utils";
var Ident = /* @__PURE__ */ ((Ident2) => {
  Ident2[Ident2["ANON"] = 0] = "ANON";
  Ident2[Ident2["PRIVATE"] = 1] = "PRIVATE";
  Ident2[Ident2["USER"] = 2] = "USER";
  return Ident2;
})(Ident || {});
var MAX_QUEUE_SIZE = 150;
var defaultDatabeatOptions = {
  defaultEnabled: true,
  noop: false,
  privacy: { userIdHash: true, userAgentSalt: false },
  userIdentTracking: false,
  strictMode: false,
  flushInterval: 500,
  initProps: () => {
    return {};
  }
};
var Databeat2 = class {
  rpc;
  auth;
  options;
  enabled;
  ident;
  userId;
  sessionId;
  allowUserTracking;
  projectId;
  queue;
  flushTimeout;
  defaultProps;
  previousPageKey;
  ts;
  constructor(host, auth, options) {
    this.auth = auth;
    this.rpc = new DatabeatRpcClient(host, auth);
    this.options = defaultDatabeatOptions;
    if (options) {
      this.options = {
        defaultEnabled: options.defaultEnabled || defaultDatabeatOptions.defaultEnabled,
        projectId: options.projectId || null,
        privacy: options.privacy || defaultDatabeatOptions.privacy,
        userIdentTracking: options.userIdentTracking || defaultDatabeatOptions.userIdentTracking,
        strictMode: options.strictMode || defaultDatabeatOptions.strictMode,
        flushInterval: options.flushInterval || defaultDatabeatOptions.flushInterval,
        noop: options.noop || false,
        initProps: options.initProps || defaultDatabeatOptions.initProps
      };
    }
    this.init();
  }
  // init is called on load by the constructor and also by reset().
  init() {
    this.enabled = isEnabled(this.options.defaultEnabled, this.auth);
    this.projectId = this.options.projectId || null;
    this.userId = null;
    this.sessionId = genSessionId();
    this.queue = [];
    this.flushTimeout = null;
    this.defaultProps = { ...getDefaultProps(), ...this.options.initProps() };
    this.identify();
  }
  // reset will reset the user_id and session_id details. Similar to a "logout" action.
  reset(skipInit) {
    this.enabled = isEnabled(this.options.defaultEnabled, this.auth);
    if (this.userId && !this.isAnon()) {
      this.userId = null;
    }
    this.ident = 0 /* ANON */;
    this.ts = setStorageVal({ on: this.enabled, id: this.userId, it: this.ident, ut: this.allowUserTracking });
    if (skipInit === true) {
      return;
    }
    this.init();
  }
  // identify can be called to seed the userId, where the behaviour changes
  // depending on privacy or strict modes. identify is also called on init,
  // where we load the data from localStorage.
  identify(userId, options) {
    if (!isBrowser())
      return;
    if (options && options.allowTracking !== void 0) {
      this.allowTracking(options.allowTracking);
    }
    if (!userId) {
      const val = getStorageVal();
      if (val !== null && val.id !== null) {
        this.userId = val.id;
        this.ident = val.it;
        this.allowUserTracking = val.ut;
        if (val.it === void 0) {
          if (this.userId.startsWith("anon:")) {
            this.ident = 0 /* ANON */;
          } else {
            this.ident = 1 /* PRIVATE */;
          }
          this.ts = setStorageVal({ on: this.enabled, id: this.userId, it: this.ident, ut: this.allowUserTracking });
        } else {
          this.ident = val.it;
        }
      }
    }
    if (userId || this.userId === null) {
      const v = genUserId(userId, this.allowUserTracking, this.options);
      this.userId = v.userId;
      this.ident = v.ident;
      this.ts = setStorageVal({ on: this.enabled, id: this.userId, it: this.ident, ut: this.allowUserTracking });
    }
    this.track({ event: "INIT", source: getPagePath(), props: this.defaultProps });
    this.flush();
  }
  // allowTracking is used by strict mode to enable/disable tracking.
  allowTracking(allowTracking) {
    this.allowUserTracking = allowTracking;
    setStorageVal({ on: this.enabled, id: this.userId, it: this.ident, ut: this.allowUserTracking });
    if (this.options.strictMode) {
      if (allowTracking) {
        this.enable();
      } else {
        this.disable();
      }
    }
  }
  async track(events, options) {
    if (isBrowser() && this.userId === null) {
      throw new Error("databeat: init first");
    }
    if (Array.isArray(events)) {
      for (let i = 0; i < events.length; i++) {
        events[i].ident = this.ident;
        events[i].userId = this.userId;
        events[i].sessionId = this.sessionId;
        if (!events[i].projectId && this.projectId) {
          events[i].projectId = this.projectId;
        }
      }
      this.queue.push(...events);
    } else {
      events.ident = this.ident;
      events.userId = this.userId;
      events.sessionId = this.sessionId;
      if (!events.projectId && this.projectId) {
        events.projectId = this.projectId;
      }
      this.queue.push(events);
    }
    if (this.queue.length > MAX_QUEUE_SIZE) {
      this.queue = this.queue.splice(this.queue.length - MAX_QUEUE_SIZE);
    }
    if (!this.enabled)
      return;
    if (options && options.flush) {
      await this.flush();
    } else if (this.flushTimeout === null) {
      this.flushTimeout = setTimeout(() => {
        this.flush();
      }, this.options.flushInterval);
    }
  }
  trackView(props = {}) {
    const eventProps = { ...this.defaultProps, ...props };
    const eventSource = getPagePath();
    const pageKey = `${eventSource}:${JSON.stringify(eventProps)}:${this.userId}:${this.sessionId}`;
    if (this.previousPageKey === pageKey)
      return;
    this.previousPageKey = pageKey;
    this.track({ event: "VIEW", source: eventSource, props: eventProps });
  }
  flush = async () => {
    if (this.flushTimeout !== null) {
      clearTimeout(this.flushTimeout);
      this.flushTimeout = null;
    }
    if (!this.enabled)
      return;
    if (this.options.noop)
      return;
    if (this.options.strictMode && !this.allowUserTracking)
      return;
    if (this.queue.length === 0)
      return;
    const events = this.dedupedQueue();
    this.queue = [];
    try {
      await this.rpc.tick({ events });
    } catch (err) {
      console.warn(`databeat flush failed: ${err}`);
    }
  };
  isEnabled() {
    return this.enabled;
  }
  isAnon() {
    return this.ident === 0 /* ANON */;
  }
  getIdent() {
    return this.ident;
  }
  getUserId() {
    return this.userId;
  }
  getSessionId() {
    return this.sessionId;
  }
  getStorageTS() {
    if (this.ts) {
      return this.ts;
    }
    const val = getStorageVal();
    if (val === void 0 || val === null || val.id === null) {
      return void 0;
    }
    this.ts = val.ts;
    return this.ts;
  }
  enable() {
    if (!isAuthEnabled(this.auth)) {
      this.enabled = false;
      return;
    }
    if (!isBrowser())
      return;
    this.enabled = true;
    this.ts = setStorageVal({ on: this.enabled, id: this.userId, it: this.ident, ut: this.allowUserTracking });
    this.identify();
  }
  disable() {
    if (!isBrowser())
      return;
    this.enabled = false;
    this.ts = setStorageVal({ on: this.enabled, id: this.userId, it: this.ident, ut: this.allowUserTracking });
  }
  dedupedQueue = () => {
    const uniqEvents = /* @__PURE__ */ new Map();
    for (let i = 0; i < this.queue.length; i++) {
      const ev = this.queue[i];
      const key = `${ev.event}:${ev.source}:${ev.userId}:${ev.sessionId}:${JSON.stringify(ev.props)}:${JSON.stringify(ev.nums)}`;
      if (!uniqEvents.has(key)) {
        uniqEvents.set(key, ev);
      }
    }
    return Array.from(uniqEvents.values());
  };
};
var isBrowser = () => {
  return typeof window === "object" && typeof window.localStorage === "object" && typeof window.localStorage.getItem === "function" && typeof window.localStorage.setItem === "function";
};
var isEnabled = (defaultEnabled, auth) => {
  if (!isAuthEnabled(auth)) {
    return false;
  }
  if (!isBrowser()) {
    return true;
  }
  const val = getStorageVal();
  if (val === null) {
    if (defaultEnabled !== null && defaultEnabled !== void 0) {
      return defaultEnabled;
    } else {
      return true;
    }
  } else {
    return val.on;
  }
};
var isAuthEnabled = (auth) => {
  if (auth?.jwt?.length > 0) {
    return true;
  }
  if (auth?.headers && Object.keys(auth.headers).length > 0) {
    return true;
  }
  return false;
};
var getPagePath = () => {
  try {
    return window.location.pathname;
  } catch (err) {
    return "";
  }
};
var getDefaultProps = () => {
  if (!isBrowser())
    return {};
  const params = new URL(window.location.href).searchParams;
  const props = {};
  props["origin"] = window.location.origin;
  if (params.get("ref") && params.get("ref") !== "") {
    props["ref"] = params.get("ref") || "";
  }
  if (params.get("source") && params.get("source") !== "") {
    props["source"] = params.get("source") || "";
  }
  if (params.get("utm_source") && params.get("utm_source") !== "") {
    props["utmSource"] = params.get("utm_source") || "";
  }
  if (params.get("utm_campaign") && params.get("utm_campaign") !== "") {
    props["utmCampaign"] = params.get("utm_campaign") || "";
  }
  if (params.get("utm_medium") && params.get("utm_medium") !== "") {
    props["utmMedium"] = params.get("utm_medium") || "";
  }
  if (params.get("utm_content") && params.get("utm_content") !== "") {
    props["utmContent"] = params.get("utm_content") || "";
  }
  if (params.get("utm_term") && params.get("utm_term") !== "") {
    props["utmTerm"] = params.get("utm_term") || "";
  }
  if (document.referrer && document.referrer !== "") {
    props["referrer"] = document.referrer;
  }
  if (params.get("gclid") && params.get("gclid") !== "") {
    props["gclid"] = params.get("gclid") || "";
  }
  if (params.get("wbraid") && params.get("wbraid") !== "") {
    props["wbraid"] = params.get("wbraid") || "";
  }
  return props;
};
var storageKey = "_dbeat";
var getStorageVal = () => {
  try {
    return JSON.parse(window.localStorage.getItem(storageKey));
  } catch (err) {
    return null;
  }
};
var setStorageVal = (val) => {
  try {
    if (!val.ts) {
      val.ts = Math.floor(Date.now() / 1e3);
    }
    window.localStorage.setItem(storageKey, JSON.stringify(val));
    return val.ts;
  } catch (err) {
    return;
  }
};
var genUserId = (seed, allowUserTracking, options) => {
  if (!seed || seed === null || seed === "") {
    const id = Math.floor(Math.random() * 1e14);
    return { userId: `${id}`, ident: 0 /* ANON */ };
  }
  if (options.userIdentTracking && allowUserTracking) {
    return { userId: seed, ident: 2 /* USER */ };
  }
  if (options.privacy.userIdHash === true || !options.userIdentTracking || !allowUserTracking) {
    if (isBrowser() && options.privacy.userAgentSalt === true) {
      seed = seed + ":" + navigator.userAgent;
    }
    if (options.privacy.extraSalt && options.privacy.extraSalt.length > 0) {
      seed = seed + ":" + options.privacy.extraSalt;
    }
    return { userId: bytesToHex(sha256(seed)).substring(0, 50), ident: 1 /* PRIVATE */ };
  } else {
    throw new Error("invalid configuration");
  }
};
var genSessionId = () => {
  const isSessionStorageAvail = isBrowser() && typeof window.sessionStorage === "object" && typeof window.sessionStorage.getItem === "function" && typeof window.sessionStorage.setItem === "function";
  if (!isSessionStorageAvail) {
    return genRandHex(16);
  } else {
    const sid = window.sessionStorage.getItem(storageKey);
    if (!!sid && sid.length > 0) {
      return sid;
    } else {
      const sid2 = genRandHex(16);
      window.sessionStorage.setItem(storageKey, sid2);
      return sid2;
    }
  }
};
var genRandHex = (n) => {
  let hexString = "";
  for (let i = 0; i < n; i++) {
    hexString += Math.floor(Math.random() * 16).toString(16);
  }
  return "0x" + hexString;
};
if (typeof process === "object" && process.version && process.version < "v18") {
  console.error(`ERROR! expecting node v18+ but your node version is reporting ${process.version}`);
  if (process && process.exit) {
    process.exit(1);
  }
}
export {
  Databeat2 as Databeat,
  Ident,
  genSessionId,
  genUserId,
  getStorageVal,
  isBrowser
};
//# sourceMappingURL=databeat-tracker.mjs.map