
import { commons } from '@0xsequence/core';
import { migrator } from '@0xsequence/migration';
import { ethers } from 'ethers';
import { ConfigTracker, PresignedConfig, PresignedConfigLink } from "../tracker.js";
import { TrackerStore } from "./stores/index.js";
export declare class LocalConfigTracker implements ConfigTracker, migrator.PresignedMigrationTracker {
    provider: ethers.Provider;
    private store;
    useEIP5719: boolean;
    private cachedEIP5719;
    constructor(provider: ethers.Provider, store?: TrackerStore, useEIP5719?: boolean);
    private loadTopology;
    private saveTopology;
    saveWalletConfig: (args: {
        config: commons.config.Config;
    }) => Promise<void>;
    private configOfImageHashCache;
    configOfImageHash: (args: {
        imageHash: string;
    }) => Promise<commons.config.Config | undefined>;
    saveCounterfactualWallet: (args: {
        config: commons.config.Config;
        context: commons.context.WalletContext[];
    }) => Promise<void>;
    imageHashOfCounterfactualWallet: (args: {
        wallet: string;
    }) => Promise<{
        imageHash: string;
        context: commons.context.WalletContext;
    } | undefined>;
    savePayload: (args: {
        payload: commons.signature.SignedPayload;
    }) => Promise<void>;
    private payloadOfSubdigestCache;
    payloadOfSubdigest: (args: {
        subdigest: string;
    }) => Promise<commons.signature.SignedPayload | undefined>;
    savePresignedConfiguration: (args: PresignedConfig) => Promise<void>;
    loadPresignedConfiguration: (args: {
        wallet: string;
        fromImageHash: string;
        longestPath?: boolean;
    }) => Promise<PresignedConfigLink[]>;
    saveWitnesses: (args: {
        wallet: string;
        digest: string;
        chainId: ethers.BigNumberish;
        signatures: string[];
    }) => Promise<void>;
    walletsOfSigner: (args: {
        signer: string;
    }) => Promise<{
        wallet: string;
        proof: {
            digest: string;
            chainId: bigint;
            signature: string;
        };
    }[]>;
    saveMigration(address: string, signed: migrator.SignedMigration, contexts: commons.context.VersionedContext): Promise<void>;
    getMigration(address: string, fromImageHash: string, fromVersion: number, chainId: ethers.BigNumberish): Promise<migrator.SignedMigration | undefined>;
    updateProvider(provider: ethers.Provider): void;
}
