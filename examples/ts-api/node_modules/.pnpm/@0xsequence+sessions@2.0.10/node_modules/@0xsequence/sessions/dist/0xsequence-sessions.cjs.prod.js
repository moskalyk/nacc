'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var utils = require('@0xsequence/utils');
var core = require('@0xsequence/core');
var migration = require('@0xsequence/migration');
var ethers = require('ethers');
var replacer = require('@0xsequence/replacer');
var idb = require('idb');

class ConfigTracker {
  constructor() {
    this.loadPresignedConfiguration = void 0;
    this.savePresignedConfiguration = void 0;
    this.saveWitnesses = void 0;
    this.configOfImageHash = void 0;
    this.saveWalletConfig = void 0;
    this.imageHashOfCounterfactualWallet = void 0;
    this.saveCounterfactualWallet = void 0;
    this.walletsOfSigner = void 0;
  }
}

var tracker = /*#__PURE__*/Object.freeze({
  __proto__: null,
  ConfigTracker: ConfigTracker
});

class DebugConfigTracker {
  constructor(tracker) {
    this.tracker = tracker;
  }
  async loadPresignedConfiguration(args) {
    console.debug('? loadPresignedConfiguration');
    debug(args, '? ');
    return debug(await this.tracker.loadPresignedConfiguration(args), '! ');
  }
  savePresignedConfiguration(args) {
    console.debug('? savePresignedConfiguration');
    debug(args, '? ');
    return this.tracker.savePresignedConfiguration(args);
  }
  saveWitnesses(args) {
    console.debug('? saveWitnesses');
    debug(args, '? ');
    return this.tracker.saveWitnesses(args);
  }
  async configOfImageHash(args) {
    console.debug('? configOfImageHash');
    debug(args, '? ');
    return debug(await this.tracker.configOfImageHash(args), '! ');
  }
  saveWalletConfig(args) {
    console.debug('? saveWalletConfig');
    debug(args, '? ');
    return this.tracker.saveWalletConfig(args);
  }
  async imageHashOfCounterfactualWallet(args) {
    console.debug('? imageHashOfCounterfactualWallet');
    debug(args, '? ');
    return debug(await this.tracker.imageHashOfCounterfactualWallet(args), '! ');
  }
  saveCounterfactualWallet(args) {
    console.debug('? saveCounterfactualWallet');
    debug(args, '? ');
    return this.tracker.saveCounterfactualWallet(args);
  }
  async walletsOfSigner(args) {
    console.debug('? walletsOfSigner');
    debug(args, '? ');
    return debug(await this.tracker.walletsOfSigner(args), '! ');
  }
  async getMigration(address, fromImageHash, fromVersion, chainId) {
    console.debug('? getMigration');
    debug({
      address,
      fromImageHash,
      fromVersion,
      chainId
    }, '? ');
    return debug(await this.tracker.getMigration(address, fromImageHash, fromVersion, chainId), '! ');
  }
  saveMigration(address, signed, contexts) {
    console.debug('? saveMigration');
    debug({
      address,
      signed,
      contexts
    }, '? ');
    return this.tracker.saveMigration(address, signed, contexts);
  }
}
function debug(value, prefix = '') {
  switch (value) {
    case undefined:
      console.debug(prefix + 'undefined');
      break;
    default:
      JSON.stringify(value, utils.bigintReplacer, 2).split('\n').map(line => prefix + line).forEach(line => console.debug(line));
      break;
  }
  return value;
}

var debug$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  DebugConfigTracker: DebugConfigTracker
});

function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}

class MemoryTrackerStore {
  constructor() {
    this.configs = {};
    this.v2Nodes = {};
    this.counterfactualWallets = {};
    this.payloads = {};
    this.signatures = {};
    this.migrations = {};
    this.loadConfig = imageHash => {
      return Promise.resolve(this.configs[imageHash]);
    };
    this.saveConfig = (imageHash, config) => {
      this.configs[imageHash] = config;
      return Promise.resolve();
    };
    this.loadV2Node = nodeHash => {
      return Promise.resolve(this.v2Nodes[nodeHash]);
    };
    this.saveV2Node = (nodeHash, node) => {
      this.v2Nodes[nodeHash] = node;
      return Promise.resolve();
    };
    this.loadCounterfactualWallet = wallet => {
      return Promise.resolve(this.counterfactualWallets[wallet]);
    };
    this.saveCounterfactualWallet = (wallet, imageHash, context) => {
      this.counterfactualWallets[wallet] = {
        imageHash,
        context
      };
      return Promise.resolve();
    };
    this.loadPayloadOfSubdigest = subdigest => {
      return Promise.resolve(this.payloads[subdigest]);
    };
    this.savePayloadOfSubdigest = (subdigest, payload) => {
      this.payloads[subdigest] = payload;
      return Promise.resolve();
    };
    this.loadSubdigestsOfSigner = signer => {
      return Promise.resolve(Object.keys(this.signatures[signer] || {}));
    };
    this.loadSignatureOfSubdigest = (signer, subdigest) => {
      var _this$signatures$sign;
      return Promise.resolve((_this$signatures$sign = this.signatures[signer]) == null ? void 0 : _this$signatures$sign[subdigest]);
    };
    this.saveSignatureOfSubdigest = (signer, subdigest, payload) => {
      if (!this.signatures[signer]) this.signatures[signer] = {};
      this.signatures[signer][subdigest] = payload;
      return Promise.resolve();
    };
    this.loadMigrationsSubdigest = (wallet, fromVersion, toVersion) => {
      var _this$migrations$wall;
      return Promise.resolve(((_this$migrations$wall = this.migrations[wallet]) == null || (_this$migrations$wall = _this$migrations$wall[fromVersion]) == null ? void 0 : _this$migrations$wall[toVersion]) || []);
    };
    this.saveMigrationsSubdigest = (wallet, fromVersion, toVersion, subdigest, toImageHash) => {
      if (!this.migrations[wallet]) this.migrations[wallet] = {};
      if (!this.migrations[wallet][fromVersion]) this.migrations[wallet][fromVersion] = {};
      if (!this.migrations[wallet][fromVersion][toVersion]) this.migrations[wallet][fromVersion][toVersion] = [];
      this.migrations[wallet][fromVersion][toVersion].push({
        subdigest,
        toImageHash
      });
      return Promise.resolve();
    };
  }
}

function recreateBigNumbers(object) {
  if (object === undefined) return undefined;
  const result = {};
  for (const key of Object.keys(object)) {
    const val = object[key];
    if (val._isBigNumber === true && val._hex !== undefined && typeof val._hex === 'string' && val._hex.length !== '') {
      // Entry is a big number
      result[key] = BigInt(val._hex);
    } else if (Array.isArray(val)) {
      // Entry is an array, recurse
      result[key] = val.map(v => recreateBigNumbers(v));
    } else if (typeof val === 'object' && val !== null) {
      // Entry is another object, recurse
      result[key] = recreateBigNumbers(val);
    } else {
      // Entry is a primitive, just copy
      result[key] = val;
    }
  }
  return result;
}
class IndexedDBStore {
  constructor(dbName) {
    var _this = this;
    this.dbName = dbName;
    this._lazyDb = void 0;
    this.loadConfig = async function (imageHash) {
      const db = await _this.getDb();
      return db.get('configs', imageHash).then(c => recreateBigNumbers(c));
    };
    this.saveConfig = async function (imageHash, config) {
      const db = await _this.getDb();
      await db.put('configs', config, imageHash);
    };
    this.loadV2Node = async function (nodeHash) {
      const db = await _this.getDb();
      return db.get('v2Nodes', nodeHash).then(c => recreateBigNumbers(c));
    };
    this.saveV2Node = async function (nodeHash, node) {
      const db = await _this.getDb();
      await db.put('v2Nodes', node, nodeHash);
    };
    this.loadCounterfactualWallet = async function (wallet) {
      const db = await _this.getDb();
      return db.get('counterfactualWallets', wallet);
    };
    this.saveCounterfactualWallet = async function (wallet, imageHash, context) {
      const db = await _this.getDb();
      await db.put('counterfactualWallets', {
        imageHash,
        context
      }, wallet);
    };
    this.loadPayloadOfSubdigest = async function (subdigest) {
      const db = await _this.getDb();
      return db.get('payloads', subdigest).then(c => recreateBigNumbers(c));
    };
    this.savePayloadOfSubdigest = async function (subdigest, payload) {
      const db = await _this.getDb();
      await db.put('payloads', payload, subdigest);
    };
    this.loadSubdigestsOfSigner = async function (signer) {
      const db = await _this.getDb();
      const index = await db.getAllKeysFromIndex('signatures', 'signer', IDBKeyRange.only(signer));
      return index.map(key => key.split('-')[0]);
    };
    this.loadSignatureOfSubdigest = async function (signer, subdigest) {
      const db = await _this.getDb();
      const signature = await db.get('signatures', [subdigest, signer].join('-'));
      return signature == null ? void 0 : signature.signature;
    };
    this.saveSignatureOfSubdigest = async function (signer, subdigest, payload) {
      const db = await _this.getDb();
      await db.put('signatures', {
        signature: payload,
        signer
      }, [subdigest, signer].join('-'));
    };
    this.loadMigrationsSubdigest = async function (wallet, fromVersion, toVersion) {
      const db = await _this.getDb();
      const index = await db.getAllFromIndex('migrations', 'jump', IDBKeyRange.only([wallet, fromVersion, toVersion]));
      return index.map(key => ({
        subdigest: key.subdigest,
        toImageHash: key.toImageHash
      }));
    };
    this.saveMigrationsSubdigest = async function (wallet, fromVersion, toVersion, subdigest, toImageHash) {
      const db = await _this.getDb();
      await db.put('migrations', {
        wallet,
        fromVersion,
        toVersion,
        subdigest,
        toImageHash
      }, subdigest);
    };
  }
  async getDb() {
    if (this._lazyDb) return this._lazyDb;
    const dbName = this.dbName;
    this._lazyDb = await idb.openDB(dbName, 1, {
      upgrade(db, oldVersion, newVersion, transaction) {
        console.log(`upgrading ${dbName} from ${oldVersion} to ${newVersion} - ${transaction}`);
        if (oldVersion === 0) {
          db.createObjectStore('configs');
          db.createObjectStore('v2Nodes');
          db.createObjectStore('counterfactualWallets');
          db.createObjectStore('payloads');
          const signatures = db.createObjectStore('signatures');
          signatures.createIndex('signer', 'signer', {
            unique: false
          });
          const migrations = db.createObjectStore('migrations');
          migrations.createIndex('jump', ['wallet', 'fromVersion', 'toVersion']);
        }
      }
    });
    return this._lazyDb;
  }
}

function isPlainNode(node) {
  return node.left !== undefined && node.right !== undefined;
}
function isPlainNested(node) {
  return node.weight !== undefined && node.threshold !== undefined && node.tree !== undefined;
}
function isPlainV2Config(config) {
  return config.version === 2 && config.threshold !== undefined && config.checkpoint !== undefined && config.tree !== undefined && typeof config.tree === 'string';
}

var index$2 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  isPlainNode: isPlainNode,
  isPlainNested: isPlainNested,
  isPlainV2Config: isPlainV2Config,
  MemoryTrackerStore: MemoryTrackerStore,
  recreateBigNumbers: recreateBigNumbers,
  IndexedDBStore: IndexedDBStore
});

class LocalConfigTracker {
  constructor(
  // TODO: The provider is only used to determine that EIP1271 signatures have *some* validity
  // but when reconstructing a presigned transaction we should do the replacement once per chain.
  // For now, it's recommended to use Mainnet as the provider.
  provider, store = new MemoryTrackerStore(), useEIP5719 = false) {
    var _this = this;
    this.provider = provider;
    this.store = store;
    this.useEIP5719 = useEIP5719;
    this.cachedEIP5719 = void 0;
    this.loadTopology = async function (hash) {
      const node = await _this.store.loadV2Node(hash);
      if (!node) return {
        nodeHash: hash
      };
      if (isPlainNode(node)) {
        const [left, right] = await Promise.all([_this.loadTopology(node.left), _this.loadTopology(node.right)]);
        return {
          left,
          right
        };
      }
      if (isPlainNested(node)) {
        return {
          weight: BigInt(node.weight),
          threshold: BigInt(node.threshold),
          tree: await _this.loadTopology(node.tree)
        };
      }
      return node;
    };
    this.saveTopology = async function (node) {
      if (core.v2.config.isNodeLeaf(node)) {
        return; // Nothing to do, this is a dead-end
      }
      const hash = core.v2.config.hashNode(node);
      if (core.v2.config.isNode(node)) {
        const saveLeft = _this.saveTopology(node.left);
        const saveRight = _this.saveTopology(node.right);
        const saveThis = _this.store.saveV2Node(hash, {
          left: core.v2.config.hashNode(node.left),
          right: core.v2.config.hashNode(node.right)
        });
        await Promise.all([saveLeft, saveRight, saveThis]);
        return;
      }
      if (core.v2.config.isNestedLeaf(node)) {
        const saveTree = _this.saveTopology(node.tree);
        const saveThis = _this.store.saveV2Node(hash, {
          weight: BigInt(node.weight).toString(),
          threshold: BigInt(node.threshold).toString(),
          tree: core.v2.config.hashNode(node.tree)
        });
        await Promise.all([saveTree, saveThis]);
        return;
      }

      // If it's a normal leaf, then we just store it
      if (core.v2.config.isSignerLeaf(node)) {
        return _this.store.saveV2Node(hash, {
          address: node.address,
          weight: node.weight
        });
      }
      if (core.v2.config.isSubdigestLeaf(node)) {
        return _this.store.saveV2Node(hash, {
          subdigest: node.subdigest
        });
      }
      throw new Error(`Unknown topology type: ${node}`);
    };
    this.saveWalletConfig = async function (args) {
      const {
        config
      } = args;
      if (core.v1.config.ConfigCoder.isWalletConfig(config)) {
        // We can store the configuration as-is
        const imageHash = core.v1.config.ConfigCoder.imageHashOf(config);
        return _this.store.saveConfig(imageHash, config);
      }
      if (core.v2.config.ConfigCoder.isWalletConfig(config)) {
        // We split the configuration in a list of nodes, and store them individually
        // then we can reconstruct it. This also means we can combine multiple configurations
        // if they share information
        const imageHash = core.v2.config.ConfigCoder.imageHashOf(config);

        // This is an optimization, it allows us to avoid splitting the tree if it's already complete
        if (core.v2.config.isComplete(config.tree)) {
          return _this.store.saveConfig(imageHash, config);
        }

        // TODO: Re-enable storing partial v2 configs once
        // we have more performant code to reconstructing them
        // in the meantime, rely on the remote tracker

        // const storeTree = this.saveTopology(config.tree)
        // const storeConfig = this.store.saveConfig(imageHash, {
        //   version: 2,
        //   threshold: BigInt(config.threshold).toString(),
        //   checkpoint: BigInt(config.checkpoint).toString(),
        //   tree: v2.config.hashNode(config.tree)
        // })

        // await Promise.all([storeTree, storeConfig])
      }
      return;
    };
    this.configOfImageHashCache = {};
    this.configOfImageHash = async function (args) {
      const {
        imageHash
      } = args;
      if (_this.configOfImageHashCache[args.imageHash]) {
        return _this.configOfImageHashCache[args.imageHash];
      }
      const config = await _this.store.loadConfig(imageHash);
      if (!config) {
        return undefined;
      }
      if (config.version === 1 || config.version === 2 && !isPlainV2Config(config)) {
        _this.configOfImageHashCache[args.imageHash] = config;
        return config;
      }
      if (isPlainV2Config(config)) {
        const fullConfig = {
          version: 2,
          threshold: BigInt(config.threshold),
          checkpoint: BigInt(config.checkpoint),
          tree: await _this.loadTopology(config.tree)
        };
        _this.configOfImageHashCache[args.imageHash] = fullConfig;
        return fullConfig;
      }
      throw new Error(`Unknown config type: ${config}`);
    };
    this.saveCounterfactualWallet = async function (args) {
      const {
        config,
        context
      } = args;
      const imageHash = core.universal.genericCoderFor(config.version).config.imageHashOf(config);
      await Promise.all([_this.saveWalletConfig({
        config
      }), ...context.map(ctx => {
        const address = core.commons.context.addressOf(ctx, imageHash);
        return _this.store.saveCounterfactualWallet(address, imageHash, ctx);
      })]);
    };
    this.imageHashOfCounterfactualWallet = async function (args) {
      const {
        wallet
      } = args;
      const result = await _this.store.loadCounterfactualWallet(wallet);
      if (!result) return undefined;
      return {
        imageHash: result.imageHash,
        context: result.context
      };
    };
    this.savePayload = async function (args) {
      const {
        payload
      } = args;
      const subdigest = core.commons.signature.subdigestOf(payload);
      await _this.store.savePayloadOfSubdigest(subdigest, payload);
    };
    this.payloadOfSubdigestCache = {};
    this.payloadOfSubdigest = async function (args) {
      if (_this.payloadOfSubdigestCache[args.subdigest]) {
        return _this.payloadOfSubdigestCache[args.subdigest];
      }
      const {
        subdigest
      } = args;
      const res = await _this.store.loadPayloadOfSubdigest(subdigest);
      if (res) {
        _this.payloadOfSubdigestCache[subdigest] = res;
      }
      return res;
    };
    this.savePresignedConfiguration = async function (args) {
      // Presigned configurations only work with v2 (for now)
      // so we can assume that the signature is for a v2 configuration
      const decoded = core.v2.signature.SignatureCoder.decode(args.signature);
      const nextImageHash = core.universal.genericCoderFor(args.nextConfig.version).config.imageHashOf(args.nextConfig);
      const message = core.v2.chained.messageSetImageHash(nextImageHash);
      const digest = ethers.ethers.keccak256(message);
      const payload = {
        message,
        address: args.wallet,
        chainId: 0,
        digest
      };
      const savePayload = _this.savePayload({
        payload
      });
      const saveNextConfig = _this.saveWalletConfig({
        config: args.nextConfig
      });
      const recovered = await core.v2.signature.SignatureCoder.recover(decoded, payload, _this.provider);

      // Save the recovered configuration and all signature parts
      const signatures = core.v2.signature.signaturesOf(recovered.config.tree);
      await Promise.all([savePayload, saveNextConfig, _this.saveWalletConfig({
        config: recovered.config
      }), ...signatures.map(sig => _this.store.saveSignatureOfSubdigest(sig.address, recovered.subdigest, sig.signature))]);
    };
    this.loadPresignedConfiguration = async function (args) {
      const {
        wallet,
        fromImageHash,
        longestPath
      } = args;
      const fromConfig = await _this.configOfImageHash({
        imageHash: fromImageHash
      });
      if (!fromConfig || !core.v2.config.ConfigCoder.isWalletConfig(fromConfig)) {
        return [];
      }

      // Get all subdigests for the config members
      const signers = core.v2.config.signersOf(fromConfig.tree).map(s => s.address);
      const subdigestsOfSigner = await Promise.all(signers.map(s => _this.store.loadSubdigestsOfSigner(s)));
      const subdigests = [...new Set(subdigestsOfSigner.flat())];

      // Get all unique payloads
      const payloads = await Promise.all([...new Set(subdigests)].map(async function (s) {
        return _extends({}, await _this.payloadOfSubdigest({
          subdigest: s
        }), {
          subdigest: s
        });
      }));

      // Get all possible next imageHashes based on the payloads
      const nextImageHashes = payloads.filter(p => (p == null ? void 0 : p.message) && (p == null ? void 0 : p.address) && p.address === wallet).map(p => ({
        payload: p,
        nextImageHash: core.v2.chained.decodeMessageSetImageHash(p.message)
      })).filter(p => p == null ? void 0 : p.nextImageHash);

      // Build a signature for each next imageHash
      // and filter out the ones that don't have enough weight
      let bestCandidate;
      const nextConfigsAndCheckpoints = await Promise.all(nextImageHashes.map(async function ({
        nextImageHash,
        payload
      }) {
        const nextConfig = await _this.configOfImageHash({
          imageHash: nextImageHash
        });
        if (!nextConfig || !core.v2.config.isWalletConfig(nextConfig)) return undefined;
        const nextCheckpoint = BigInt(nextConfig.checkpoint);
        return {
          nextConfig,
          nextCheckpoint,
          nextImageHash,
          payload
        };
      }));
      const sortedNextConfigsAndCheckpoints = nextConfigsAndCheckpoints.filter(c => c !== undefined).filter(c => c.nextCheckpoint > BigInt(fromConfig.checkpoint)).sort((a, b) =>
      // If we are looking for the longest path, sort by ascending checkpoint
      // because we want to find the smalles jump, and we should start with the
      // closest one. If we are not looking for the longest path, sort by
      // descending checkpoint, because we want to find the largest jump.
      //
      // We don't have a guarantee that all "next configs" will be valid
      // so worst case scenario we will need to try all of them.
      // But we can try to optimize for the most common case.
      a.nextCheckpoint > b.nextCheckpoint ? longestPath ? 1 : -1 : longestPath ? -1 : 1);
      for (const entry of sortedNextConfigsAndCheckpoints) {
        const {
          nextConfig,
          nextCheckpoint,
          nextImageHash,
          payload
        } = entry;
        if (bestCandidate) {
          const bestCheckpoint = bestCandidate.checkpoint;
          if (longestPath) {
            // Only consider candidates earlier than our current best
            if (nextCheckpoint >= bestCheckpoint) continue;
          } else {
            // Only consider candidates later than our current best
            if (nextCheckpoint <= bestCheckpoint) continue;
          }
        }

        // Get all signatures (for all signers) for this subdigest
        const signatures = new Map((await Promise.all(signers.map(async function (signer) {
          const signature = await _this.store.loadSignatureOfSubdigest(signer, payload.subdigest);
          if (!signature) {
            return [signer, undefined];
          }
          const replacedSignature = ethers.ethers.hexlify(_this.useEIP5719 ? await _this.cachedEIP5719.runByEIP5719(signer, payload.subdigest, signature) : signature);
          const isDynamic = core.commons.signer.tryRecoverSigner(payload.subdigest, replacedSignature) !== signer;
          return [signer, {
            isDynamic,
            signature: replacedSignature
          }];
        }))).filter(signature => Boolean(signature[1])));

        // Skip if we don't have ANY signatures (it can never reach the threshold)
        if (signatures.size === 0) continue;

        // Encode the full signature (to see if it has enough weight)
        const encoded = core.v2.signature.SignatureCoder.encodeSigners(fromConfig, signatures, [], 0);
        if (encoded.weight < BigInt(fromConfig.threshold)) continue;

        // Save the new best candidate
        bestCandidate = {
          nextImageHash,
          checkpoint: BigInt(nextConfig.checkpoint),
          signature: encoded.encoded
        };
      }
      if (!bestCandidate) {
        return [];
      }

      // Get the next step
      const nextStep = await _this.loadPresignedConfiguration({
        wallet,
        fromImageHash: bestCandidate.nextImageHash,
        longestPath
      });
      return [{
        wallet,
        nextImageHash: bestCandidate.nextImageHash,
        signature: bestCandidate.signature
      }, ...nextStep];
    };
    this.saveWitnesses = async function (args) {
      const payload = {
        digest: args.digest,
        address: args.wallet,
        chainId: args.chainId
      };
      const subdigest = core.commons.signature.subdigestOf(payload);
      await Promise.all([_this.savePayload({
        payload
      }), ...args.signatures.filter(signature => {
        // We don't support saving witnesses for non-recoverable signatures
        // we could change this eventually, but the issue is that the witness may become invalid
        return core.commons.signer.canRecover(signature);
      }).map(signature => {
        const signer = core.commons.signer.recoverSigner(subdigest, signature);
        return _this.store.saveSignatureOfSubdigest(signer, subdigest, signature);
      })]);
    };
    this.walletsOfSigner = async function (args) {
      const subdigests = await _this.store.loadSubdigestsOfSigner(args.signer);
      const payloads = await Promise.all(subdigests.map(s => _this.payloadOfSubdigest({
        subdigest: s
      }))).then(p => p.filter(p => p !== undefined));

      // filter unique wallets, and provide a proof for each wallet
      const result = [];
      for (const payload of payloads) {
        const wallet = payload.address;
        if (result.find(r => r.wallet === wallet)) continue;
        const subdigest = core.commons.signature.subdigestOf(payload);
        const signature = await _this.store.loadSignatureOfSubdigest(args.signer, subdigest);
        if (!signature) continue;
        result.push({
          wallet,
          proof: {
            digest: payload.digest,
            chainId: BigInt(payload.chainId),
            signature: ethers.ethers.hexlify(signature)
          }
        });
      }
      return result;
    };
    this.cachedEIP5719 = new replacer.CachedEIP5719(provider);
  }
  async saveMigration(address, signed, contexts) {
    const fromVersion = signed.fromVersion;
    if (fromVersion !== 1) throw new Error('Migration not supported');
    if (!core.v2.config.isWalletConfig(signed.toConfig)) throw new Error('Invalid to config');

    // Validate migration transaction
    const {
      newImageHash,
      address: decodedAddress
    } = migration.migration.v1v2.decodeTransaction(signed.tx, contexts);
    if (decodedAddress !== address) throw new Error('Invalid migration transaction - address');
    if (core.v2.config.ConfigCoder.imageHashOf(signed.toConfig) != newImageHash) throw new Error('Invalid migration transaction - config');

    // Split signature and save each part
    const message = core.commons.transaction.packMetaTransactionsData(signed.tx.nonce, signed.tx.transactions);
    const digest = ethers.ethers.keccak256(message);
    const payload = {
      chainId: signed.tx.chainId,
      message,
      address,
      digest
    };
    const subdigest = core.commons.signature.subdigestOf(payload);
    const savePayload = this.savePayload({
      payload
    });
    const saveToConfig = this.saveWalletConfig({
      config: signed.toConfig
    });
    const decoded = core.v1.signature.SignatureCoder.decode(signed.tx.signature);
    const recovered = await core.v1.signature.SignatureCoder.recover(decoded, payload, this.provider);

    // Save the recovered config, the migrate transaction, and all signature parts
    const signatures = core.v1.signature.SignatureCoder.signaturesOf(recovered.config);
    await Promise.all([savePayload, saveToConfig, this.saveWalletConfig({
      config: recovered.config
    }), this.store.saveMigrationsSubdigest(address, fromVersion, fromVersion + 1, subdigest, newImageHash), ...signatures.map(sig => this.store.saveSignatureOfSubdigest(sig.address, recovered.subdigest, sig.signature))]);
  }
  async getMigration(address, fromImageHash, fromVersion, chainId) {
    var _this2 = this;
    // Get the current config and all possible migration payloads
    const [currentConfig, txs] = await Promise.all([this.configOfImageHash({
      imageHash: fromImageHash
    }), this.store.loadMigrationsSubdigest(address, fromVersion, fromVersion + 1)]);
    const coder = core.universal.coderFor(fromVersion);
    if (!currentConfig) {
      // We may not be able to find the config, because the migration is still not copied locally
      // in that case we consider as we don't have any migration
      return undefined;
    }
    if (!coder.config.isWalletConfig(currentConfig)) {
      // throw new Error("Invalid from config - version")
      // better to not fail here, some other tracker may be able to handle this migration
      return undefined;
    }

    // We need to process every migration candidate individually
    // and see which one has enough signers to be valid (for the current config)
    const candidates = await Promise.all(txs.map(async function (tx) {
      const {
        subdigest,
        toImageHash
      } = tx;
      const payload = await _this2.payloadOfSubdigest({
        subdigest
      });
      if (!payload || !payload.message) return undefined;
      if (BigInt(chainId) !== BigInt(payload.chainId)) return undefined;
      const signers = coder.config.signersOf(currentConfig).map(s => s.address);

      // Get all signatures (for all signers) for this subdigest
      const signatures = new Map((await Promise.all(signers.map(async function (signer) {
        const signature = await _this2.store.loadSignatureOfSubdigest(signer, subdigest);
        if (!signature) {
          return [signer, undefined];
        }
        const replacedSignature = ethers.ethers.hexlify(_this2.useEIP5719 ? await _this2.cachedEIP5719.runByEIP5719(signer, subdigest, signature) : signature);
        const isDynamic = core.commons.signer.tryRecoverSigner(subdigest, replacedSignature) !== signer;
        return [signer, {
          isDynamic,
          signature: replacedSignature
        }];
      }))).filter(signature => Boolean(signature[1])));

      // Encode signature parts into a single signature
      const encoded = coder.signature.encodeSigners(currentConfig, signatures, [], chainId);
      if (!encoded || encoded.weight < BigInt(currentConfig.threshold)) return undefined;

      // Unpack payload (it should have transactions)
      const [nonce, transactions] = core.commons.transaction.unpackMetaTransactionsData(payload.message);
      return {
        tx: {
          entrypoint: address,
          transactions: core.commons.transaction.fromTxAbiEncode(transactions),
          chainId: chainId,
          nonce: nonce,
          signature: encoded.encoded,
          intent: {
            id: subdigest,
            wallet: address
          }
        },
        toConfig: await _this2.configOfImageHash({
          imageHash: toImageHash
        }),
        fromVersion,
        toVersion: fromVersion + 1
      };
    })).then(c => c.filter(c => c !== undefined));

    // Return the first valid candidate
    return candidates[0];
  }
  updateProvider(provider) {
    this.provider = provider;
  }
}

var local = /*#__PURE__*/Object.freeze({
  __proto__: null,
  LocalConfigTracker: LocalConfigTracker
});

//
// Types
//

let SignatureType = /*#__PURE__*/function (SignatureType) {
  SignatureType["EIP712"] = "EIP712";
  SignatureType["EthSign"] = "EthSign";
  SignatureType["EIP1271"] = "EIP1271";
  return SignatureType;
}({});
//
// Client
//
class Sessions {
  constructor(hostname, fetch) {
    this.hostname = void 0;
    this.fetch = void 0;
    this.path = '/rpc/Sessions/';
    this.ping = (headers, signal) => {
      return this.fetch(this.url('Ping'), createHTTPRequest({}, headers, signal)).then(res => {
        return buildResponse(res).then(_data => {
          return {};
        });
      }, error => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ''}`
        });
      });
    };
    this.config = (args, headers, signal) => {
      return this.fetch(this.url('Config'), createHTTPRequest(args, headers, signal)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            version: _data.version,
            config: _data.config
          };
        });
      }, error => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ''}`
        });
      });
    };
    this.wallets = (args, headers, signal) => {
      return this.fetch(this.url('Wallets'), createHTTPRequest(args, headers, signal)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            wallets: _data.wallets
          };
        });
      }, error => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ''}`
        });
      });
    };
    this.deployHash = (args, headers, signal) => {
      return this.fetch(this.url('DeployHash'), createHTTPRequest(args, headers, signal)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            deployHash: _data.deployHash,
            context: _data.context
          };
        });
      }, error => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ''}`
        });
      });
    };
    this.configUpdates = (args, headers, signal) => {
      return this.fetch(this.url('ConfigUpdates'), createHTTPRequest(args, headers, signal)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            updates: _data.updates
          };
        });
      }, error => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ''}`
        });
      });
    };
    this.migrations = (args, headers, signal) => {
      return this.fetch(this.url('Migrations'), createHTTPRequest(args, headers, signal)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            migrations: _data.migrations
          };
        });
      }, error => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ''}`
        });
      });
    };
    this.saveConfig = (args, headers, signal) => {
      return this.fetch(this.url('SaveConfig'), createHTTPRequest(args, headers, signal)).then(res => {
        return buildResponse(res).then(_data => {
          return {};
        });
      }, error => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ''}`
        });
      });
    };
    this.saveWallet = (args, headers, signal) => {
      return this.fetch(this.url('SaveWallet'), createHTTPRequest(args, headers, signal)).then(res => {
        return buildResponse(res).then(_data => {
          return {};
        });
      }, error => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ''}`
        });
      });
    };
    this.saveSignature = (args, headers, signal) => {
      return this.fetch(this.url('SaveSignature'), createHTTPRequest(args, headers, signal)).then(res => {
        return buildResponse(res).then(_data => {
          return {};
        });
      }, error => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ''}`
        });
      });
    };
    this.saveSignerSignatures = (args, headers, signal) => {
      return this.fetch(this.url('SaveSignerSignatures'), createHTTPRequest(args, headers, signal)).then(res => {
        return buildResponse(res).then(_data => {
          return {};
        });
      }, error => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ''}`
        });
      });
    };
    this.saveMigration = (args, headers, signal) => {
      return this.fetch(this.url('SaveMigration'), createHTTPRequest(args, headers, signal)).then(res => {
        return buildResponse(res).then(_data => {
          return {};
        });
      }, error => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ''}`
        });
      });
    };
    this.hostname = hostname;
    this.fetch = (input, init) => fetch(input, init);
  }
  url(name) {
    return this.hostname + this.path + name;
  }
}
const createHTTPRequest = (body = {}, headers = {}, signal = null) => {
  return {
    method: 'POST',
    headers: _extends({}, headers, {
      'Content-Type': 'application/json'
    }),
    body: JSON.stringify(body || {}),
    signal
  };
};
const buildResponse = res => {
  return res.text().then(text => {
    let data;
    try {
      data = JSON.parse(text);
    } catch (error) {
      let message = '';
      if (error instanceof Error) {
        message = error.message;
      }
      throw WebrpcBadResponseError.new({
        status: res.status,
        cause: `JSON.parse(): ${message}: response text: ${text}`
      });
    }
    if (!res.ok) {
      const code = typeof data.code === 'number' ? data.code : 0;
      throw (webrpcErrorByCode[code] || WebrpcError).new(data);
    }
    return data;
  });
};

//
// Errors
//

class WebrpcError extends Error {
  constructor(name, code, message, status, cause) {
    super(message);
    this.name = void 0;
    this.code = void 0;
    this.message = void 0;
    this.status = void 0;
    this.cause = void 0;
    /** @deprecated Use message instead of msg. Deprecated in webrpc v0.11.0. */
    this.msg = void 0;
    this.name = name || 'WebrpcError';
    this.code = typeof code === 'number' ? code : 0;
    this.message = message || `endpoint error ${this.code}`;
    this.msg = this.message;
    this.status = typeof status === 'number' ? status : 0;
    this.cause = cause;
    Object.setPrototypeOf(this, WebrpcError.prototype);
  }
  static new(payload) {
    return new this(payload.error, payload.code, payload.message || payload.msg, payload.status, payload.cause);
  }
}

// Webrpc errors

class WebrpcEndpointError extends WebrpcError {
  constructor(name = 'WebrpcEndpoint', code = 0, message = 'endpoint error', status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, WebrpcEndpointError.prototype);
  }
}
class WebrpcRequestFailedError extends WebrpcError {
  constructor(name = 'WebrpcRequestFailed', code = -1, message = 'request failed', status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, WebrpcRequestFailedError.prototype);
  }
}
class WebrpcBadRouteError extends WebrpcError {
  constructor(name = 'WebrpcBadRoute', code = -2, message = 'bad route', status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, WebrpcBadRouteError.prototype);
  }
}
class WebrpcBadMethodError extends WebrpcError {
  constructor(name = 'WebrpcBadMethod', code = -3, message = 'bad method', status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, WebrpcBadMethodError.prototype);
  }
}
class WebrpcBadRequestError extends WebrpcError {
  constructor(name = 'WebrpcBadRequest', code = -4, message = 'bad request', status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, WebrpcBadRequestError.prototype);
  }
}
class WebrpcBadResponseError extends WebrpcError {
  constructor(name = 'WebrpcBadResponse', code = -5, message = 'bad response', status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, WebrpcBadResponseError.prototype);
  }
}
class WebrpcServerPanicError extends WebrpcError {
  constructor(name = 'WebrpcServerPanic', code = -6, message = 'server panic', status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, WebrpcServerPanicError.prototype);
  }
}
class WebrpcInternalErrorError extends WebrpcError {
  constructor(name = 'WebrpcInternalError', code = -7, message = 'internal error', status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, WebrpcInternalErrorError.prototype);
  }
}
class WebrpcClientDisconnectedError extends WebrpcError {
  constructor(name = 'WebrpcClientDisconnected', code = -8, message = 'client disconnected', status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, WebrpcClientDisconnectedError.prototype);
  }
}
class WebrpcStreamLostError extends WebrpcError {
  constructor(name = 'WebrpcStreamLost', code = -9, message = 'stream lost', status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, WebrpcStreamLostError.prototype);
  }
}
class WebrpcStreamFinishedError extends WebrpcError {
  constructor(name = 'WebrpcStreamFinished', code = -10, message = 'stream finished', status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, WebrpcStreamFinishedError.prototype);
  }
}

// Schema errors

class InvalidArgumentError extends WebrpcError {
  constructor(name = 'InvalidArgument', code = 1, message = 'invalid argument', status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, InvalidArgumentError.prototype);
  }
}
class NotFoundError extends WebrpcError {
  constructor(name = 'NotFound', code = 2, message = 'not found', status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, NotFoundError.prototype);
  }
}
const webrpcErrorByCode = {
  [0]: WebrpcEndpointError,
  [-1]: WebrpcRequestFailedError,
  [-2]: WebrpcBadRouteError,
  [-3]: WebrpcBadMethodError,
  [-4]: WebrpcBadRequestError,
  [-5]: WebrpcBadResponseError,
  [-6]: WebrpcServerPanicError,
  [-7]: WebrpcInternalErrorError,
  [-8]: WebrpcClientDisconnectedError,
  [-9]: WebrpcStreamLostError,
  [-10]: WebrpcStreamFinishedError,
  [1]: InvalidArgumentError,
  [2]: NotFoundError
};

class RemoteConfigTracker {
  constructor(hostname, onlyRecoverable = true) {
    this.onlyRecoverable = onlyRecoverable;
    this.sessions = void 0;
    this.sessions = new Sessions(hostname, fetch);
  }
  async loadPresignedConfiguration(args) {
    try {
      const {
        updates
      } = await this.sessions.configUpdates({
        wallet: args.wallet,
        fromImageHash: args.fromImageHash,
        allUpdates: args.longestPath
      });
      return updates.map(({
        toImageHash,
        signature
      }) => ({
        wallet: args.wallet,
        nextImageHash: toImageHash,
        signature
      }));
    } catch (error) {
      if (is404NotFound(error)) {
        return [];
      } else {
        throw error;
      }
    }
  }
  async savePresignedConfiguration(args) {
    const config = args.nextConfig;
    const imageHash = core.universal.genericCoderFor(config.version).config.imageHashOf(config);
    const message = core.v2.signature.setImageHashStruct(imageHash);
    const digest = ethers.ethers.keccak256(message);
    await this.sessions.saveSignature({
      wallet: args.wallet,
      digest,
      chainID: '0',
      signature: args.signature,
      toConfig: encodeConfig(config)
    });
  }
  async saveWitnesses(args) {
    let filteredSignatures = args.signatures;
    if (this.onlyRecoverable) {
      filteredSignatures = filteredSignatures.filter(signature => {
        return core.commons.signer.canRecover(signature);
      });
    }
    await this.sessions.saveSignerSignatures({
      wallet: args.wallet,
      digest: args.digest,
      chainID: numberString(args.chainId),
      signatures: filteredSignatures
    });
  }
  async configOfImageHash(args) {
    try {
      const {
        version,
        config
      } = await this.sessions.config(args);
      return decodeConfig(version, config);
    } catch (error) {
      if (is404NotFound(error)) {
        return;
      } else {
        throw error;
      }
    }
  }
  async saveWalletConfig(args) {
    const config = encodeConfig(args.config);
    await this.sessions.saveConfig({
      version: args.config.version,
      config
    });
  }
  async imageHashOfCounterfactualWallet(args) {
    try {
      const {
        deployHash,
        context
      } = await this.sessions.deployHash(args);
      return {
        imageHash: deployHash,
        context
      };
    } catch (error) {
      if (is404NotFound(error)) {
        return;
      } else {
        throw error;
      }
    }
  }
  async saveCounterfactualWallet(args) {
    const deployConfig = encodeConfig(args.config);
    await this.sessions.saveWallet({
      version: args.config.version,
      deployConfig
    });
  }
  async walletsOfSigner(args) {
    const {
      wallets
    } = await this.sessions.wallets(args);
    return Object.entries(wallets).map(([wallet, {
      digest,
      chainID,
      type,
      signature
    }]) => {
      switch (type) {
        case SignatureType.EIP712:
          signature += ethers.ethers.toBeHex(core.commons.signer.SigType.EIP712).slice(2);
          break;
        case SignatureType.EthSign:
          signature += ethers.ethers.toBeHex(core.commons.signer.SigType.ETH_SIGN).slice(2);
          break;
        case SignatureType.EIP1271:
          signature += ethers.ethers.toBeHex(core.commons.signer.SigType.WALLET_BYTES32).slice(2);
          break;
      }
      return {
        wallet,
        proof: {
          digest,
          signature,
          chainId: BigInt(chainID)
        }
      };
    });
  }
  async getMigration(wallet, fromImageHash, fromVersion, chainId) {
    var _this = this;
    const chainIdString = numberString(chainId);
    const {
      migrations
    } = await this.sessions.migrations({
      wallet,
      fromVersion,
      fromImageHash,
      chainID: chainIdString
    });
    const chooseMigration = async function chooseMigration(chainId) {
      const migrations_ = migrations[chainId];
      if (migrations_) {
        const toVersions = Object.keys(migrations_).map(Number).sort((a, b) => b - a);
        for (const toVersion of toVersions) {
          for (const [toHash, transactions] of Object.entries(migrations_[toVersion])) {
            try {
              const toConfig = await _this.configOfImageHash({
                imageHash: toHash
              });
              if (toConfig) {
                return {
                  fromVersion,
                  toVersion,
                  toConfig,
                  tx: {
                    entrypoint: transactions.executor,
                    transactions: transactions.transactions,
                    nonce: transactions.nonce,
                    signature: transactions.signature,
                    chainId,
                    intent: {
                      id: core.commons.transaction.subdigestOfTransactions(wallet, chainId, transactions.nonce, transactions.transactions),
                      wallet
                    }
                  }
                };
              }
            } catch (error) {
              console.error(error);
            }
          }
        }
      }
      return;
    };
    const migration = await chooseMigration(chainIdString);
    if (migration) {
      return migration;
    }
    for (const _chainId in migrations) {
      if (_chainId !== chainIdString) {
        const _migration = await chooseMigration(_chainId);
        if (_migration) {
          return _migration;
        }
      }
    }
    return;
  }
  async saveMigration(wallet, signed, _contexts) {
    await this.sessions.saveMigration({
      wallet,
      fromVersion: signed.fromVersion,
      toVersion: signed.toVersion,
      toConfig: encodeConfig(signed.toConfig),
      executor: signed.tx.entrypoint,
      transactions: signed.tx.transactions.map(encodeTransaction),
      nonce: numberString(signed.tx.nonce),
      signature: signed.tx.signature,
      chainID: numberString(signed.tx.chainId)
    });
  }
}
function encodeConfig(config) {
  switch (config.version) {
    case 1:
      if (core.v1.config.ConfigCoder.isWalletConfig(config)) {
        return {
          threshold: numberNumber(config.threshold),
          signers: config.signers.map(({
            weight,
            address
          }) => ({
            weight: numberNumber(weight),
            address
          }))
        };
      } else {
        throw new Error(`not a v${config.version} config: ${config}`);
      }
    case 2:
      if (core.v2.config.ConfigCoder.isWalletConfig(config)) {
        return {
          threshold: numberNumber(config.threshold),
          checkpoint: numberNumber(config.checkpoint),
          tree: encodeV2ConfigTree(config.tree)
        };
      } else {
        throw new Error(`not a v${config.version} config: ${config}`);
      }
    default:
      throw new Error(`unknown version ${config.version}`);
  }
}
function encodeV2ConfigTree(tree) {
  if (core.v2.config.isNode(tree)) {
    return {
      left: encodeV2ConfigTree(tree.left),
      right: encodeV2ConfigTree(tree.right)
    };
  } else if (core.v2.config.isSignerLeaf(tree)) {
    return {
      weight: numberNumber(tree.weight),
      address: tree.address
    };
  } else if (core.v2.config.isNestedLeaf(tree)) {
    return {
      weight: numberNumber(tree.weight),
      threshold: numberNumber(tree.threshold),
      tree: encodeV2ConfigTree(tree.tree)
    };
  } else if (core.v2.config.isNodeLeaf(tree)) {
    return {
      node: tree.nodeHash
    };
  } else {
    return _extends({}, tree);
  }
}
function decodeConfig(version, config) {
  switch (version) {
    case 1:
      return _extends({}, config, {
        version
      });
    case 2:
      return _extends({}, config, {
        version,
        tree: decodeV2ConfigTree(config.tree)
      });
    default:
      throw new Error(`unknown version ${version}`);
  }
}
function decodeV2ConfigTree(tree) {
  switch (typeof tree) {
    case 'object':
      const tree_ = _extends({}, tree);
      if (tree_.left !== undefined) {
        tree_.left = decodeV2ConfigTree(tree_.left);
      }
      if (tree_.right !== undefined) {
        tree_.right = decodeV2ConfigTree(tree_.right);
      }
      if (tree_.tree !== undefined) {
        tree_.tree = decodeV2ConfigTree(tree_.tree);
      }
      if (tree_.node !== undefined) {
        tree_.nodeHash = tree_.node;
        delete tree_.node;
      }
      return tree_;
    default:
      throw new Error(`v2 config tree ${tree} is not an object`);
  }
}
function encodeTransaction(transaction) {
  return {
    to: transaction.to,
    value: transaction.value !== undefined ? numberString(transaction.value) : undefined,
    data: transaction.data !== undefined ? ethers.ethers.hexlify(transaction.data) : undefined,
    gasLimit: transaction.gasLimit !== undefined ? numberString(transaction.gasLimit) : undefined,
    delegateCall: transaction.delegateCall,
    revertOnError: transaction.revertOnError
  };
}
function numberNumber(n) {
  return Number(n);
}
function numberString(n) {
  return BigInt(n).toString();
}
function is404NotFound(error) {
  return typeof error === 'object' && error.status === 404;
}

var index$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  RemoteConfigTracker: RemoteConfigTracker
});

function raceUntil(promises, fallback, evalRes) {
  return new Promise(resolve => {
    let count = 0;
    promises.forEach(p => p.then(val => {
      if (evalRes(val)) {
        resolve(val);
      } else {
        count++;
        if (count === promises.length) {
          resolve(fallback);
        }
      }
    }).catch(() => {
      // Ignore
      count++;
      if (count === promises.length) {
        resolve(fallback);
      }
    }));
  });
}
async function allSafe(promises, fallback) {
  return Promise.all(promises.map(promise => promise.catch(() => fallback)));
}
class MultipleTracker {
  constructor(trackers) {
    this.trackers = trackers;
  }
  async configOfImageHash(args) {
    const requests = this.trackers.map(async function (t, i) {
      return {
        res: await t.configOfImageHash(args),
        i
      };
    });

    // We try to find a complete configuration, we race so that we don't wait for all trackers to respond
    const result1 = await raceUntil(requests, undefined, val => {
      if ((val == null ? void 0 : val.res) === undefined) return false;
      return core.universal.genericCoderFor(val.res.version).config.isComplete(val.res);
    });
    if (result1 != null && result1.res) {
      // Skip saving the config to the tracker that returned the result
      this.saveWalletConfig({
        config: result1.res,
        skipTracker: result1.i
      });
      return result1.res;
    }

    // If we haven't found a complete configuration yet, it either means that the configuration is not complete
    // (and thus we need to combine all results) or that the configuration is not found at all
    // but we try to combine all results anyway
    const tmptracker = new LocalConfigTracker(undefined); // TODO: Fix this, provider not needed anyway

    const results = await allSafe(requests, undefined);
    for (const r of results) {
      if (r != null && r.res) await tmptracker.saveWalletConfig({
        config: r.res
      });
    }
    const result2 = await tmptracker.configOfImageHash(args);
    if (result2) this.saveWalletConfig({
      config: result2
    });
    return result2;
  }
  async saveWalletConfig(args) {
    await Promise.all(this.trackers.map((t, i) => {
      if (i === args.skipTracker) return;
      return t.saveWalletConfig(args);
    }));
  }
  async imageHashOfCounterfactualWallet(args) {
    const imageHash = await raceUntil(this.trackers.map(t => t.imageHashOfCounterfactualWallet(args)), undefined, result => Boolean(result));
    if (imageHash) {
      this.configOfImageHash({
        imageHash: imageHash.imageHash
      }).then(config => {
        if (config) {
          this.saveCounterfactualWallet({
            config,
            context: [imageHash.context]
          });
        }
      });
    }
    return imageHash;
  }
  async saveCounterfactualWallet(args) {
    await Promise.all(this.trackers.map((t, i) => {
      if (i === args.skipTracker) return;
      return t.saveCounterfactualWallet(args);
    }));
  }
  async walletsOfSigner(args) {
    // We can't race here, because there is no "correct" response
    // we just return the union of all results, skipping duplicates
    const results = await allSafe(this.trackers.map(t => t.walletsOfSigner(args)), []).then(r => r.flat());
    const wallets = {};
    for (const r of results) {
      wallets[r.wallet] = r.proof;
    }

    // TODO: This will send redundant information back to the trackers
    // consider optimizing this for better performance during login

    const result = Object.keys(wallets).map(w => ({
      wallet: w,
      proof: wallets[w]
    }));
    const witnesses = new Map();
    result.forEach(({
      wallet,
      proof: {
        digest,
        chainId,
        signature
      }
    }) => {
      const key = `${wallet}-${digest}-${chainId}`;
      let signatures = witnesses.get(key);
      if (!signatures) {
        signatures = {
          wallet,
          digest,
          chainId,
          signatures: []
        };
        witnesses.set(key, signatures);
      }
      signatures.signatures.push(signature);
    });
    witnesses.forEach(witnesses => this.saveWitnesses(witnesses));
    return result;
  }
  async saveWitnesses(args) {
    await Promise.all(this.trackers.map(t => t.saveWitnesses(args)));
  }
  async loadPresignedConfiguration(args) {
    var _this = this;
    // We can't race here, because any of the trackers could have a new "link" in the chain
    const results = await allSafe(this.trackers.map(t => t.loadPresignedConfiguration(args)), []);

    // The "best" result is the one with the highest checkpoint
    const checkpoints = await allSafe(results.map(async function (r) {
      const last = r[r.length - 1];

      // TODO: This will fire a lot of requests, optimize it
      const config = await _this.configOfImageHash({
        imageHash: last.nextImageHash
      });
      if (!config) return undefined;
      return {
        checkpoint: core.universal.genericCoderFor(config.version).config.checkpointOf(config),
        result: r
      };
    }), undefined);
    const best = checkpoints.reduce((acc, val) => {
      if (!val) return acc;
      if (!acc) return val;
      if (val.checkpoint > acc.checkpoint) return val;
      return acc;
    });
    if (!best) return [];
    const configs = new Map();
    const config = imageHash => {
      if (!configs.has(imageHash)) {
        configs.set(imageHash, this.configOfImageHash({
          imageHash
        }));
      }
      return configs.get(imageHash);
    };
    best.result.forEach(async function (res) {
      const nextConfig = await config(res.nextImageHash);
      if (nextConfig) {
        _this.savePresignedConfiguration({
          wallet: args.wallet,
          nextConfig,
          signature: res.signature
        });
      }
    });
    return best.result;
  }
  async savePresignedConfiguration(args) {
    await Promise.all(this.trackers.map(t => t.savePresignedConfiguration(args)));
  }
  async getMigration(address, fromImageHash, fromVersion, chainId) {
    // TODO: Backfeed migration results to other trackers
    const results = await Promise.all(this.trackers.map(t => t.getMigration(address, fromImageHash, fromVersion, chainId)));
    return results.find(r => !!r);
  }
  async saveMigration(address, signed, contexts) {
    await Promise.all(this.trackers.map(t => t.saveMigration(address, signed, contexts)));
  }
}

class CachedTracker {
  constructor(tracker, cache, contexts) {
    this.tracker = tracker;
    this.cache = cache;
    this.contexts = contexts;
  }
  async loadPresignedConfiguration(args) {
    var _this = this;
    // We need to check both, and return the one with the highest checkpoint
    // eventually we could try to combine them, but for now we'll just return
    // the one with the highest checkpoint
    const results = [this.tracker.loadPresignedConfiguration(args), this.cache.loadPresignedConfiguration(args)];
    let best;

    // If both results end with the same image hash, we can just return the longest/shortest one
    const [result1, result2] = await Promise.all(results);
    if (result1.length > 0 && result2.length > 0 && result1[result1.length - 1].nextImageHash === result2[result2.length - 1].nextImageHash) {
      best = args.longestPath === true ? result1.length > result2.length ? result1 : result2 : result1.length < result2.length ? result1 : result2;
    } else {
      var _checkpoints$reduce$r, _checkpoints$reduce;
      // Otherwise we need to check the checkpoints
      // this requires us to fetch the config for each image hash
      const checkpoints = await Promise.all(results.map(async function (result) {
        const r = await result;
        const last = r[r.length - 1];
        if (!last) return undefined;

        // TODO: This will fire a lot of requests, optimize it
        const config = await _this.configOfImageHash({
          imageHash: last.nextImageHash
        });
        if (!config) return undefined;
        return {
          checkpoint: core.universal.genericCoderFor(config.version).config.checkpointOf(config),
          result: r
        };
      }));
      best = (_checkpoints$reduce$r = (_checkpoints$reduce = checkpoints.reduce((acc, val) => {
        if (!val) return acc;
        if (!acc) return val;
        if (val.checkpoint > acc.checkpoint) return val;
        return acc;
      })) == null ? void 0 : _checkpoints$reduce.result) != null ? _checkpoints$reduce$r : [];
    }
    if (!best) return [];
    return best;
  }
  async savePresignedConfiguration(args) {
    await Promise.all([this.tracker.savePresignedConfiguration(args), this.cache.savePresignedConfiguration(args)]);
  }
  async configOfImageHash(args) {
    // We first check the cache, if it's not there, we check the tracker
    // and then we save it to the cache
    if (args.noCache !== true) {
      const config = await this.cache.configOfImageHash(args);
      if (config) return config;
    }
    const config2 = await this.tracker.configOfImageHash(args);
    if (config2) {
      await this.cache.saveWalletConfig({
        config: config2
      });
    }
    return config2;
  }
  async saveWalletConfig(args) {
    await Promise.all([this.tracker.saveWalletConfig(args), this.cache.saveWalletConfig(args)]);
  }
  async imageHashOfCounterfactualWallet(args) {
    // We first check the cache, if it's not there, we check the tracker
    // and then we save it to the cache
    if (args.noCache !== true) {
      const result1 = await this.cache.imageHashOfCounterfactualWallet(args);
      if (result1) return result1;
    }
    const result2 = await this.tracker.imageHashOfCounterfactualWallet(args);
    if (result2) {
      // TODO: We shouldn't need to get the config to save the counterfactual wallet
      const config = await this.configOfImageHash({
        imageHash: result2.imageHash
      });
      if (config) {
        await this.cache.saveCounterfactualWallet({
          config,
          context: [result2.context]
        });
      }
    }
    return result2;
  }
  async saveCounterfactualWallet(args) {
    await Promise.all([this.tracker.saveCounterfactualWallet(args), this.cache.saveCounterfactualWallet(args)]);
  }
  async walletsOfSigner(args) {
    if (args.noCache) {
      return this.tracker.walletsOfSigner(args);
    }

    // In this case we need to both aggregate the results from the cache and the tracker
    // and then dedupe the results
    const results = await Promise.all([this.tracker.walletsOfSigner(args), this.cache.walletsOfSigner(args)]);
    const wallets = new Map();
    for (const result of results) {
      for (const wallet of result) {
        wallets.set(wallet.wallet, wallet);
      }
    }
    return Array.from(wallets.values());
  }
  async saveWitnesses(args) {
    await Promise.all([this.tracker.saveWitnesses(args), this.cache.saveWitnesses(args)]);
  }
  async getMigration(address, fromImageHash, fromVersion, chainId) {
    // We first check the cache, if it's not there, we check the tracker
    // NOTICE: we could eventually try to combine the two, but now we just have 1 migration
    // so it's not worth it.
    const migration1 = await this.cache.getMigration(address, fromImageHash, fromVersion, chainId);
    if (migration1) return migration1;
    const migration2 = await this.tracker.getMigration(address, fromImageHash, fromVersion, chainId);
    if (migration2) {
      await this.cache.saveMigration(address, migration2, this.contexts);
    }
    return migration2;
  }
  async saveMigration(address, signed, contexts) {
    await Promise.all([this.tracker.saveMigration(address, signed, contexts), this.cache.saveMigration(address, signed, contexts)]);
  }
}

class PromiseCache {
  constructor() {
    this.cache = void 0;
    this.cache = new Map();
  }
  do(key, validMilliseconds, task, ...args) {
    key = `${key}:${ethers.ethers.id(JSON.stringify(args, deterministically))}`;
    let entry = this.cache.get(key);
    if (entry) {
      if (entry.expiration) {
        if (new Date() >= entry.expiration) {
          entry = undefined;
          this.cache.delete(key);
        }
      }
    }
    if (!entry) {
      const entry_ = {
        promise: task(...args)
      };
      if (validMilliseconds !== undefined) {
        entry_.promise = entry_.promise.then(result => {
          entry_.expiration = new Date(Date.now() + validMilliseconds);
          return result;
        });
      }
      entry = entry_;
      this.cache.set(key, entry);
    }
    return entry.promise;
  }
}
function deterministically(_key, value) {
  if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
    return Object.fromEntries(Object.entries(value).sort());
  } else if (typeof value === 'bigint') {
    return value.toString();
  }
  return value;
}

function isDedupedTracker(tracker) {
  return tracker instanceof DedupedTracker;
}

// This tracks wraps another tracker and dedupes calls to it, so in any calls
// are sent in short succession, only the first call is forwarded to the
// underlying tracker, and the rest are ignored.
class DedupedTracker {
  constructor(tracker, window = 50, verbose = false) {
    this.tracker = tracker;
    this.window = window;
    this.verbose = verbose;
    this.cache = new PromiseCache();
  }
  invalidateCache() {
    this.cache = new PromiseCache();
  }
  configOfImageHash(args) {
    return this.cache.do('configOfImageHash', this.window, args => this.tracker.configOfImageHash(args), args);
  }
  getMigration(address, fromImageHash, fromVersion, chainId) {
    return this.cache.do('getMigration', this.window, (...args) => this.tracker.getMigration(...args), address, fromImageHash, fromVersion, chainId);
  }
  saveMigration(address, signed, contexts) {
    return this.cache.do('saveMigration', undefined, (...args) => this.tracker.saveMigration(...args), address, signed, contexts);
  }
  loadPresignedConfiguration(args) {
    return this.cache.do('loadPresignedConfiguration', this.window, args => this.tracker.loadPresignedConfiguration(args), args);
  }
  savePresignedConfiguration(args) {
    return this.cache.do('savePresignedConfiguration', undefined, args => this.tracker.savePresignedConfiguration(args), args);
  }
  saveWitnesses(args) {
    return this.cache.do('saveWitnesses', undefined, args => this.tracker.saveWitnesses(args), args);
  }
  saveWalletConfig(args) {
    return this.cache.do('saveWalletConfig', undefined, args => this.tracker.saveWalletConfig(args), args);
  }
  imageHashOfCounterfactualWallet(args) {
    return this.cache.do('imageHashOfCounterfactualWallet', undefined, args => this.tracker.imageHashOfCounterfactualWallet(args), args);
  }
  saveCounterfactualWallet(args) {
    return this.cache.do('saveCounterfactualWallet', undefined, args => this.tracker.saveCounterfactualWallet(args), args);
  }
  walletsOfSigner(args) {
    return this.cache.do('walletsOfSigner', this.window, args => this.tracker.walletsOfSigner(args), args);
  }
  updateProvider(provider) {
    if (this.tracker instanceof LocalConfigTracker) {
      this.tracker.updateProvider(provider);
    }
  }
}

var index = /*#__PURE__*/Object.freeze({
  __proto__: null,
  debug: debug$1,
  local: local,
  remote: index$1,
  stores: index$2,
  raceUntil: raceUntil,
  allSafe: allSafe,
  MultipleTracker: MultipleTracker,
  CachedTracker: CachedTracker,
  isDedupedTracker: isDedupedTracker,
  DedupedTracker: DedupedTracker
});

exports.tracker = tracker;
exports.trackers = index;
