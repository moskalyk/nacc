import { ethers } from 'ethers';
import { Leaf, WalletConfig, SignerLeaf, Topology } from "./config.js";
import * as base from "../commons/signature.js";
export declare enum SignatureType {
    Legacy = 0,
    Dynamic = 1,
    NoChainIdDynamic = 2,
    Chained = 3
}
export declare enum SignaturePartType {
    Signature = 0,
    Address = 1,
    DynamicSignature = 2,
    Node = 3,
    Branch = 4,
    Subdigest = 5,
    Nested = 6
}
export declare const SignaturePartTypeLength = 66;
export type SignatureLeaf = SignerLeaf & {
    signature: string;
    isDynamic: boolean;
};
export type UnrecoveredSignatureLeaf = Omit<SignatureLeaf, 'address'> & Pick<Partial<SignatureLeaf>, 'address'> & {
    unrecovered: true;
};
export type UnrecoveredNestedLeaf = {
    tree: UnrecoveredTopology;
    weight: ethers.BigNumberish;
    threshold: ethers.BigNumberish;
};
export type UnrecoveredLeaf = UnrecoveredNestedLeaf | UnrecoveredSignatureLeaf | Leaf;
export type UnrecoveredNode = {
    left: UnrecoveredNode | UnrecoveredLeaf;
    right: UnrecoveredNode | UnrecoveredLeaf;
};
export type UnrecoveredTopology = UnrecoveredNode | UnrecoveredLeaf;
export declare function isUnrecoveredNode(node: UnrecoveredTopology): node is UnrecoveredNode;
export declare function isUnrecoveredNestedLeaf(leaf: UnrecoveredTopology): leaf is UnrecoveredNestedLeaf;
export declare function isUnrecoveredSignatureLeaf(leaf: UnrecoveredTopology): leaf is UnrecoveredSignatureLeaf;
export declare function decodeSignatureTree(body: ethers.BytesLike): UnrecoveredTopology;
export declare class InvalidSignatureLeafError extends Error {
    leaf: UnrecoveredLeaf;
    constructor(leaf: UnrecoveredLeaf);
}
export declare function recoverTopology(unrecovered: UnrecoveredTopology, subdigest: string, provider: ethers.Provider): Promise<Topology>;
export declare const partEncoder: {
    concat: (a: ethers.BytesLike, b: ethers.BytesLike) => string;
    node: (nodeHash: ethers.BytesLike) => string;
    branch: (tree: ethers.BytesLike) => string;
    nested: (weight: ethers.BigNumberish, threshold: ethers.BigNumberish, tree: ethers.BytesLike) => string;
    subdigest: (subdigest: ethers.BytesLike) => string;
    signature: (weight: ethers.BigNumberish, signature: ethers.BytesLike) => string;
    dynamicSignature: (weight: ethers.BigNumberish, address: ethers.BytesLike, signature: ethers.BytesLike) => string;
    address: (weight: ethers.BigNumberish, address: ethers.BytesLike) => string;
};
export type EncodingOptions = {
    forceDynamicEncoding?: boolean;
    disableTrim?: boolean;
};
export declare function encodeSigners(config: WalletConfig, parts: Map<string, base.SignaturePart>, subdigests: string[], chainId: ethers.BigNumberish, options?: EncodingOptions): {
    encoded: string;
    weight: bigint;
};
export declare function encodeTree(topology: Topology, parts: Map<string, base.SignaturePart>, subdigests: string[], options?: EncodingOptions): {
    encoded: string;
    weight: bigint;
};
export type UnrecoveredConfig = {
    tree: UnrecoveredTopology;
    threshold: ethers.BigNumberish;
    checkpoint: ethers.BigNumberish;
};
export type UnrecoveredSignature = base.UnrecoveredSignature & {
    type: SignatureType;
    decoded: UnrecoveredConfig;
};
export type Signature = base.Signature<WalletConfig> & {
    type: SignatureType;
};
export type UnrecoveredChainedSignature = UnrecoveredSignature & {
    suffix: (UnrecoveredSignature | UnrecoveredChainedSignature)[];
};
export type ChainedSignature = Signature & {
    suffix: (Signature | ChainedSignature)[];
};
export declare function deepestConfigOfSignature(signature: Signature | ChainedSignature): WalletConfig;
export declare function isUnrecoveredSignature(sig: any): sig is UnrecoveredSignature;
export declare function isUnrecoveredChainedSignature(sig: any): sig is UnrecoveredChainedSignature;
export declare function isSignature(sig: any): sig is Signature;
export declare function isChainedSignature(sig: any): sig is ChainedSignature;
export declare function decodeSignature(signature: ethers.BytesLike): UnrecoveredSignature | UnrecoveredChainedSignature;
export declare function decodeSignatureBody(signature: ethers.BytesLike): UnrecoveredConfig;
export declare function decodeChainedSignature(signature: ethers.BytesLike): UnrecoveredChainedSignature;
export declare function setImageHashStruct(imageHash: string): string;
export declare function recoverSignature(signature: UnrecoveredSignature | UnrecoveredChainedSignature, payload: base.SignedPayload | {
    subdigest: string;
}, provider: ethers.Provider): Promise<Signature | ChainedSignature>;
export declare function encodeChain(main: ethers.BytesLike, suffix: ethers.BytesLike[]): string;
export declare function encodeSignature(decoded: UnrecoveredChainedSignature | ChainedSignature | UnrecoveredSignature | Signature | ethers.BytesLike): string;
export declare function encodeSignatureBody(decoded: WalletConfig | UnrecoveredConfig): string;
export declare function encodeSignatureTree(tree: UnrecoveredTopology | Topology): string;
export declare function signaturesOf(topology: Topology): {
    address: string;
    signature: string;
}[];
export declare function signaturesOfDecoded(utopology: UnrecoveredTopology): string[];
export declare function subdigestsOfDecoded(utopology: UnrecoveredTopology): string[];
export declare function trimSignature(signature: string | UnrecoveredSignature): Promise<string>;
export declare function trimUnrecoveredTree(tree: UnrecoveredTopology, trimStaticDigest?: boolean): Promise<{
    weight: number;
    trimmed: UnrecoveredTopology;
}>;
export declare const SignatureCoder: base.SignatureCoder<WalletConfig, Signature, UnrecoveredChainedSignature | UnrecoveredSignature>;
