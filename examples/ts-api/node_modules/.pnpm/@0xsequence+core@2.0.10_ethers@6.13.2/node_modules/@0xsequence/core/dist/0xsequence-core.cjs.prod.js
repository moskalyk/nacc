'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var ethers = require('ethers');
var abi = require('@0xsequence/abi');
var utils = require('@0xsequence/utils');

function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}

var config$2 = /*#__PURE__*/Object.freeze({
  __proto__: null
});

function subdigestOf(payload) {
  return ethers.ethers.solidityPackedKeccak256(['bytes', 'uint256', 'address', 'bytes32'], ['0x1901', payload.chainId, payload.address, payload.digest]);
}
function isSignedPayload(payload) {
  return payload.digest !== undefined && payload.chainId !== undefined && payload.address !== undefined;
}

var signature$2 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  subdigestOf: subdigestOf,
  isSignedPayload: isSignedPayload
});

const EIP1271_MAGIC_VALUE = '0x1626ba7e';
const EIP1271_ABI = [{
  inputs: [{
    internalType: 'bytes32',
    type: 'bytes32'
  }, {
    internalType: 'bytes',
    type: 'bytes'
  }],
  name: 'isValidSignature',
  outputs: [{
    internalType: 'bytes4',
    type: 'bytes4'
  }],
  stateMutability: 'view',
  type: 'function'
}];
async function isValidEIP1271Signature(address, digest, signature, provider) {
  const contract = new ethers.ethers.Contract(address, EIP1271_ABI, provider);
  const result = await contract.isValidSignature(digest, signature);
  return result === EIP1271_MAGIC_VALUE;
}

var validateEIP1271 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  isValidEIP1271Signature: isValidEIP1271Signature
});

let SigType = /*#__PURE__*/function (SigType) {
  SigType[SigType["EIP712"] = 1] = "EIP712";
  SigType[SigType["ETH_SIGN"] = 2] = "ETH_SIGN";
  SigType[SigType["WALLET_BYTES32"] = 3] = "WALLET_BYTES32";
  return SigType;
}({});
function canRecover(signature) {
  const bytes = ethers.ethers.getBytes(signature);
  const type = bytes[bytes.length - 1];
  return type === SigType.EIP712 || type === SigType.ETH_SIGN;
}
function recoverSigner(digest, signature) {
  const bytes = ethers.ethers.getBytes(signature);
  const digestBytes = ethers.ethers.getBytes(digest);

  // type is last byte
  const type = bytes[bytes.length - 1];

  // Split r:s:v
  const r = ethers.ethers.hexlify(bytes.slice(0, 32));
  const s = ethers.ethers.hexlify(bytes.slice(32, 64));
  const v = Number(ethers.ethers.hexlify(bytes.slice(64, 65)));
  const splitSignature = {
    r,
    s,
    v
  };
  if (type === SigType.EIP712) {
    return ethers.ethers.recoverAddress(digestBytes, splitSignature);
  }
  if (type === SigType.ETH_SIGN) {
    return ethers.ethers.recoverAddress(ethers.ethers.hashMessage(digestBytes), splitSignature);
  }
  throw new Error(`Unsupported signature type: ${type}`);
}
function isValidSignature(address, digest, signature, provider) {
  const bytes = ethers.ethers.getBytes(signature);

  // type is last byte
  const type = bytes[bytes.length - 1];
  if (type === SigType.EIP712 || type === SigType.ETH_SIGN) {
    return address === recoverSigner(digest, signature);
  }
  if (type === SigType.WALLET_BYTES32) {
    return isValidEIP1271Signature(address, ethers.ethers.hexlify(digest), bytes.slice(0, -1), provider);
  }
  throw new Error(`Unsupported signature type: ${type}`);
}
function tryRecoverSigner(digest, signature) {
  const bytes = ethers.ethers.getBytes(signature);
  if (bytes.length !== 66) return undefined;
  try {
    return recoverSigner(digest, bytes);
  } catch (_unused) {}
  return undefined;
}

var signer = /*#__PURE__*/Object.freeze({
  __proto__: null,
  SigType: SigType,
  canRecover: canRecover,
  recoverSigner: recoverSigner,
  isValidSignature: isValidSignature,
  tryRecoverSigner: tryRecoverSigner
});

let SignaturePartType$1 = /*#__PURE__*/function (SignaturePartType) {
  SignaturePartType[SignaturePartType["EOASignature"] = 0] = "EOASignature";
  SignaturePartType[SignaturePartType["Address"] = 1] = "Address";
  SignaturePartType[SignaturePartType["DynamicSignature"] = 2] = "DynamicSignature";
  return SignaturePartType;
}({});
function isAddressMember(member) {
  return member.address !== undefined && !isUnrecoveredSignatureMember(member);
}
function isUnrecoveredSignatureMember(member) {
  return member.signature !== undefined && member.weight !== undefined && member.isDynamic !== undefined;
}
function isUnrecoveredSignature$1(signature) {
  return signature.threshold !== undefined && signature.signers !== undefined;
}
function decodeSignature$1(signature) {
  const bytes = ethers.ethers.getBytes(signature);
  const threshold = bytes[0] << 8 | bytes[1];
  const signers = [];
  for (let i = 2; i < bytes.length;) {
    const type = bytes[i++];
    const weight = bytes[i++];
    switch (type) {
      case SignaturePartType$1.EOASignature:
        signers.push({
          unrecovered: true,
          weight,
          signature: ethers.ethers.hexlify(bytes.slice(i, i + 66)),
          isDynamic: false
        });
        i += 66;
        break;
      case SignaturePartType$1.Address:
        signers.push({
          weight,
          address: ethers.ethers.getAddress(ethers.ethers.hexlify(bytes.slice(i, i + 20)))
        });
        i += 20;
        break;
      case SignaturePartType$1.DynamicSignature:
        const address = ethers.ethers.getAddress(ethers.ethers.hexlify(bytes.slice(i, i + 20)));
        i += 20;
        const size = bytes[i] << 8 | bytes[i + 1];
        i += 2;
        signers.push({
          unrecovered: true,
          weight,
          signature: ethers.ethers.hexlify(bytes.slice(i, i + size)),
          address,
          isDynamic: true
        });
        i += size;
        break;
      default:
        throw new Error(`Unknown signature part type: ${type}`);
    }
  }
  return {
    version: 1,
    threshold,
    signers
  };
}
function encodeSignature$1(signature) {
  if (ethers.ethers.isBytesLike(signature)) {
    return ethers.ethers.hexlify(signature);
  }
  const {
    signers,
    threshold
  } = isUnrecoveredSignature$1(signature) ? signature : signature.config;
  const encodedSigners = signers.map(s => {
    if (isAddressMember(s)) {
      return ethers.ethers.solidityPacked(['uint8', 'uint8', 'address'], [SignaturePartType$1.Address, s.weight, s.address]);
    }
    if (s.isDynamic) {
      const bytes = ethers.ethers.getBytes(s.signature);
      return ethers.ethers.solidityPacked(['uint8', 'uint8', 'address', 'uint16', 'bytes'], [SignaturePartType$1.DynamicSignature, s.weight, s.address, bytes.length, bytes]);
    }
    return ethers.ethers.solidityPacked(['uint8', 'uint8', 'bytes'], [SignaturePartType$1.EOASignature, s.weight, s.signature]);
  });
  return ethers.ethers.solidityPacked(['uint16', ...new Array(encodedSigners.length).fill('bytes')], [threshold, ...encodedSigners]);
}
async function recoverSignature$1(data, payload, provider) {
  const subdigest = subdigestOf(payload);
  const signers = await Promise.all(data.signers.map(async s => {
    if (isAddressMember(s)) {
      return s;
    }
    if (s.isDynamic) {
      if (!s.address) throw new Error('Dynamic signature part must have address');
      if (!isValidSignature(s.address, subdigest, s.signature, provider)) {
        throw new Error(`Invalid dynamic signature part ${s.address}`);
      }
      return {
        address: s.address,
        weight: s.weight,
        signature: s.signature
      };
    } else {
      const address = recoverSigner(subdigest, s.signature);
      return {
        address,
        weight: s.weight,
        signature: s.signature
      };
    }
  }));
  return {
    version: 1,
    payload,
    subdigest,
    config: {
      version: 1,
      threshold: data.threshold,
      signers
    }
  };
}
function encodeSigners$1(config, signatures, subdigests, _) {
  if (subdigests.length !== 0) {
    throw new Error('Explicit subdigests not supported on v1');
  }
  let weight = 0n;
  const parts = config.signers.map(s => {
    if (!signatures.has(s.address)) {
      return s;
    }
    const signature = signatures.get(s.address);
    const bytes = ethers.ethers.getBytes(signature.signature);
    weight += BigInt(s.weight);
    if (signature.isDynamic || bytes.length !== 66) {
      return _extends({}, s, {
        isDynamic: true,
        signature: signature.signature,
        address: s.address
      });
    }
    return _extends({}, s, {
      isDynamic: false,
      signature: signature.signature
    });
  });
  const encoded = encodeSignature$1({
    version: 1,
    threshold: config.threshold,
    signers: parts
  });
  return {
    encoded,
    weight
  };
}
const SignatureCoder$1 = {
  decode: data => {
    return decodeSignature$1(data);
  },
  encode: data => {
    return encodeSignature$1(data);
  },
  trim: async data => {
    return data;
  },
  supportsNoChainId: true,
  recover: (data, payload, provider) => {
    return recoverSignature$1(data, payload, provider);
  },
  encodeSigners: (config, signatures, subdigests, chainId) => {
    return encodeSigners$1(config, signatures, subdigests);
  },
  hasEnoughSigningPower: (config, signatures) => {
    const {
      weight
    } = SignatureCoder$1.encodeSigners(config, signatures, [], 0);
    return weight >= BigInt(config.threshold);
  },
  chainSignatures: (_main, _suffix) => {
    throw new Error('Signature chaining not supported on v1');
  },
  hashSetImageHash: function (_imageHash) {
    throw new Error('Image hash not supported on v1');
  },
  signaturesOf(config) {
    return config.signers.filter(s => s.signature !== undefined).map(s => ({
      address: s.address,
      signature: s.signature
    }));
  },
  signaturesOfDecoded: function (data) {
    return data.signers.map(s => s.signature).filter(s => s !== undefined);
  }
};

var signature$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  SignaturePartType: SignaturePartType$1,
  isAddressMember: isAddressMember,
  isUnrecoveredSignatureMember: isUnrecoveredSignatureMember,
  isUnrecoveredSignature: isUnrecoveredSignature$1,
  decodeSignature: decodeSignature$1,
  encodeSignature: encodeSignature$1,
  recoverSignature: recoverSignature$1,
  encodeSigners: encodeSigners$1,
  SignatureCoder: SignatureCoder$1
});

const ConfigCoder$1 = {
  isWalletConfig: config => {
    return config.version === 1 && config.threshold !== undefined && config.signers !== undefined;
  },
  imageHashOf: config => {
    return config.signers.reduce((imageHash, signer) => ethers.ethers.keccak256(ethers.ethers.AbiCoder.defaultAbiCoder().encode(['bytes32', 'uint8', 'address'], [imageHash, signer.weight, signer.address])), ethers.ethers.solidityPacked(['uint256'], [config.threshold]));
  },
  hasSubdigest: (_walletConfig, _subdigest) => {
    // v1 does not support explicit subdigests
    return false;
  },
  isComplete: _config => {
    // v1 does not support incomplete configs
    return true;
  },
  checkpointOf: _config => {
    return 0n;
  },
  signersOf: config => {
    return config.signers.map(s => ({
      address: s.address,
      weight: Number(s.weight)
    }));
  },
  fromSimple: config => {
    if (BigInt(config.checkpoint) !== 0n) {
      throw new Error('v1 wallet config does not support checkpoint');
    }
    if (config.subdigests && config.subdigests.length > 0) {
      throw new Error('v1 wallet config does not support subdigests');
    }
    return {
      version: 1,
      threshold: config.threshold,
      signers: config.signers
    };
  },
  update: {
    isKindUsed: true,
    buildTransaction: (wallet, config, context, kind) => {
      const module = new ethers.ethers.Interface([...abi.walletContracts.mainModule.abi, ...abi.walletContracts.mainModuleUpgradable.abi]);
      const transactions = [];
      if (!kind || kind === 'first') {
        transactions.push({
          to: wallet,
          data: module.encodeFunctionData(module.getFunction('updateImplementation'), [context.mainModuleUpgradable]),
          gasLimit: 0,
          delegateCall: false,
          revertOnError: true,
          value: 0
        });
      }
      transactions.push({
        to: wallet,
        data: module.encodeFunctionData(module.getFunction('updateImageHash'), [ConfigCoder$1.imageHashOf(config)]),
        gasLimit: 0,
        delegateCall: false,
        revertOnError: true,
        value: 0
      });
      return {
        entrypoint: wallet,
        transactions
      };
    },
    decodeTransaction: function (tx) {
      throw new Error('Function not implemented.');
    }
  },
  toJSON: function (config) {
    const plainMembers = config.signers.map(signer => {
      return {
        weight: BigInt(signer.weight).toString(),
        address: signer.address
      };
    });
    return JSON.stringify({
      version: config.version,
      threshold: BigInt(config.threshold).toString(),
      signers: plainMembers
    });
  },
  fromJSON: function (json) {
    const parsed = JSON.parse(json);
    const signers = parsed.signers.map(signer => {
      return {
        weight: BigInt(signer.weight),
        address: signer.address
      };
    });
    return {
      version: parsed.version,
      threshold: BigInt(parsed.threshold),
      signers
    };
  },
  editConfig: function (config, action) {
    var _action$threshold;
    const newSigners = config.signers.slice();
    if (action.checkpoint && BigInt(action.checkpoint) !== 0n) {
      throw new Error('v1 wallet config does not support checkpoint');
    }
    if (action.add) {
      for (const signer of action.add) {
        if (newSigners.find(s => s.address === signer.address)) {
          continue;
        }
        newSigners.push({
          weight: signer.weight,
          address: signer.address
        });
      }
    }
    if (action.remove) {
      for (const address of action.remove) {
        const index = newSigners.findIndex(signer => signer.address === address);
        if (index >= 0) {
          newSigners.splice(index, 1);
        }
      }
    }
    return {
      version: config.version,
      threshold: (_action$threshold = action.threshold) != null ? _action$threshold : config.threshold,
      signers: newSigners
    };
  },
  buildStubSignature: function (config, overrides) {
    const parts = new Map();
    for (const [signer, signature] of overrides.entries()) {
      parts.set(signer, {
        signature,
        isDynamic: true
      });
      const {
        encoded,
        weight
      } = encodeSigners$1(config, parts, []);
      if (weight >= BigInt(config.threshold)) {
        return encoded;
      }
    }
    const signers = config.signers;
    for (const {
      address
    } of signers.sort(({
      weight: a
    }, {
      weight: b
    }) => Number(a) - Number(b))) {
      const signature = '0x4e82f02f388a12b5f9d29eaf2452dd040c0ee5804b4e504b4dd64e396c6c781f2c7624195acba242dd825bfd25a290912e3c230841fd55c9a734c4de8d9899451b02';
      parts.set(address, {
        signature,
        isDynamic: false
      });
      const {
        encoded,
        weight
      } = encodeSigners$1(config, parts, []);
      if (weight >= BigInt(config.threshold)) {
        return encoded;
      }
    }
    return encodeSigners$1(config, parts, []).encoded;
  }
};

var config$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  ConfigCoder: ConfigCoder$1
});

var context$2 = /*#__PURE__*/Object.freeze({
  __proto__: null
});

const version$1 = 1;
const DeployedWalletContext$1 = {
  version: version$1,
  factory: '0xf9D09D634Fb818b05149329C1dcCFAeA53639d96',
  guestModule: '0x02390F3E6E5FD1C6786CB78FD3027C117a9955A7',
  mainModule: '0xd01F11855bCcb95f88D7A48492F66410d4637313',
  mainModuleUpgradable: '0x7EFE6cE415956c5f80C6530cC6cc81b4808F6118',
  walletCreationCode: '0x603a600e3d39601a805130553df3363d3d373d3d3d363d30545af43d82803e903d91601857fd5bf3'
};

var v1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  config: config$1,
  context: context$2,
  signature: signature$1,
  version: version$1,
  DeployedWalletContext: DeployedWalletContext$1
});

//                              = keccak256("SetImageHash(bytes32 imageHash)")
const SetImageHashPrefix = '0x8713a7c4465f6fbee2b6e9d6646d1d9f83fec929edfc4baf661f3c865bdd04d1';
function hashSetImageHash(imageHash) {
  return ethers.ethers.keccak256(messageSetImageHash(imageHash));
}
function messageSetImageHash(imageHash) {
  return ethers.ethers.solidityPacked(['bytes32', 'bytes32'], [SetImageHashPrefix, imageHash]);
}
function decodeMessageSetImageHash(message) {
  const arr = ethers.ethers.getBytes(message);
  if (arr.length !== 64) {
    return undefined;
  }
  if (ethers.ethers.hexlify(arr.slice(0, 32)) !== SetImageHashPrefix) {
    return undefined;
  }
  return ethers.ethers.hexlify(arr.slice(32, 64));
}
function isMessageSetImageHash(message) {
  return decodeMessageSetImageHash(message) !== undefined;
}

var chained = /*#__PURE__*/Object.freeze({
  __proto__: null,
  SetImageHashPrefix: SetImageHashPrefix,
  hashSetImageHash: hashSetImageHash,
  messageSetImageHash: messageSetImageHash,
  decodeMessageSetImageHash: decodeMessageSetImageHash,
  isMessageSetImageHash: isMessageSetImageHash
});

let SignatureType = /*#__PURE__*/function (SignatureType) {
  SignatureType[SignatureType["Legacy"] = 0] = "Legacy";
  SignatureType[SignatureType["Dynamic"] = 1] = "Dynamic";
  SignatureType[SignatureType["NoChainIdDynamic"] = 2] = "NoChainIdDynamic";
  SignatureType[SignatureType["Chained"] = 3] = "Chained";
  return SignatureType;
}({});
let SignaturePartType = /*#__PURE__*/function (SignaturePartType) {
  SignaturePartType[SignaturePartType["Signature"] = 0] = "Signature";
  SignaturePartType[SignaturePartType["Address"] = 1] = "Address";
  SignaturePartType[SignaturePartType["DynamicSignature"] = 2] = "DynamicSignature";
  SignaturePartType[SignaturePartType["Node"] = 3] = "Node";
  SignaturePartType[SignaturePartType["Branch"] = 4] = "Branch";
  SignaturePartType[SignaturePartType["Subdigest"] = 5] = "Subdigest";
  SignaturePartType[SignaturePartType["Nested"] = 6] = "Nested";
  return SignaturePartType;
}({});
const SignaturePartTypeLength = 66;
function isUnrecoveredNode(node) {
  return node.left !== undefined && node.right !== undefined;
}
function isUnrecoveredNestedLeaf(leaf) {
  return leaf.tree !== undefined;
}
function isUnrecoveredSignatureLeaf(leaf) {
  return leaf.unrecovered && leaf.signature !== undefined && leaf.isDynamic !== undefined;
}
function decodeSignatureTree(body) {
  let arr = ethers.ethers.getBytes(body);
  let pointer;
  const append = (prevPointer, node) => {
    if (!prevPointer) {
      return {
        left: node
      };
    }
    if (!prevPointer.right) {
      return {
        left: prevPointer.left,
        right: node
      };
    }
    return {
      left: prevPointer,
      right: node
    };
  };
  while (arr.length > 0) {
    const type = arr[0];
    arr = arr.slice(1);
    switch (type) {
      case SignaturePartType.Signature:
        {
          const weight = arr[0];
          const signature = ethers.ethers.hexlify(arr.slice(1, SignaturePartTypeLength + 1));
          pointer = append(pointer, {
            signature,
            weight,
            unrecovered: true,
            isDynamic: false
          });
          arr = arr.slice(SignaturePartTypeLength + 1);
        }
        break;
      case SignaturePartType.Address:
        {
          const weight = arr[0];
          const address = ethers.ethers.getAddress(ethers.ethers.hexlify(arr.slice(1, 21)));
          pointer = append(pointer, {
            address,
            weight
          });
          arr = arr.slice(21);
        }
        break;
      case SignaturePartType.DynamicSignature:
        {
          const weight = arr[0];
          const address = ethers.ethers.getAddress(ethers.ethers.hexlify(arr.slice(1, 21)));
          const size = arr[21] << 16 | arr[22] << 8 | arr[23];
          const signature = ethers.ethers.hexlify(arr.slice(24, 24 + size));
          pointer = append(pointer, {
            address,
            signature,
            weight,
            unrecovered: true,
            isDynamic: true
          });
          arr = arr.slice(24 + size);
        }
        break;
      case SignaturePartType.Node:
        {
          const nodeHash = ethers.ethers.hexlify(arr.slice(0, 32));
          pointer = append(pointer, {
            nodeHash
          });
          arr = arr.slice(32);
        }
        break;
      case SignaturePartType.Branch:
        {
          const size = arr[0] << 16 | arr[1] << 8 | arr[2];
          const branch = decodeSignatureTree(arr.slice(3, 3 + size));
          pointer = append(pointer, branch);
          arr = arr.slice(3 + size);
        }
        break;
      case SignaturePartType.Subdigest:
        {
          const subdigest = ethers.ethers.hexlify(arr.slice(0, 32));
          pointer = append(pointer, {
            subdigest
          });
          arr = arr.slice(32);
        }
        break;
      case SignaturePartType.Nested:
        {
          const weight = arr[0];
          const threshold = arr[1] << 8 | arr[2];
          const size = arr[3] << 16 | arr[4] << 8 | arr[5];
          const tree = decodeSignatureTree(arr.slice(6, 6 + size));
          pointer = append(pointer, {
            weight,
            threshold,
            tree
          });
          arr = arr.slice(6 + size);
        }
        break;
      default:
        throw new Error(`Unknown signature part type: ${type}: ${ethers.ethers.hexlify(arr)}`);
    }
  }
  if (!pointer) {
    throw new Error('Empty signature tree');
  }
  if (pointer.right) {
    return pointer;
  }
  return pointer.left;
}
class InvalidSignatureLeafError extends Error {
  constructor(leaf) {
    super(`Invalid signature leaf: ${JSON.stringify(leaf)}`);
    this.leaf = leaf;
  }
}
async function recoverTopology(unrecovered, subdigest, provider) {
  if (isUnrecoveredNode(unrecovered)) {
    const [left, right] = await Promise.all([recoverTopology(unrecovered.left, subdigest, provider), recoverTopology(unrecovered.right, subdigest, provider)]);
    return {
      left,
      right
    };
  }
  if (isUnrecoveredNestedLeaf(unrecovered)) {
    return {
      weight: unrecovered.weight,
      threshold: unrecovered.threshold,
      tree: await recoverTopology(unrecovered.tree, subdigest, provider)
    };
  }
  if (isUnrecoveredSignatureLeaf(unrecovered)) {
    if (unrecovered.isDynamic) {
      if (!unrecovered.address) {
        throw new Error('Dynamic signature leaf without address');
      }
      const isValid = await isValidSignature(unrecovered.address, subdigest, unrecovered.signature, provider);
      if (!isValid) {
        throw new InvalidSignatureLeafError(unrecovered);
      }
      return {
        weight: unrecovered.weight,
        address: unrecovered.address,
        signature: unrecovered.signature,
        subdigest
      };
    } else {
      return {
        weight: unrecovered.weight,
        address: recoverSigner(subdigest, unrecovered.signature),
        signature: unrecovered.signature,
        subdigest
      };
    }
  }
  return unrecovered;
}

// TODO: It should be possible to re-use encodeSignatureTree
// and avoid duplicating this logic
const partEncoder = {
  concat: (a, b) => {
    return ethers.ethers.solidityPacked(['bytes', 'bytes'], [a, b]);
  },
  node: nodeHash => {
    return ethers.ethers.solidityPacked(['uint8', 'bytes32'], [SignaturePartType.Node, nodeHash]);
  },
  branch: tree => {
    const arr = ethers.ethers.getBytes(tree);
    return ethers.ethers.solidityPacked(['uint8', 'uint24', 'bytes'], [SignaturePartType.Branch, arr.length, arr]);
  },
  nested: (weight, threshold, tree) => {
    const arr = ethers.ethers.getBytes(tree);
    return ethers.ethers.solidityPacked(['uint8', 'uint8', 'uint16', 'uint24', 'bytes'], [SignaturePartType.Nested, weight, threshold, arr.length, arr]);
  },
  subdigest: subdigest => {
    return ethers.ethers.solidityPacked(['uint8', 'bytes32'], [SignaturePartType.Subdigest, subdigest]);
  },
  signature: (weight, signature) => {
    return ethers.ethers.solidityPacked(['uint8', 'uint8', 'bytes'], [SignaturePartType.Signature, weight, signature]);
  },
  dynamicSignature: (weight, address, signature) => {
    const arrSignature = ethers.ethers.getBytes(signature);
    return ethers.ethers.solidityPacked(['uint8', 'uint8', 'address', 'uint24', 'bytes'], [SignaturePartType.DynamicSignature, weight, address, arrSignature.length, arrSignature]);
  },
  address: (weight, address) => {
    return ethers.ethers.solidityPacked(['uint8', 'uint8', 'address'], [SignaturePartType.Address, weight, address]);
  }
};
function encodeSigners(config, parts, subdigests, chainId, options = {}) {
  const tree = encodeTree(config.tree, parts, subdigests, options);
  if (BigInt(chainId) === 0n) {
    return {
      encoded: ethers.ethers.solidityPacked(['uint8', 'uint16', 'uint32', 'bytes'], [SignatureType.NoChainIdDynamic, config.threshold, config.checkpoint, tree.encoded]),
      weight: tree.weight
    };
  }
  if (BigInt(config.threshold) > 255n) {
    return {
      encoded: ethers.ethers.solidityPacked(['uint8', 'uint16', 'uint32', 'bytes'], [SignatureType.Dynamic, config.threshold, config.checkpoint, tree.encoded]),
      weight: tree.weight
    };
  }
  return {
    encoded: ethers.ethers.solidityPacked(['uint8', 'uint8', 'uint32', 'bytes'], [SignatureType.Legacy, config.threshold, config.checkpoint, tree.encoded]),
    weight: tree.weight
  };
}
function encodeTree(topology, parts, subdigests, options = {}) {
  const trim = !options.disableTrim;
  if (isNode(topology)) {
    const left = encodeTree(topology.left, parts, subdigests);
    const right = encodeTree(topology.right, parts, subdigests);
    const isLeftSigner = isSignerLeaf(topology.left);
    const isRightSigner = isSignerLeaf(topology.right);
    if (trim && left.weight === 0n && right.weight === 0n && !isLeftSigner && !isRightSigner) {
      return {
        // We don't need to include anything for this node
        // just the hash will be enough
        encoded: partEncoder.node(hashNode(topology)),
        weight: 0n
      };
    }
    if (trim && right.weight === 0n && !isRightSigner) {
      return {
        // The right node doesn't have any weight
        // but we still need to include the left node encoded
        encoded: partEncoder.concat(left.encoded, partEncoder.node(hashNode(topology.right))),
        weight: left.weight
      };
    }
    if (trim && left.weight === 0n && !isLeftSigner) {
      return {
        // The left node doesn't have any weight
        // we can just append its hash, but for the right node
        // we need to create a new "branch"
        encoded: partEncoder.concat(partEncoder.node(hashNode(topology.left)), partEncoder.branch(right.encoded)),
        weight: right.weight
      };
    }
    return {
      // Both nodes have weight, we need to include both
      // the right one must be a branch
      encoded: partEncoder.concat(left.encoded, partEncoder.branch(right.encoded)),
      weight: left.weight + right.weight
    };
  }
  if (isNestedLeaf(topology)) {
    const tree = encodeTree(topology.tree, parts, subdigests);
    if (trim && tree.weight === 0n) {
      return {
        encoded: partEncoder.node(hashNode(topology)),
        weight: 0n
      };
    }
    return {
      encoded: partEncoder.nested(topology.weight, topology.threshold, tree.encoded),
      weight: tree.weight
    };
  }
  if (isNodeLeaf(topology)) {
    return {
      encoded: partEncoder.node(hashNode(topology)),
      weight: 0n
    };
  }
  if (isSubdigestLeaf(topology)) {
    const include = subdigests.includes(topology.subdigest);
    return {
      encoded: partEncoder.subdigest(topology.subdigest),
      weight: include ? utils.MAX_UINT_256 : 0n
    };
  }
  if (isSignerLeaf(topology)) {
    const include = parts.has(topology.address);
    if (include) {
      const part = parts.get(topology.address);
      const signature = part.signature;
      if (options.forceDynamicEncoding || part.isDynamic) {
        return {
          encoded: partEncoder.dynamicSignature(topology.weight, topology.address, signature),
          weight: BigInt(topology.weight)
        };
      } else {
        return {
          encoded: partEncoder.signature(topology.weight, signature),
          weight: BigInt(topology.weight)
        };
      }
    } else {
      return {
        encoded: partEncoder.address(topology.weight, topology.address),
        weight: 0n
      };
    }
  }
  throw new Error(`Invalid topology - unknown error: ${JSON.stringify(topology)}`);
}
function deepestConfigOfSignature(signature) {
  return isChainedSignature(signature) ? deepestConfigOfSignature(signature.suffix[signature.suffix.length - 1]) : signature.config;
}
function isUnrecoveredSignature(sig) {
  return sig.type !== undefined && sig.decoded !== undefined && sig.version !== undefined && sig.version === 2;
}
function isUnrecoveredChainedSignature(sig) {
  return sig.suffix !== undefined && Array.isArray(sig.suffix) && sig.suffix.every(isUnrecoveredSignature);
}
function isSignature(sig) {
  return sig.type !== undefined && sig.config !== undefined && sig.digest !== undefined && sig.version !== undefined && sig.version === 2;
}
function isChainedSignature(sig) {
  return sig.chain !== undefined && Array.isArray(sig.chain) && sig.chain.every(isSignature);
}
function decodeSignature(signature) {
  const bytes = ethers.ethers.getBytes(signature);
  const type = bytes[0];
  switch (type) {
    case SignatureType.Legacy:
      return {
        version: 2,
        type: SignatureType.Legacy,
        decoded: decodeSignatureBody(bytes)
      };
    case SignatureType.Dynamic:
      return {
        version: 2,
        type: SignatureType.Dynamic,
        decoded: decodeSignatureBody(bytes.slice(1))
      };
    case SignatureType.NoChainIdDynamic:
      return {
        version: 2,
        type: SignatureType.NoChainIdDynamic,
        decoded: decodeSignatureBody(bytes.slice(1))
      };
    case SignatureType.Chained:
      return decodeChainedSignature(bytes);
    default:
      throw new Error(`Invalid signature type: ${type}`);
  }
}
function decodeSignatureBody(signature) {
  const bytes = ethers.ethers.getBytes(signature);
  const threshold = bytes[0] << 8 | bytes[1];
  const checkpoint = bytes[2] << 24 | bytes[3] << 16 | bytes[4] << 8 | bytes[5];
  const tree = decodeSignatureTree(bytes.slice(6));
  return {
    threshold,
    checkpoint,
    tree
  };
}
function decodeChainedSignature(signature) {
  const arr = ethers.ethers.getBytes(signature);
  const type = arr[0];
  if (type !== SignatureType.Chained) {
    throw new Error(`Expected chained signature type: ${type}`);
  }
  const chain = [];
  let index = 1;
  while (index < arr.length) {
    const size = arr[index] << 16 | arr[index + 1] << 8 | arr[index + 2];
    index += 3;
    const sig = decodeSignature(arr.slice(index, index + size));
    chain.push(sig);
    index += size;
  }
  const main = chain[0];
  if (isUnrecoveredChainedSignature(main)) {
    throw new Error(`Expected first link of chained signature to be a simple signature (not chained)`);
  }
  const suffix = chain.slice(1);
  return _extends({}, main, {
    suffix
  });
}
function setImageHashStruct(imageHash) {
  return ethers.ethers.solidityPacked(['bytes32', 'bytes32'], [ethers.ethers.solidityPackedKeccak256(['string'], ['SetImageHash(bytes32 imageHash)']), imageHash]);
}
async function recoverSignature(signature, payload, provider) {
  const signedPayload = payload.subdigest === undefined ? payload : undefined;
  const isNoChainId = signature.type === SignatureType.NoChainIdDynamic;
  if (isNoChainId && signedPayload) {
    signedPayload.chainId = 0;
  }
  const subdigest = signedPayload ? subdigestOf(signedPayload) : payload.subdigest;
  if (!isUnrecoveredChainedSignature(signature)) {
    const tree = await recoverTopology(signature.decoded.tree, subdigest, provider);
    return {
      version: 2,
      type: signature.type,
      subdigest,
      config: _extends({
        version: 2
      }, signature.decoded, {
        tree
      })
    };
  }
  if (!isSignedPayload(signedPayload)) {
    throw new Error(`Chained signature recovery requires detailed signed payload, subdigest is not enough`);
  }
  const result = [];
  let mutatedPayload = signedPayload;

  // Recover the chain of signatures
  // NOTICE: Remove the suffix from the "first" siganture
  // otherwise we recurse infinitely
  for (const sig of [_extends({}, signature, {
    suffix: undefined
  }), ...signature.suffix]) {
    const recovered = await recoverSignature(sig, mutatedPayload, provider);
    result.unshift(recovered);
    const nextMessage = setImageHashStruct(imageHash(deepestConfigOfSignature(recovered)));
    mutatedPayload = _extends({}, mutatedPayload, {
      message: nextMessage,
      digest: ethers.ethers.keccak256(nextMessage)
    });
  }
  const main = result[0];
  const suffix = result.slice(1);
  return _extends({}, main, {
    suffix
  });
}
function encodeChain(main, suffix) {
  const allSignatures = [main, ...(suffix || [])];
  const encodedMap = allSignatures.map(s => ethers.ethers.getBytes(encodeSignature(s)));
  const body = ethers.ethers.solidityPacked(encodedMap.map(() => ['uint24', 'bytes']).flat(), encodedMap.map(s => [s.length, s]).flat());
  return ethers.ethers.solidityPacked(['uint8', 'bytes'], [SignatureType.Chained, body]);
}
function encodeSignature(decoded) {
  if (ethers.ethers.isBytesLike(decoded)) return ethers.ethers.hexlify(decoded);
  if (isUnrecoveredChainedSignature(decoded) || isChainedSignature(decoded)) {
    return encodeChain(encodeSignature(decoded), (decoded.suffix || []).map(encodeSignature));
  }
  const body = isUnrecoveredSignature(decoded) ? decoded.decoded : decoded.config;
  switch (decoded.type) {
    case SignatureType.Legacy:
      if (BigInt(body.threshold) > 255n) {
        throw new Error(`Legacy signature threshold is too large: ${body.threshold} (max 255)`);
      }
      return encodeSignatureBody(body);
    case SignatureType.NoChainIdDynamic:
    case SignatureType.Dynamic:
      return ethers.ethers.solidityPacked(['uint8', 'bytes'], [decoded.type, encodeSignatureBody(body)]);
    case SignatureType.Chained:
      throw new Error(`Unreachable code: Chained signature should be handled above`);
    default:
      throw new Error(`Invalid signature type: ${decoded.type}`);
  }
}
function encodeSignatureBody(decoded) {
  return ethers.ethers.solidityPacked(['uint16', 'uint32', 'bytes'], [decoded.threshold, decoded.checkpoint, encodeSignatureTree(decoded.tree)]);
}
function encodeSignatureTree(tree) {
  if (isNode(tree) || isUnrecoveredNode(tree)) {
    const encodedRight = ethers.ethers.getBytes(encodeSignatureTree(tree.right));
    const encodedLeft = ethers.ethers.getBytes(encodeSignatureTree(tree.left));
    const isBranching = isNode(tree.right) || isUnrecoveredNode(tree.right);
    if (isBranching) {
      return ethers.ethers.solidityPacked(['bytes', 'uint8', 'uint24', 'bytes'], [encodedLeft, SignaturePartType.Branch, encodedRight.length, encodedRight]);
    } else {
      return ethers.ethers.solidityPacked(['bytes', 'bytes'], [encodedLeft, encodedRight]);
    }
  }
  if (isNestedLeaf(tree) || isUnrecoveredNestedLeaf(tree)) {
    const nested = ethers.ethers.getBytes(encodeSignatureTree(tree.tree));
    return ethers.ethers.solidityPacked(['uint8', 'uint8', 'uint16', 'uint24', 'bytes'], [SignaturePartType.Nested, tree.weight, tree.threshold, nested.length, nested]);
  }
  if (isUnrecoveredSignatureLeaf(tree) || isSignerLeaf(tree) && tree.signature !== undefined) {
    const signature = ethers.ethers.getBytes(tree.signature);
    if (tree.isDynamic || signature.length !== SignaturePartTypeLength) {
      if (!tree.address) throw new Error(`Dynamic signature leaf must have address`);
      return ethers.ethers.solidityPacked(['uint8', 'uint8', 'address', 'uint24', 'bytes'], [SignaturePartType.DynamicSignature, tree.weight, tree.address, signature.length, signature]);
    } else {
      return ethers.ethers.solidityPacked(['uint8', 'uint8', 'bytes'], [SignaturePartType.Signature, tree.weight, signature]);
    }
  }
  if (isSignerLeaf(tree)) {
    return ethers.ethers.solidityPacked(['uint8', 'uint8', 'address'], [SignaturePartType.Address, tree.weight, tree.address]);
  }
  if (isNodeLeaf(tree)) {
    return ethers.ethers.solidityPacked(['uint8', 'bytes32'], [SignaturePartType.Node, tree.nodeHash]);
  }
  if (isSubdigestLeaf(tree)) {
    return ethers.ethers.solidityPacked(['uint8', 'bytes32'], [SignaturePartType.Subdigest, tree.subdigest]);
  }
  throw new Error(`Unknown signature tree type: ${tree}`);
}
function signaturesOf(topology) {
  if (isNode(topology)) {
    return [...signaturesOf(topology.left), ...signaturesOf(topology.right)];
  }
  if (isNestedLeaf(topology)) {
    return signaturesOf(topology.tree);
  }
  if (isSignerLeaf(topology) && topology.signature) {
    return [{
      address: topology.address,
      signature: topology.signature
    }];
  }
  return [];
}
function signaturesOfDecoded(utopology) {
  if (isUnrecoveredNode(utopology)) {
    return [...signaturesOfDecoded(utopology.left), ...signaturesOfDecoded(utopology.right)];
  }
  if (isUnrecoveredNestedLeaf(utopology)) {
    return signaturesOfDecoded(utopology.tree);
  }
  if (isUnrecoveredSignatureLeaf(utopology)) {
    return [utopology.signature];
  }
  return [];
}
function subdigestsOfDecoded(utopology) {
  if (isUnrecoveredNode(utopology)) {
    return [...subdigestsOfDecoded(utopology.left), ...subdigestsOfDecoded(utopology.right)];
  }
  if (isUnrecoveredNestedLeaf(utopology)) {
    return subdigestsOfDecoded(utopology.tree);
  }
  if (isSubdigestLeaf(utopology)) {
    return [utopology.subdigest];
  }
  return [];
}
async function trimSignature(signature) {
  const decoded = typeof signature === 'string' ? decodeSignature(signature) : signature;
  if (isUnrecoveredChainedSignature(decoded)) {
    // We need to trim every suffix AND the main signature
    const _trimmed = await Promise.all([trimSignature(_extends({}, decoded, {
      suffix: undefined
    })), ...decoded.suffix.map(s => trimSignature(s))]);
    return encodeChain(_trimmed[0], _trimmed.slice(1));
  }
  const {
    trimmed
  } = await trimUnrecoveredTree(decoded.decoded.tree);
  return encodeSignature(_extends({}, decoded, {
    decoded: _extends({}, decoded.decoded, {
      tree: trimmed
    })
  }));
}
async function trimUnrecoveredTree(tree, trimStaticDigest = true) {
  if (isUnrecoveredNode(tree)) {
    const [left, right] = await Promise.all([trimUnrecoveredTree(tree.left), trimUnrecoveredTree(tree.right)]);
    if (left.weight === 0 && right.weight === 0) {
      try {
        // If both weights are 0 then it means we don't have any signatures yet
        // because of that, we should be able to "recover" the tree with any subdigest
        // and still get the valid node hash (there shouldn't be any signatures to verify)
        const recovered = await recoverTopology(tree, ethers.ethers.ZeroHash, undefined);
        return {
          weight: 0,
          trimmed: {
            nodeHash: hashNode(recovered)
          }
        };
      } catch (_unused) {
        // If something fails it's more likely because some signatures have sneaked in
        // in that case we should keep this node
      }
    } else {
      return {
        weight: left.weight + right.weight,
        trimmed: {
          left: left.trimmed,
          right: right.trimmed
        }
      };
    }
  }
  if (isUnrecoveredNestedLeaf(tree)) {
    const trimmed = await trimUnrecoveredTree(tree.tree);
    if (trimmed.weight === 0) {
      try {
        // If the nested leaf is empty, we can recover it with any subdigest
        // and still get the valid node hash (there shouldn't be any signatures to verify)
        const recovered = await recoverTopology(tree, ethers.ethers.ZeroHash, undefined);
        return {
          weight: 0,
          trimmed: {
            nodeHash: hashNode(recovered)
          }
        };
      } catch (_unused2) {
        // If something fails it's more likely because some signatures have sneaked in
        // in that case we should keep this node
      }
    }
    return {
      weight: trimmed.weight,
      trimmed: {
        weight: tree.weight,
        threshold: tree.threshold,
        tree: trimmed.trimmed
      }
    };
  }

  // Hash nodes can be encoded as signer leaves if they have a weight below
  // 256, most likely the are signer leaves wrongly encoded
  if (isNodeLeaf(tree) && isEncodedSignerLeaf(tree.nodeHash)) {
    return {
      weight: 0,
      trimmed: _extends({}, decodeSignerLeaf(tree.nodeHash))
    };
  }
  if (isUnrecoveredSignatureLeaf(tree) || isSignerLeaf(tree) && tree.signature !== undefined) {
    return {
      weight: Number(tree.weight),
      trimmed: tree
    };
  }
  if (!trimStaticDigest && isSubdigestLeaf(tree)) {
    return {
      weight: +Infinity,
      trimmed: tree
    };
  }
  return {
    weight: 0,
    trimmed: tree
  };
}
const SignatureCoder = {
  decode: data => {
    return decodeSignature(data);
  },
  encode: data => {
    return encodeSignature(data);
  },
  trim: data => {
    return trimSignature(data);
  },
  supportsNoChainId: true,
  recover: (data, payload, provider) => {
    return recoverSignature(data, payload, provider);
  },
  encodeSigners: (config, signatures, subdigests, chainId) => {
    return encodeSigners(config, signatures, subdigests, chainId);
  },
  hasEnoughSigningPower: (config, signatures) => {
    const {
      weight
    } = SignatureCoder.encodeSigners(config, signatures, [], 0);
    return weight >= BigInt(config.threshold);
  },
  chainSignatures: (main, suffix) => {
    // Notice: v2 expects suffix to be reversed
    // that being: from signed to current imageHash
    const reversed = suffix.reverse();
    const mraw = ethers.ethers.isBytesLike(main) ? main : encodeSignature(main);
    const sraw = reversed.map(s => ethers.ethers.isBytesLike(s) ? s : encodeSignature(s));
    return encodeChain(mraw, sraw);
  },
  hashSetImageHash: function (imageHash) {
    return hashSetImageHash(imageHash);
  },
  signaturesOf(config) {
    return signaturesOf(config.tree);
  },
  signaturesOfDecoded: function (data) {
    return signaturesOfDecoded(data.decoded.tree);
  }
};

var signature = /*#__PURE__*/Object.freeze({
  __proto__: null,
  SignatureType: SignatureType,
  SignaturePartType: SignaturePartType,
  SignaturePartTypeLength: SignaturePartTypeLength,
  isUnrecoveredNode: isUnrecoveredNode,
  isUnrecoveredNestedLeaf: isUnrecoveredNestedLeaf,
  isUnrecoveredSignatureLeaf: isUnrecoveredSignatureLeaf,
  decodeSignatureTree: decodeSignatureTree,
  InvalidSignatureLeafError: InvalidSignatureLeafError,
  recoverTopology: recoverTopology,
  partEncoder: partEncoder,
  encodeSigners: encodeSigners,
  encodeTree: encodeTree,
  deepestConfigOfSignature: deepestConfigOfSignature,
  isUnrecoveredSignature: isUnrecoveredSignature,
  isUnrecoveredChainedSignature: isUnrecoveredChainedSignature,
  isSignature: isSignature,
  isChainedSignature: isChainedSignature,
  decodeSignature: decodeSignature,
  decodeSignatureBody: decodeSignatureBody,
  decodeChainedSignature: decodeChainedSignature,
  setImageHashStruct: setImageHashStruct,
  recoverSignature: recoverSignature,
  encodeChain: encodeChain,
  encodeSignature: encodeSignature,
  encodeSignatureBody: encodeSignatureBody,
  encodeSignatureTree: encodeSignatureTree,
  signaturesOf: signaturesOf,
  signaturesOfDecoded: signaturesOfDecoded,
  subdigestsOfDecoded: subdigestsOfDecoded,
  trimSignature: trimSignature,
  trimUnrecoveredTree: trimUnrecoveredTree,
  SignatureCoder: SignatureCoder
});

//
// Tree typings - leaves
//

// This is an unknown node
// it means the tree has a branch
// but we don't know what the content

function isSignerLeaf(leaf) {
  return leaf.address !== undefined && leaf.weight !== undefined;
}
function isSubdigestLeaf(leaf) {
  return leaf.subdigest !== undefined && leaf.address === undefined;
}
function topologyToJSON(tree) {
  if (isNode(tree)) {
    return JSON.stringify({
      left: topologyToJSON(tree.left),
      right: topologyToJSON(tree.right)
    });
  }
  if (isNestedLeaf(tree)) {
    return JSON.stringify({
      weight: BigInt(tree.weight).toString(),
      threshold: BigInt(tree.threshold).toString(),
      tree: topologyToJSON(tree.tree)
    });
  }
  if (isSignerLeaf(tree)) {
    return JSON.stringify({
      address: tree.address,
      weight: BigInt(tree.weight).toString()
    });
  }
  return JSON.stringify(tree);
}
function topologyFromJSON(json) {
  const parsed = typeof json === 'string' ? JSON.parse(json) : json;
  if (parsed.left !== undefined && parsed.right !== undefined) {
    return {
      left: topologyFromJSON(parsed.left),
      right: topologyFromJSON(parsed.right)
    };
  }
  if (parsed.weight !== undefined && parsed.threshold !== undefined && parsed.tree !== undefined) {
    return {
      weight: BigInt(parsed.weight),
      threshold: BigInt(parsed.threshold),
      tree: topologyFromJSON(parsed.tree)
    };
  }
  if (parsed.address !== undefined && parsed.weight !== undefined) {
    return {
      address: parsed.address,
      weight: BigInt(parsed.weight)
    };
  }
  return parsed;
}
function isNestedLeaf(leaf) {
  return leaf.tree !== undefined && leaf.weight !== undefined && leaf.threshold !== undefined;
}
function isNodeLeaf(leaf) {
  return leaf.nodeHash !== undefined;
}
function isLeaf(leaf) {
  return isSignerLeaf(leaf) || isSubdigestLeaf(leaf) || isNestedLeaf(leaf) || isNodeLeaf(leaf);
}

//
// Tree typings - nodes
//

function isNode(node) {
  return node.left !== undefined && node.right !== undefined;
}
function isTopology(topology) {
  return isNode(topology) || isLeaf(topology);
}
function encodeSignerLeaf(leaf) {
  return ethers.ethers.solidityPacked(['uint96', 'address'], [leaf.weight, leaf.address]);
}
function decodeSignerLeaf(encoded) {
  const bytes = ethers.ethers.getBytes(encoded);
  if (bytes.length !== 32) {
    throw new Error('Invalid encoded string length');
  }
  const weight = BigInt(ethers.ethers.hexlify(bytes.slice(0, 12)));
  const address = ethers.ethers.getAddress(ethers.ethers.hexlify(bytes.slice(12)));
  return {
    weight,
    address
  };
}
function isEncodedSignerLeaf(encoded) {
  const bytes = ethers.ethers.getBytes(encoded);
  if (bytes.length !== 32) {
    return false;
  }
  const prefix = bytes.slice(0, 11);
  return prefix.every(byte => byte === 0);
}
function hashNode(node) {
  if (isSignerLeaf(node)) {
    return encodeSignerLeaf(node);
  }
  if (isSubdigestLeaf(node)) {
    return ethers.ethers.solidityPackedKeccak256(['string', 'bytes32'], ['Sequence static digest:\n', node.subdigest]);
  }
  if (isNestedLeaf(node)) {
    const nested = hashNode(node.tree);
    return ethers.ethers.solidityPackedKeccak256(['string', 'bytes32', 'uint256', 'uint256'], ['Sequence nested config:\n', nested, node.threshold, node.weight]);
  }
  if (isNodeLeaf(node)) {
    return node.nodeHash;
  }
  return ethers.ethers.solidityPackedKeccak256(['bytes32', 'bytes32'], [hashNode(node.left), hashNode(node.right)]);
}
function leftFace(topology) {
  const stack = [];
  let prev = topology;
  while (!isLeaf(prev)) {
    stack.unshift(prev.right);
    prev = prev.left;
  }
  stack.unshift(prev);
  return stack;
}

//
// Wallet config types
//

function isWalletConfig(config) {
  return config.threshold !== undefined && config.checkpoint !== undefined && config.tree !== undefined && config.version !== undefined && config.version === 2;
}
function imageHash(config) {
  return ethers.ethers.solidityPackedKeccak256(['bytes32', 'uint256'], [ethers.ethers.solidityPackedKeccak256(['bytes32', 'uint256'], [hashNode(config.tree), config.threshold]), config.checkpoint]);
}

//
// Simple wallet config types
// (used for building and reading merkle configs)
//
// dev: `members` is a flat representation of the tree
//      it keeps relevant structure like 'nested trees' but
//      it ignores the tree structure
//
//

function isSimpleNestedMember(member) {
  return member.threshold !== undefined && member.weight !== undefined && member.members !== undefined;
}
function topologyToMembers(tree) {
  if (isSignerLeaf(tree) || isSubdigestLeaf(tree)) {
    return [tree];
  }
  if (isNestedLeaf(tree)) {
    return [{
      threshold: tree.threshold,
      weight: tree.weight,
      members: topologyToMembers(tree.tree)
    }];
  }
  if (isNodeLeaf(tree)) {
    // we don't know the content of this node
    // so we omit it
    return [];
  }
  return [...topologyToMembers(tree.left), ...topologyToMembers(tree.right)];
}
function hasUnknownNodes(tree) {
  if (isNodeLeaf(tree)) {
    return true;
  }
  if (isNode(tree)) {
    return hasUnknownNodes(tree.left) || hasUnknownNodes(tree.right);
  }
  return false;
}
function toSimpleWalletConfig(config) {
  return {
    threshold: config.threshold,
    checkpoint: config.checkpoint,
    members: topologyToMembers(config.tree)
  };
}
const membersAsTopologies = (members, builder) => {
  return members.map(member => {
    if (isSimpleNestedMember(member)) {
      return {
        tree: builder(member.members),
        threshold: member.threshold,
        weight: member.weight
      };
    }
    return member;
  });
};
function legacyTopologyBuilder(members) {
  if (members.length === 0) {
    throw new Error('Empty members array');
  }
  const asTopologies = membersAsTopologies(members, legacyTopologyBuilder);
  return asTopologies.reduce((acc, member) => {
    return {
      left: acc,
      right: member
    };
  });
}
function merkleTopologyBuilder(members) {
  if (members.length === 0) {
    throw new Error('Empty members array');
  }
  const leaves = membersAsTopologies(members, merkleTopologyBuilder);
  for (let s = leaves.length; s > 1; s = s / 2) {
    for (let i = 0; i < s / 2; i++) {
      const j1 = i * 2;
      const j2 = j1 + 1;
      if (j2 >= s) {
        leaves[i] = leaves[j1];
      } else {
        leaves[i] = {
          left: leaves[j1],
          right: leaves[j2]
        };
      }
    }
  }
  return leaves[0];
}
function optimized2SignersTopologyBuilder(members) {
  if (members.length > 8) {
    return merkleTopologyBuilder(members);
  }
  return legacyTopologyBuilder(members);
}
function toWalletConfig(simpleWalletConfig, builder = optimized2SignersTopologyBuilder) {
  return {
    version: 2,
    threshold: simpleWalletConfig.threshold,
    checkpoint: simpleWalletConfig.checkpoint,
    tree: builder(simpleWalletConfig.members)
  };
}
function hasSubdigest(tree, subdigest) {
  if (isSubdigestLeaf(tree)) {
    return tree.subdigest === subdigest;
  }
  if (isNode(tree)) {
    return hasSubdigest(tree.left, subdigest) || hasSubdigest(tree.right, subdigest);
  }
  return false;
}
function signersOf(tree) {
  const stack = [tree];
  const signers = new Set();
  while (stack.length > 0) {
    const node = stack.pop();
    if (isNestedLeaf(node)) {
      stack.push(node.tree);
    } else if (isNode(node)) {
      stack.push(node.left);
      stack.push(node.right);
    } else if (isSignerLeaf(node)) {
      signers.add({
        address: node.address,
        weight: Number(node.weight)
      });
    }
  }
  return Array.from(signers);
}
function isComplete(tree) {
  if (isNode(tree)) {
    return isComplete(tree.left) && isComplete(tree.right);
  }
  return !isNodeLeaf(tree);
}
const ConfigCoder = {
  isWalletConfig: config => {
    return config.version === 2 && config.threshold !== undefined && config.tree !== undefined;
  },
  imageHashOf: config => {
    return imageHash(config);
  },
  hasSubdigest: (config, subdigest) => {
    return hasSubdigest(config.tree, subdigest);
  },
  checkpointOf: config => {
    return BigInt(config.checkpoint);
  },
  signersOf: config => {
    return signersOf(config.tree);
  },
  fromSimple: config => {
    var _config$subdigests;
    return toWalletConfig(_extends({}, config, {
      members: [...config.signers, ...((_config$subdigests = config.subdigests) != null ? _config$subdigests : []).map(subdigest => ({
        subdigest
      }))]
    }));
  },
  isComplete: config => {
    return isComplete(config.tree);
  },
  // isValid = (config: WalletConfig): boolean {}
  /**
   *
   * Notice: context and kind are ignored because v2
   * doesn't need to manually update the implementation before
   * a configuration update, it's automatically done by the contract.
   *
   */
  update: {
    isKindUsed: true,
    buildTransaction: (wallet, config, _context, _kind) => {
      const module = new ethers.ethers.Interface(abi.walletContracts.mainModuleUpgradable.abi);
      return {
        entrypoint: wallet,
        transactions: [{
          to: wallet,
          data: module.encodeFunctionData(module.getFunction('updateImageHash'), [ConfigCoder.imageHashOf(config)]),
          gasLimit: 0,
          delegateCall: false,
          revertOnError: true,
          value: 0
        }]
      };
    },
    decodeTransaction: function (tx) {
      var _tx$transactions$0$va, _tx$transactions$, _tx$transactions$0$ga, _tx$transactions$2;
      const module = new ethers.ethers.Interface(abi.walletContracts.mainModuleUpgradable.abi);
      if (tx.transactions.length !== 1) {
        throw new Error('Invalid transaction bundle, expected 1 transaction');
      }
      const data = tx.transactions[0].data;
      if (!data) {
        throw new Error('Invalid transaction bundle, expected data');
      }
      const decoded = module.decodeFunctionData(module.getFunction('updateImageHash'), data);
      if (!decoded) {
        throw new Error('Invalid transaction bundle, expected valid data');
      }
      if (tx.transactions[0].to !== tx.entrypoint) {
        throw new Error('Invalid transaction bundle, expected to be sent to entrypoint');
      }
      if (tx.transactions[0].delegateCall) {
        throw new Error('Invalid transaction bundle, expected not to be a delegateCall');
      }
      if (!tx.transactions[0].revertOnError) {
        throw new Error('Invalid transaction bundle, expected revertOnError');
      }
      if (BigInt((_tx$transactions$0$va = (_tx$transactions$ = tx.transactions[0]) == null ? void 0 : _tx$transactions$.value) != null ? _tx$transactions$0$va : 0) !== 0n) {
        throw new Error('Invalid transaction bundle, expected value to be 0');
      }
      if (BigInt((_tx$transactions$0$ga = (_tx$transactions$2 = tx.transactions[0]) == null ? void 0 : _tx$transactions$2.gasLimit) != null ? _tx$transactions$0$ga : 0) !== 0n) {
        throw new Error('Invalid transaction bundle, expected value to be 0');
      }
      return {
        address: tx.entrypoint,
        newImageHash: decoded[0],
        kind: undefined
      };
    }
  },
  toJSON: function (config) {
    return JSON.stringify({
      version: config.version,
      threshold: BigInt(config.threshold).toString(),
      checkpoint: BigInt(config.checkpoint).toString(),
      tree: topologyToJSON(config.tree)
    });
  },
  fromJSON: function (json) {
    const config = JSON.parse(json);
    return {
      version: config.version,
      threshold: BigInt(config.threshold),
      checkpoint: BigInt(config.checkpoint),
      tree: topologyFromJSON(config.tree)
    };
  },
  editConfig: function (config, action) {
    var _action$threshold, _action$checkpoint;
    const members = topologyToMembers(config.tree);
    if (action.add) {
      for (const signer of action.add) {
        if (members.find(s => isSignerLeaf(s) && s.address === signer.address)) {
          continue;
        }
        members.push({
          address: signer.address,
          weight: signer.weight
        });
      }
    }
    if (action.remove) {
      for (const address of action.remove) {
        const index = members.findIndex(s => isSignerLeaf(s) && s.address === address);
        if (index >= 0) {
          members.splice(index, 1);
        }
      }
    }
    return {
      version: config.version,
      threshold: (_action$threshold = action.threshold) != null ? _action$threshold : config.threshold,
      checkpoint: (_action$checkpoint = action.checkpoint) != null ? _action$checkpoint : config.checkpoint,
      tree: optimized2SignersTopologyBuilder(members)
    };
  },
  buildStubSignature: function (config, overrides) {
    const parts = new Map();
    for (const [signer, signature] of overrides.entries()) {
      parts.set(signer, {
        signature,
        isDynamic: true
      });
      const {
        encoded,
        weight
      } = encodeSigners(config, parts, [], 0);
      if (weight >= BigInt(config.threshold)) {
        return encoded;
      }
    }
    const signers = signersOf(config.tree);
    for (const {
      address
    } of signers.sort(({
      weight: a
    }, {
      weight: b
    }) => a - b)) {
      const signature = '0x4e82f02f388a12b5f9d29eaf2452dd040c0ee5804b4e504b4dd64e396c6c781f2c7624195acba242dd825bfd25a290912e3c230841fd55c9a734c4de8d9899451b02';
      parts.set(address, {
        signature,
        isDynamic: false
      });
      const {
        encoded,
        weight
      } = encodeSigners(config, parts, [], 0);
      if (weight >= BigInt(config.threshold)) {
        return encoded;
      }
    }
    return encodeSigners(config, parts, [], 0).encoded;
  }
};

var config = /*#__PURE__*/Object.freeze({
  __proto__: null,
  isSignerLeaf: isSignerLeaf,
  isSubdigestLeaf: isSubdigestLeaf,
  topologyToJSON: topologyToJSON,
  topologyFromJSON: topologyFromJSON,
  isNestedLeaf: isNestedLeaf,
  isNodeLeaf: isNodeLeaf,
  isLeaf: isLeaf,
  isNode: isNode,
  isTopology: isTopology,
  encodeSignerLeaf: encodeSignerLeaf,
  decodeSignerLeaf: decodeSignerLeaf,
  isEncodedSignerLeaf: isEncodedSignerLeaf,
  hashNode: hashNode,
  leftFace: leftFace,
  isWalletConfig: isWalletConfig,
  imageHash: imageHash,
  isSimpleNestedMember: isSimpleNestedMember,
  topologyToMembers: topologyToMembers,
  hasUnknownNodes: hasUnknownNodes,
  toSimpleWalletConfig: toSimpleWalletConfig,
  legacyTopologyBuilder: legacyTopologyBuilder,
  merkleTopologyBuilder: merkleTopologyBuilder,
  optimized2SignersTopologyBuilder: optimized2SignersTopologyBuilder,
  toWalletConfig: toWalletConfig,
  hasSubdigest: hasSubdigest,
  signersOf: signersOf,
  isComplete: isComplete,
  ConfigCoder: ConfigCoder
});

var context$1 = /*#__PURE__*/Object.freeze({
  __proto__: null
});

const coders = {
  config: ConfigCoder,
  signature: SignatureCoder
};
const version = 2;
const DeployedWalletContext = {
  version: version,
  factory: '0xFaA5c0b14d1bED5C888Ca655B9a8A5911F78eF4A',
  guestModule: '0xfea230Ee243f88BC698dD8f1aE93F8301B6cdfaE',
  mainModule: '0xfBf8f1A5E00034762D928f46d438B947f5d4065d',
  mainModuleUpgradable: '0x4222dcA3974E39A8b41c411FeDDE9b09Ae14b911',
  walletCreationCode: '0x603a600e3d39601a805130553df3363d3d373d3d3d363d30545af43d82803e903d91601857fd5bf3'
};

var v2 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  config: config,
  signature: signature,
  context: context$1,
  chained: chained,
  coders: coders,
  version: version,
  DeployedWalletContext: DeployedWalletContext
});

function addressOf(context, imageHash) {
  const codeHash = ethers.ethers.keccak256(ethers.ethers.solidityPacked(['bytes', 'bytes32'], [context.walletCreationCode, ethers.ethers.zeroPadValue(context.mainModule, 32)]));
  const hash = ethers.ethers.keccak256(ethers.ethers.solidityPacked(['bytes1', 'address', 'bytes32', 'bytes32'], ['0xff', context.factory, imageHash, codeHash]));
  return ethers.ethers.getAddress(ethers.ethers.dataSlice(hash, 12));
}
async function isValidCounterfactual(wallet, digest, signature, chainId, provider, contexts) {
  // We don't know the version of the signature
  // so we need to try all of them
  const res = await Promise.all(allVersions.map(async version => {
    try {
      const decoded = version.signature.SignatureCoder.decode(ethers.ethers.hexlify(signature));
      const recovered1 = await version.signature.SignatureCoder.recover(decoded, {
        address: wallet,
        digest: ethers.ethers.hexlify(digest),
        chainId
      }, provider);
      const imageHash = version.config.ConfigCoder.imageHashOf(recovered1.config);
      const counterfactualAddress = addressOf(contexts[version.version], imageHash);
      if (counterfactualAddress.toLowerCase() === wallet.toLowerCase()) {
        return true;
      }

      // chainId=0 means no chainId, so the signature is valid for all chains
      // we need to check that case too
      const recovered2 = await version.signature.SignatureCoder.recover(decoded, {
        address: wallet,
        digest: ethers.ethers.hexlify(digest),
        chainId
      }, provider);
      const imageHash2 = version.config.ConfigCoder.imageHashOf(recovered2.config);
      const counterfactualAddress2 = addressOf(contexts[version.version], imageHash2);
      return counterfactualAddress2.toLowerCase() === wallet.toLowerCase();
    } catch (_unused) {}

    // We most likely failed to decode the signature
    return false;
  }));
  return res.some(r => r);
}
function isValidVersionedContext(contexts) {
  // number of keys is the number of versions
  const versions = Object.keys(contexts).length;

  // check that all versions exist and are valid
  for (let i = 1; i <= versions; i++) {
    const context = contexts[i];
    if (!context || context.version !== i) {
      return false;
    }
  }
  return true;
}
function latestContext(contexts) {
  const versions = Object.keys(contexts).length;
  return contexts[versions];
}
const defaultContexts = {
  1: DeployedWalletContext$1,
  2: DeployedWalletContext
};

var context = /*#__PURE__*/Object.freeze({
  __proto__: null,
  addressOf: addressOf,
  isValidCounterfactual: isValidCounterfactual,
  isValidVersionedContext: isValidVersionedContext,
  latestContext: latestContext,
  defaultContexts: defaultContexts
});

const MetaTransactionsType = `tuple(
  bool delegateCall,
  bool revertOnError,
  uint256 gasLimit,
  address target,
  uint256 value,
  bytes data
)[]`;
function intendTransactionBundle(bundle, wallet, chainId, id) {
  return _extends({}, bundle, {
    chainId,
    intent: {
      id: id,
      wallet
    }
  });
}
function intendedTransactionID(bundle) {
  return ethers.ethers.keccak256(ethers.ethers.AbiCoder.defaultAbiCoder().encode(['address', 'uint256', 'bytes32'], [bundle.intent.wallet, bundle.chainId, bundle.intent.id]));
}
function unpackMetaTransactionsData(data) {
  const res = ethers.ethers.AbiCoder.defaultAbiCoder().decode(['uint256', MetaTransactionsType], data);
  if (res.length !== 2 || !res[0] || !res[1]) throw new Error('Invalid meta transaction data');
  return [res[0], res[1]];
}
function packMetaTransactionsData(nonce, txs) {
  return ethers.ethers.AbiCoder.defaultAbiCoder().encode(['uint256', MetaTransactionsType], [nonce, sequenceTxAbiEncode(txs)]);
}
function digestOfTransactions(nonce, txs) {
  return ethers.ethers.keccak256(packMetaTransactionsData(nonce, txs));
}
function subdigestOfTransactions(address, chainId, nonce, txs) {
  return subdigestOf({
    address,
    chainId,
    digest: digestOfTransactions(nonce, txs)
  });
}
function subdigestOfGuestModuleTransactions(guestModule, chainId, txs) {
  return subdigestOf({
    address: guestModule,
    chainId,
    digest: ethers.ethers.keccak256(ethers.ethers.AbiCoder.defaultAbiCoder().encode(['string', MetaTransactionsType], ['guest:', sequenceTxAbiEncode(txs)]))
  });
}
function toSequenceTransactions(wallet, txs) {
  return txs.map(tx => toSequenceTransaction(wallet, tx));
}
function toSequenceTransaction(wallet, tx) {
  if (tx.to && tx.to !== ethers.ethers.ZeroAddress) {
    return {
      nonce: !isNullish(tx.nonce) ? BigInt(tx.nonce) : undefined,
      transaction: {
        delegateCall: false,
        revertOnError: false,
        gasLimit: !isNullish(tx.gasLimit) ? BigInt(tx.gasLimit) : undefined,
        // XXX: `tx.to` could also be ethers Addressable type which returns a getAddress promise
        // Keeping this as is for now so we don't have to change everything to async
        to: tx.to,
        value: BigInt(tx.value || 0),
        data: tx.data || '0x'
      }
    };
  } else {
    const walletInterface = new ethers.ethers.Interface(abi.walletContracts.mainModule.abi);
    const data = walletInterface.encodeFunctionData(walletInterface.getFunction('createContract'), [tx.data]);
    return {
      nonce: typeof tx.nonce === 'number' ? BigInt(tx.nonce) : undefined,
      transaction: {
        delegateCall: false,
        revertOnError: false,
        gasLimit: !isNullish(tx.gasLimit) ? BigInt(tx.gasLimit) : undefined,
        to: wallet,
        value: BigInt(tx.value || 0),
        data
      }
    };
  }
}
function isSequenceTransaction(tx) {
  return tx.delegateCall !== undefined || tx.revertOnError !== undefined;
}
function hasSequenceTransactions(txs) {
  return txs.every(isSequenceTransaction);
}

// TODO: We may be able to remove this if we make Transaction === TransactionEncoded
function sequenceTxAbiEncode(txs) {
  return txs.map(tx => {
    var _tx$to;
    return {
      delegateCall: tx.delegateCall === true,
      revertOnError: tx.revertOnError === true,
      gasLimit: !isNullish(tx.gasLimit) ? BigInt(tx.gasLimit) : 0n,
      target: (_tx$to = tx.to) != null ? _tx$to : ethers.ethers.ZeroAddress,
      value: !isNullish(tx.value) ? tx.value : 0n,
      data: tx.data || '0x'
    };
  });
}
function fromTxAbiEncode(txs) {
  return txs.map(tx => ({
    delegateCall: tx.delegateCall,
    revertOnError: tx.revertOnError,
    gasLimit: tx.gasLimit,
    to: tx.target,
    value: tx.value,
    data: tx.data
  }));
}

// export function appendNonce(txs: Transaction[], nonce: ethers.BigNumberish): Transaction[] {
//   return txs.map((t: Transaction) => ({ ...t, nonce }))
// }

function encodeNonce(space, nonce) {
  const bspace = BigInt(space);
  const bnonce = BigInt(nonce);
  const shl = 2n ** 96n;
  if (bnonce / shl !== 0n) {
    throw new Error('Space already encoded');
  }
  return bnonce + bspace * shl;
}
function decodeNonce(nonce) {
  const bnonce = BigInt(nonce);
  const shr = 2n ** 96n;
  return [bnonce / shr, bnonce % shr];
}
function fromTransactionish(wallet, transaction) {
  if (Array.isArray(transaction)) {
    if (hasSequenceTransactions(transaction)) {
      return transaction;
    } else {
      const stx = toSequenceTransactions(wallet, transaction);
      return stx.map(t => t.transaction);
    }
  } else if (isSequenceTransaction(transaction)) {
    return [transaction];
  } else {
    return [toSequenceTransaction(wallet, transaction).transaction];
  }
}
function isTransactionBundle(cand) {
  return cand !== undefined && cand.entrypoint !== undefined && cand.chainId !== undefined && cand.transactions !== undefined && cand.nonce !== undefined && cand.intent !== undefined && cand.intent.id !== undefined && cand.intent.wallet !== undefined && Array.isArray(cand.transactions) && cand.transactions.reduce((p, c) => p && isSequenceTransaction(c), true);
}
function isSignedTransactionBundle(cand) {
  return cand !== undefined && cand.signature !== undefined && cand.signature !== '' && isTransactionBundle(cand);
}
function encodeBundleExecData(bundle) {
  const walletInterface = new ethers.ethers.Interface(abi.walletContracts.mainModule.abi);
  return walletInterface.encodeFunctionData(walletInterface.getFunction('execute'), isSignedTransactionBundle(bundle) ? [
  // Signed transaction bundle has all 3 parameters
  sequenceTxAbiEncode(bundle.transactions), bundle.nonce, bundle.signature] : [
  // Unsigned bundle may be a GuestModule call, so signature and nonce are missing
  sequenceTxAbiEncode(bundle.transactions), 0, new Uint8Array([])]);
}

// TODO: Use Sequence ABI package
const selfExecuteSelector = '0x61c2926c';
const selfExecuteAbi = `tuple(
  bool delegateCall,
  bool revertOnError,
  uint256 gasLimit,
  address target,
  uint256 value,
  bytes data
)[]`;

// Splits Sequence batch transactions into individual parts
const unwind = (wallet, transactions) => {
  const unwound = [];
  const walletInterface = new ethers.ethers.Interface(abi.walletContracts.mainModule.abi);
  for (const tx of transactions) {
    const txData = ethers.ethers.getBytes(tx.data || '0x');
    if (tx.to === wallet && ethers.ethers.hexlify(txData.slice(0, 4)) === selfExecuteSelector) {
      // Decode as selfExecute call
      const data = txData.slice(4);
      const decoded = ethers.ethers.AbiCoder.defaultAbiCoder().decode([selfExecuteAbi], data)[0];
      unwound.push(...unwind(tx.to, decoded.map(d => _extends({}, d, {
        to: d.target
      }))));
    } else {
      try {
        const innerTransactions = walletInterface.decodeFunctionData('execute', txData)[0];
        const unwoundTransactions = unwind(wallet, innerTransactions.map(tx => _extends({}, tx.toObject(), {
          to: tx.target
        })));
        unwound.push(...unwoundTransactions);
      } catch (_unused) {
        unwound.push(tx);
      }
    }
  }
  return unwound;
};
const isNullish = value => value === null || value === void 0;

var transaction = /*#__PURE__*/Object.freeze({
  __proto__: null,
  MetaTransactionsType: MetaTransactionsType,
  intendTransactionBundle: intendTransactionBundle,
  intendedTransactionID: intendedTransactionID,
  unpackMetaTransactionsData: unpackMetaTransactionsData,
  packMetaTransactionsData: packMetaTransactionsData,
  digestOfTransactions: digestOfTransactions,
  subdigestOfTransactions: subdigestOfTransactions,
  subdigestOfGuestModuleTransactions: subdigestOfGuestModuleTransactions,
  toSequenceTransactions: toSequenceTransactions,
  toSequenceTransaction: toSequenceTransaction,
  isSequenceTransaction: isSequenceTransaction,
  hasSequenceTransactions: hasSequenceTransactions,
  sequenceTxAbiEncode: sequenceTxAbiEncode,
  fromTxAbiEncode: fromTxAbiEncode,
  encodeNonce: encodeNonce,
  decodeNonce: decodeNonce,
  fromTransactionish: fromTransactionish,
  isTransactionBundle: isTransactionBundle,
  isSignedTransactionBundle: isSignedTransactionBundle,
  encodeBundleExecData: encodeBundleExecData,
  selfExecuteSelector: selfExecuteSelector,
  selfExecuteAbi: selfExecuteAbi,
  unwind: unwind
});

/* Source of Offchain EIP-6492 validation:

// SPDX-License-Identifier: Apache-2.0
pragma solidity 0.8.18;


// As per ERC-1271
interface IERC1271Wallet {
  function isValidSignature(bytes32 hash, bytes calldata signature) external view returns (bytes4 magicValue);
}

error ERC1271Revert(bytes error);
error ERC6492DeployFailed(bytes error);

contract UniversalSigValidator {
  bytes32 private constant ERC6492_DETECTION_SUFFIX = 0x6492649264926492649264926492649264926492649264926492649264926492;
  bytes4 private constant ERC1271_SUCCESS = 0x1626ba7e;

  function isValidSigImpl(
    address _signer,
    bytes32 _hash,
    bytes calldata _signature,
    bool allowSideEffects,
    bool deployAlreadyDeployed
  ) public returns (bool) {
    uint contractCodeLen = address(_signer).code.length;
    bytes memory sigToValidate;
    // The order here is striclty defined in https://eips.ethereum.org/EIPS/eip-6492
    // - ERC-6492 suffix check and verification first, while being permissive in case the contract is already deployed; if the contract is deployed we will check the sig against the deployed version, this allows 6492 signatures to still be validated while taking into account potential key rotation
    // - ERC-1271 verification if there's contract code
    // - finally, ecrecover
    bool isCounterfactual = bytes32(_signature[_signature.length-32:_signature.length]) == ERC6492_DETECTION_SUFFIX;
    if (isCounterfactual) {
      address create2Factory;
      bytes memory factoryCalldata;
      (create2Factory, factoryCalldata, sigToValidate) = abi.decode(_signature[0:_signature.length-32], (address, bytes, bytes));

      if (contractCodeLen == 0 || deployAlreadyDeployed) {
        (bool success, bytes memory err) = create2Factory.call(factoryCalldata);
        if (!success) revert ERC6492DeployFailed(err);
      }
    } else {
      sigToValidate = _signature;
    }

    // Try ERC-1271 verification
    if (isCounterfactual || contractCodeLen > 0) {
      try IERC1271Wallet(_signer).isValidSignature(_hash, sigToValidate) returns (bytes4 magicValue) {
        bool isValid = magicValue == ERC1271_SUCCESS;

        // EXPERIMENTAL: This is not part of the EIP-6492 spec *yet*
        // but it may be useful to retry the call making the factory call
        // even if the wallet is already deployed, in case the wallet
        // needs to perform some sort of migration or onchain key rotation
        if (!isValid && !deployAlreadyDeployed && contractCodeLen > 0) {
          return isValidSigImpl(_signer, _hash, _signature, allowSideEffects, true);
        }

        if (contractCodeLen == 0 && isCounterfactual && !allowSideEffects) {
          // if the call had side effects we need to return the
          // result using a `revert` (to undo the state changes)
          assembly {
            mstore(0, isValid)
            revert(31, 1)
          }
        }

        return isValid;
      } catch (bytes memory err) {
        // EXPERIMENTAL: This is not part of the EIP-6492 spec *yet*
        // but it may be useful to retry the call making the factory call
        // even if the wallet is already deployed, in case the wallet
        // needs to perform some sort of migration or onchain key rotation
        if (!deployAlreadyDeployed && contractCodeLen > 0) {
          return isValidSigImpl(_signer, _hash, _signature, allowSideEffects, true);
        }

        revert ERC1271Revert(err);
      }
    }

    // ecrecover verification
    require(_signature.length == 65, 'SignatureValidator#recoverSigner: invalid signature length');
    bytes32 r = bytes32(_signature[0:32]);
    bytes32 s = bytes32(_signature[32:64]);
    uint8 v = uint8(_signature[64]);

    if (v != 27 && v != 28) {
      revert('SignatureValidator: invalid signature v value');
    }

    return ecrecover(_hash, v, r, s) == _signer;
  }

  function isValidSigWithSideEffects(
    address _signer,
    bytes32 _hash,
    bytes calldata _signature
  ) external returns (bool) {
    return this.isValidSigImpl(_signer, _hash, _signature, true, false);
  }

  function isValidSig(
    address _signer,
    bytes32 _hash,
    bytes calldata _signature
  ) external returns (bool) {
    try this.isValidSigImpl(_signer, _hash, _signature, false, false) returns (bool isValid) {
      return isValid;
    } catch (bytes memory error) {
      // in order to avoid side effects from the contract getting deployed, the entire call will revert with a single byte result
      uint len = error.length;
      if (len == 1) {
        return error[0] == 0x01;
        // all other errors are simply forwarded, but in custom formats so that nothing else can revert with a single byte in the call
      } else {
        assembly { revert(error, len) }
      }
    }
  }

  // NOTICE: These functions aren't part of the standard
  // they are helpers that behave like the above functions
  // but they don't revert on failure, instead they return false

  function isValidSigNoThrow(
    address _signer,
    bytes32 _hash,
    bytes calldata _signature
  ) external returns (bool) {
    try this.isValidSigImpl(_signer, _hash, _signature, false, false) returns (bool isValid) {
      return isValid;
    } catch (bytes memory error) {
      // in order to avoid side effects from the contract getting deployed, the entire call will revert with a single byte result
      uint len = error.length;
      if (len == 1) {
        return error[0] == 0x01;
        // all other errors are simply forwarded, but in custom formats so that nothing else can revert with a single byte in the call
      } else {
        // Ignore all other errors and return false
        return false;
      }
    }
  }

  function isValidSigWithSideEffectsNoThrow(
    address _signer,
    bytes32 _hash,
    bytes calldata _signature
  ) external returns (bool) {
    try this.isValidSigImpl(_signer, _hash, _signature, true, false) returns (bool isValid) {
      return isValid;
    } catch (bytes memory error) {
      // Ignore all errors and return false
      return false;
    }
  }
}

// this is a helper so we can perform validation in a single eth_call without pre-deploying a singleton
contract ValidateSigOffchain {
  constructor (address _signer, bytes32 _hash, bytes memory _signature) {
    UniversalSigValidator validator = new UniversalSigValidator();
    bool isValidSig = validator.isValidSigWithSideEffects(_signer, _hash, _signature);
    assembly {
      mstore(0, isValidSig)
      return(31, 1)
    }
  }
}
*/

const EIP_6492_OFFCHAIN_DEPLOY_CODE = '0x608060405234801561001057600080fd5b5060405161124a38038061124a83398101604081905261002f91610124565b600060405161003d906100dd565b604051809103906000f080158015610059573d6000803e3d6000fd5b5090506000816001600160a01b0316638f0684308686866040518463ffffffff1660e01b815260040161008e939291906101fb565b6020604051808303816000875af11580156100ad573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906100d19190610244565b9050806000526001601ff35b610fdc8061026e83390190565b634e487b7160e01b600052604160045260246000fd5b60005b8381101561011b578181015183820152602001610103565b50506000910152565b60008060006060848603121561013957600080fd5b83516001600160a01b038116811461015057600080fd5b6020850151604086015191945092506001600160401b038082111561017457600080fd5b818601915086601f83011261018857600080fd5b81518181111561019a5761019a6100ea565b604051601f8201601f19908116603f011681019083821181831017156101c2576101c26100ea565b816040528281528960208487010111156101db57600080fd5b6101ec836020830160208801610100565b80955050505050509250925092565b60018060a01b0384168152826020820152606060408201526000825180606084015261022e816080850160208701610100565b601f01601f191691909101608001949350505050565b60006020828403121561025657600080fd5b8151801515811461026657600080fd5b939250505056fe608060405234801561001057600080fd5b50610fbc806100206000396000f3fe608060405234801561001057600080fd5b50600436106100675760003560e01c806376be4cea1161005057806376be4cea146100a65780638f068430146100b957806398ef1ed8146100cc57600080fd5b80631c6453271461006c5780633d787b6314610093575b600080fd5b61007f61007a366004610ad4565b6100df565b604051901515815260200160405180910390f35b61007f6100a1366004610ad4565b61023d565b61007f6100b4366004610b3e565b61031e565b61007f6100c7366004610ad4565b6108e1565b61007f6100da366004610ad4565b61096e565b6040517f76be4cea00000000000000000000000000000000000000000000000000000000815260009030906376be4cea9061012890889088908890889088908190600401610bc3565b6020604051808303816000875af1925050508015610181575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016820190925261017e91810190610c45565b60015b610232573d8080156101af576040519150601f19603f3d011682016040523d82523d6000602084013e6101b4565b606091505b508051600181900361022757816000815181106101d3576101d3610c69565b6020910101517fff00000000000000000000000000000000000000000000000000000000000000167f0100000000000000000000000000000000000000000000000000000000000000149250610235915050565b600092505050610235565b90505b949350505050565b6040517f76be4cea00000000000000000000000000000000000000000000000000000000815260009030906376be4cea906102879088908890889088906001908990600401610bc3565b6020604051808303816000875af19250505080156102e0575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01682019092526102dd91810190610c45565b60015b610232573d80801561030e576040519150601f19603f3d011682016040523d82523d6000602084013e610313565b606091505b506000915050610235565b600073ffffffffffffffffffffffffffffffffffffffff87163b6060827f64926492649264926492649264926492649264926492649264926492649264928888610369602082610c98565b610375928b9290610cd8565b61037e91610d02565b1490508015610484576000606089828a610399602082610c98565b926103a693929190610cd8565b8101906103b39190610e18565b955090925090508415806103c45750865b1561047d576000808373ffffffffffffffffffffffffffffffffffffffff16836040516103f19190610eb2565b6000604051808303816000865af19150503d806000811461042e576040519150601f19603f3d011682016040523d82523d6000602084013e610433565b606091505b50915091508161047a57806040517f9d0d6e2d0000000000000000000000000000000000000000000000000000000081526004016104719190610f18565b60405180910390fd5b50505b50506104be565b87878080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152509294505050505b80806104ca5750600083115b156106bb576040517f1626ba7e00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8b1690631626ba7e90610523908c908690600401610f2b565b602060405180830381865afa92505050801561057a575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016820190925261057791810190610f44565b60015b61060f573d8080156105a8576040519150601f19603f3d011682016040523d82523d6000602084013e6105ad565b606091505b50851580156105bc5750600084115b156105db576105d08b8b8b8b8b600161031e565b9450505050506108d7565b806040517f6f2a95990000000000000000000000000000000000000000000000000000000081526004016104719190610f18565b7fffffffff0000000000000000000000000000000000000000000000000000000081167f1626ba7e000000000000000000000000000000000000000000000000000000001480158161065f575086155b801561066b5750600085115b1561068b5761067f8c8c8c8c8c600161031e565b955050505050506108d7565b841580156106965750825b80156106a0575087155b156106af57806000526001601ffd5b94506108d79350505050565b6041871461074b576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603a60248201527f5369676e617475726556616c696461746f72237265636f7665725369676e657260448201527f3a20696e76616c6964207369676e6174757265206c656e6774680000000000006064820152608401610471565b600061075a6020828a8c610cd8565b61076391610d02565b90506000610775604060208b8d610cd8565b61077e91610d02565b905060008a8a604081811061079557610795610c69565b919091013560f81c915050601b81148015906107b557508060ff16601c14155b15610842576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602d60248201527f5369676e617475726556616c696461746f723a20696e76616c6964207369676e60448201527f617475726520762076616c7565000000000000000000000000000000000000006064820152608401610471565b6040805160008152602081018083528e905260ff831691810191909152606081018490526080810183905273ffffffffffffffffffffffffffffffffffffffff8e169060019060a0016020604051602081039080840390855afa1580156108ad573d6000803e3d6000fd5b5050506020604051035173ffffffffffffffffffffffffffffffffffffffff161496505050505050505b9695505050505050565b6040517f76be4cea00000000000000000000000000000000000000000000000000000000815260009030906376be4cea9061092b9088908890889088906001908990600401610bc3565b6020604051808303816000875af115801561094a573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102329190610c45565b6040517f76be4cea00000000000000000000000000000000000000000000000000000000815260009030906376be4cea906109b790889088908890889088908190600401610bc3565b6020604051808303816000875af1925050508015610a10575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0168201909252610a0d91810190610c45565b60015b610232573d808015610a3e576040519150601f19603f3d011682016040523d82523d6000602084013e610a43565b606091505b5080516001819003610a6257816000815181106101d3576101d3610c69565b8082fd5b73ffffffffffffffffffffffffffffffffffffffff81168114610a8857600080fd5b50565b60008083601f840112610a9d57600080fd5b50813567ffffffffffffffff811115610ab557600080fd5b602083019150836020828501011115610acd57600080fd5b9250929050565b60008060008060608587031215610aea57600080fd5b8435610af581610a66565b935060208501359250604085013567ffffffffffffffff811115610b1857600080fd5b610b2487828801610a8b565b95989497509550505050565b8015158114610a8857600080fd5b60008060008060008060a08789031215610b5757600080fd5b8635610b6281610a66565b955060208701359450604087013567ffffffffffffffff811115610b8557600080fd5b610b9189828a01610a8b565b9095509350506060870135610ba581610b30565b91506080870135610bb581610b30565b809150509295509295509295565b73ffffffffffffffffffffffffffffffffffffffff8716815285602082015260a060408201528360a0820152838560c0830137600060c085830181019190915292151560608201529015156080820152601f9092017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016909101019392505050565b600060208284031215610c5757600080fd5b8151610c6281610b30565b9392505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b81810381811115610cd2577f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b92915050565b60008085851115610ce857600080fd5b83861115610cf557600080fd5b5050820193919092039150565b80356020831015610cd2577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff602084900360031b1b1692915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b600082601f830112610d7e57600080fd5b813567ffffffffffffffff80821115610d9957610d99610d3e565b604051601f83017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f01168101908282118183101715610ddf57610ddf610d3e565b81604052838152866020858801011115610df857600080fd5b836020870160208301376000602085830101528094505050505092915050565b600080600060608486031215610e2d57600080fd5b8335610e3881610a66565b9250602084013567ffffffffffffffff80821115610e5557600080fd5b610e6187838801610d6d565b93506040860135915080821115610e7757600080fd5b50610e8486828701610d6d565b9150509250925092565b60005b83811015610ea9578181015183820152602001610e91565b50506000910152565b60008251610ec4818460208701610e8e565b9190910192915050565b60008151808452610ee6816020860160208601610e8e565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b602081526000610c626020830184610ece565b8281526040602082015260006102356040830184610ece565b600060208284031215610f5657600080fd5b81517fffffffff0000000000000000000000000000000000000000000000000000000081168114610c6257600080fdfea26469706673582212201a72aed4b15ffb05b6502997a9bb655992e06590bd26b336dfbb153d7ff6f34b64736f6c63430008120033';
const EIP_6492_SUFFIX = '0x6492649264926492649264926492649264926492649264926492649264926492';

// TODO: This is a length payload, we can lower the load by deploying
// the contract on some of the popular chains, and calling the contract
// if the provider is one of those chains
async function validateEIP6492Offchain(provider, signer, hash, signature) {
  try {
    const result = await provider.call({
      data: ethers.ethers.concat([EIP_6492_OFFCHAIN_DEPLOY_CODE, ethers.ethers.AbiCoder.defaultAbiCoder().encode(['address', 'bytes32', 'bytes'], [signer, hash, signature])])
    });
    return result === '0x01';
  } catch (err) {
    return false;
  }
}

var validateEIP6492 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  EIP_6492_OFFCHAIN_DEPLOY_CODE: EIP_6492_OFFCHAIN_DEPLOY_CODE,
  EIP_6492_SUFFIX: EIP_6492_SUFFIX,
  validateEIP6492Offchain: validateEIP6492Offchain
});

/**
 * Provides stateful information about the wallet.
 */

/**
 * The OnChainReader class fetches on-chain data from a wallet.
 * It is used to understand the "real" state of the wallet contract on-chain.
 */
class OnChainReader {
  constructor(provider) {
    this.provider = provider;
    // Simple cache to avoid re-fetching the same data
    this.isDeployedCache = new Set();
  }
  module(address) {
    return new ethers.ethers.Contract(address, [...abi.walletContracts.mainModuleUpgradable.abi, ...abi.walletContracts.mainModule.abi, ...abi.walletContracts.erc1271.abi], this.provider);
  }
  async isDeployed(wallet) {
    // This is safe to cache because the wallet cannot be undeployed once deployed
    if (this.isDeployedCache.has(wallet)) {
      return true;
    }
    const code = await this.provider.getCode(wallet).then(c => ethers.ethers.getBytes(c));
    const isDeployed = code.length !== 0;
    if (isDeployed) {
      this.isDeployedCache.add(wallet);
    }
    return isDeployed;
  }
  async implementation(wallet) {
    const position = ethers.ethers.AbiCoder.defaultAbiCoder().encode(['address'], [wallet]);
    const val = await this.provider.getStorage(wallet, position).then(c => ethers.ethers.getBytes(c));
    if (val.length === 20) {
      return ethers.ethers.getAddress(ethers.ethers.hexlify(val));
    }
    if (val.length === 32) {
      return ethers.ethers.AbiCoder.defaultAbiCoder().decode(['address'], val)[0];
    }
    return undefined;
  }
  async imageHash(wallet) {
    try {
      const imageHash = await this.module(wallet).imageHash();
      return imageHash;
    } catch (_unused) {}
    return undefined;
  }
  async nonce(wallet, space = 0) {
    try {
      const nonce = await this.module(wallet).readNonce(space);
      return nonce;
    } catch (e) {
      if (!(await this.isDeployed(wallet))) {
        return 0;
      }
      throw e;
    }
  }

  // We use the EIP-6492 validator contract to check the signature
  // this means that if the wallet is not deployed, then the signature
  // must be prefixed with a transaction that deploys the wallet
  async isValidSignature(wallet, digest, signature) {
    return validateEIP6492Offchain(this.provider, wallet, digest, signature);
  }
}

var reader = /*#__PURE__*/Object.freeze({
  __proto__: null,
  OnChainReader: OnChainReader
});

/**
 * Request metadata, used by the wallet to pass additional information through the orchestrator.
 */

function isWalletSignRequestMetadata(obj) {
  return obj && obj.address && obj.digest && obj.chainId !== undefined && obj.config;
}

/**
 * Request metadata, used by the wallet to pass additional information through the orchestrator.
 */

var index$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  config: config$2,
  signature: signature$2,
  context: context,
  signer: signer,
  EIP1271: validateEIP1271,
  transaction: transaction,
  reader: reader,
  EIP6492: validateEIP6492,
  isWalletSignRequestMetadata: isWalletSignRequestMetadata
});

const ALL_CODERS = [{
  config: ConfigCoder$1,
  signature: SignatureCoder$1
}, {
  config: ConfigCoder,
  signature: SignatureCoder
}];
function coderFor(version) {
  const index = version - 1;
  if (index < 0 || index >= ALL_CODERS.length) {
    throw new Error(`No coder for version: ${version}`);
  }
  return ALL_CODERS[index];
}

/**
 *  Same as `coderFor` but returns `generic` coders without versioned types.
 */
function genericCoderFor(version) {
  return coderFor(version);
}

var index = /*#__PURE__*/Object.freeze({
  __proto__: null,
  ALL_CODERS: ALL_CODERS,
  coderFor: coderFor,
  genericCoderFor: genericCoderFor
});

const VERSION = '2.0.10';

const allVersions = [v1, v2];

exports.VERSION = VERSION;
exports.allVersions = allVersions;
exports.commons = index$1;
exports.universal = index;
exports.v1 = v1;
exports.v2 = v2;
