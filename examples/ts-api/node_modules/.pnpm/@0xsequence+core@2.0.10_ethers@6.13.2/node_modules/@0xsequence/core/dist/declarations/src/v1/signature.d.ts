import { ethers } from 'ethers';
import * as base from "../commons/signature.js";
import { AddressMember, WalletConfig } from "./config.js";
export declare enum SignaturePartType {
    EOASignature = 0,
    Address = 1,
    DynamicSignature = 2
}
export type Signature = base.Signature<WalletConfig>;
export type UnrecoveredSignatureMember = {
    unrecovered: true;
    weight: ethers.BigNumberish;
    signature: string;
    address?: string;
    isDynamic: boolean;
};
export type UnrecoveredMember = AddressMember | UnrecoveredSignatureMember;
export type UnrecoveredSignature = base.UnrecoveredSignature & {
    threshold: ethers.BigNumberish;
    signers: UnrecoveredMember[];
};
export declare function isAddressMember(member: any): member is AddressMember;
export declare function isUnrecoveredSignatureMember(member: any): member is UnrecoveredSignatureMember;
export declare function isUnrecoveredSignature(signature: Signature | UnrecoveredSignature): signature is UnrecoveredSignature;
export declare function decodeSignature(signature: ethers.BytesLike): UnrecoveredSignature;
export declare function encodeSignature(signature: Signature | UnrecoveredSignature | ethers.BytesLike): string;
export declare function recoverSignature(data: UnrecoveredSignature, payload: base.SignedPayload, provider: ethers.Provider): Promise<Signature>;
export declare function encodeSigners(config: WalletConfig, signatures: Map<string, base.SignaturePart>, subdigests: string[], _: ethers.BigNumberish): {
    encoded: string;
    weight: bigint;
};
export declare const SignatureCoder: base.SignatureCoder<WalletConfig, Signature, UnrecoveredSignature>;
