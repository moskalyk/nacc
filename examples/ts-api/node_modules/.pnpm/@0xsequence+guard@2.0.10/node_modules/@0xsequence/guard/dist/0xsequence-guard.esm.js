import { commons, universal } from '@0xsequence/core';
import { signers } from '@0xsequence/signhub';
import { encodeTypedDataDigest } from '@0xsequence/utils';
import { ethers } from 'ethers';

function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}

//
// Types
//

//
// Client
//
class Guard {
  constructor(hostname, fetch) {
    this.hostname = void 0;
    this.fetch = void 0;
    this.path = '/rpc/Guard/';
    this.ping = (headers, signal) => {
      return this.fetch(this.url('Ping'), createHTTPRequest({}, headers, signal)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            status: _data.status
          };
        });
      }, error => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ''}`
        });
      });
    };
    this.version = (headers, signal) => {
      return this.fetch(this.url('Version'), createHTTPRequest({}, headers, signal)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            version: _data.version
          };
        });
      }, error => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ''}`
        });
      });
    };
    this.runtimeStatus = (headers, signal) => {
      return this.fetch(this.url('RuntimeStatus'), createHTTPRequest({}, headers, signal)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            status: _data.status
          };
        });
      }, error => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ''}`
        });
      });
    };
    this.getSignerConfig = (args, headers, signal) => {
      return this.fetch(this.url('GetSignerConfig'), createHTTPRequest(args, headers, signal)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            signerConfig: _data.signerConfig
          };
        });
      }, error => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ''}`
        });
      });
    };
    this.sign = (args, headers, signal) => {
      return this.fetch(this.url('Sign'), createHTTPRequest(args, headers, signal)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            sig: _data.sig
          };
        });
      }, error => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ''}`
        });
      });
    };
    this.signWith = (args, headers, signal) => {
      return this.fetch(this.url('SignWith'), createHTTPRequest(args, headers, signal)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            sig: _data.sig
          };
        });
      }, error => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ''}`
        });
      });
    };
    this.patch = (args, headers, signal) => {
      return this.fetch(this.url('Patch'), createHTTPRequest(args, headers, signal)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            txs: _data.txs
          };
        });
      }, error => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ''}`
        });
      });
    };
    this.authMethods = (args, headers, signal) => {
      return this.fetch(this.url('AuthMethods'), createHTTPRequest(args, headers, signal)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            methods: _data.methods,
            active: _data.active
          };
        });
      }, error => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ''}`
        });
      });
    };
    this.setPIN = (args, headers, signal) => {
      return this.fetch(this.url('SetPIN'), createHTTPRequest(args, headers, signal)).then(res => {
        return buildResponse(res).then(_data => {
          return {};
        });
      }, error => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ''}`
        });
      });
    };
    this.resetPIN = (args, headers, signal) => {
      return this.fetch(this.url('ResetPIN'), createHTTPRequest(args, headers, signal)).then(res => {
        return buildResponse(res).then(_data => {
          return {};
        });
      }, error => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ''}`
        });
      });
    };
    this.createTOTP = (args, headers, signal) => {
      return this.fetch(this.url('CreateTOTP'), createHTTPRequest(args, headers, signal)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            uri: _data.uri
          };
        });
      }, error => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ''}`
        });
      });
    };
    this.commitTOTP = (args, headers, signal) => {
      return this.fetch(this.url('CommitTOTP'), createHTTPRequest(args, headers, signal)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            codes: _data.codes
          };
        });
      }, error => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ''}`
        });
      });
    };
    this.resetTOTP = (args, headers, signal) => {
      return this.fetch(this.url('ResetTOTP'), createHTTPRequest(args, headers, signal)).then(res => {
        return buildResponse(res).then(_data => {
          return {};
        });
      }, error => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ''}`
        });
      });
    };
    this.reset2FA = (args, headers, signal) => {
      return this.fetch(this.url('Reset2FA'), createHTTPRequest(args, headers, signal)).then(res => {
        return buildResponse(res).then(_data => {
          return {};
        });
      }, error => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ''}`
        });
      });
    };
    this.recoveryCodes = (args, headers, signal) => {
      return this.fetch(this.url('RecoveryCodes'), createHTTPRequest(args, headers, signal)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            codes: _data.codes
          };
        });
      }, error => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ''}`
        });
      });
    };
    this.resetRecoveryCodes = (args, headers, signal) => {
      return this.fetch(this.url('ResetRecoveryCodes'), createHTTPRequest(args, headers, signal)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            codes: _data.codes
          };
        });
      }, error => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ''}`
        });
      });
    };
    this.hostname = hostname;
    this.fetch = (input, init) => fetch(input, init);
  }
  url(name) {
    return this.hostname + this.path + name;
  }
}
const createHTTPRequest = (body = {}, headers = {}, signal = null) => {
  return {
    method: 'POST',
    headers: _extends({}, headers, {
      'Content-Type': 'application/json'
    }),
    body: JSON.stringify(body || {}),
    signal
  };
};
const buildResponse = res => {
  return res.text().then(text => {
    let data;
    try {
      data = JSON.parse(text);
    } catch (error) {
      let message = '';
      if (error instanceof Error) {
        message = error.message;
      }
      throw WebrpcBadResponseError.new({
        status: res.status,
        cause: `JSON.parse(): ${message}: response text: ${text}`
      });
    }
    if (!res.ok) {
      const code = typeof data.code === 'number' ? data.code : 0;
      throw (webrpcErrorByCode[code] || WebrpcError).new(data);
    }
    return data;
  });
};

//
// Errors
//

class WebrpcError extends Error {
  constructor(name, code, message, status, cause) {
    super(message);
    this.name = void 0;
    this.code = void 0;
    this.message = void 0;
    this.status = void 0;
    this.cause = void 0;
    /** @deprecated Use message instead of msg. Deprecated in webrpc v0.11.0. */
    this.msg = void 0;
    this.name = name || 'WebrpcError';
    this.code = typeof code === 'number' ? code : 0;
    this.message = message || `endpoint error ${this.code}`;
    this.msg = this.message;
    this.status = typeof status === 'number' ? status : 0;
    this.cause = cause;
    Object.setPrototypeOf(this, WebrpcError.prototype);
  }
  static new(payload) {
    return new this(payload.error, payload.code, payload.message || payload.msg, payload.status, payload.cause);
  }
}

// Webrpc errors

class WebrpcEndpointError extends WebrpcError {
  constructor(name = 'WebrpcEndpoint', code = 0, message = 'endpoint error', status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, WebrpcEndpointError.prototype);
  }
}
class WebrpcRequestFailedError extends WebrpcError {
  constructor(name = 'WebrpcRequestFailed', code = -1, message = 'request failed', status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, WebrpcRequestFailedError.prototype);
  }
}
class WebrpcBadRouteError extends WebrpcError {
  constructor(name = 'WebrpcBadRoute', code = -2, message = 'bad route', status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, WebrpcBadRouteError.prototype);
  }
}
class WebrpcBadMethodError extends WebrpcError {
  constructor(name = 'WebrpcBadMethod', code = -3, message = 'bad method', status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, WebrpcBadMethodError.prototype);
  }
}
class WebrpcBadRequestError extends WebrpcError {
  constructor(name = 'WebrpcBadRequest', code = -4, message = 'bad request', status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, WebrpcBadRequestError.prototype);
  }
}
class WebrpcBadResponseError extends WebrpcError {
  constructor(name = 'WebrpcBadResponse', code = -5, message = 'bad response', status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, WebrpcBadResponseError.prototype);
  }
}
class WebrpcServerPanicError extends WebrpcError {
  constructor(name = 'WebrpcServerPanic', code = -6, message = 'server panic', status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, WebrpcServerPanicError.prototype);
  }
}
class WebrpcInternalErrorError extends WebrpcError {
  constructor(name = 'WebrpcInternalError', code = -7, message = 'internal error', status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, WebrpcInternalErrorError.prototype);
  }
}
class WebrpcClientDisconnectedError extends WebrpcError {
  constructor(name = 'WebrpcClientDisconnected', code = -8, message = 'client disconnected', status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, WebrpcClientDisconnectedError.prototype);
  }
}
class WebrpcStreamLostError extends WebrpcError {
  constructor(name = 'WebrpcStreamLost', code = -9, message = 'stream lost', status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, WebrpcStreamLostError.prototype);
  }
}
class WebrpcStreamFinishedError extends WebrpcError {
  constructor(name = 'WebrpcStreamFinished', code = -10, message = 'stream finished', status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, WebrpcStreamFinishedError.prototype);
  }
}

// Schema errors

class UnauthorizedError extends WebrpcError {
  constructor(name = 'Unauthorized', code = 1000, message = 'Unauthorized access', status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, UnauthorizedError.prototype);
  }
}
class SessionExpiredError extends WebrpcError {
  constructor(name = 'SessionExpired', code = 1002, message = 'Session expired', status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, SessionExpiredError.prototype);
  }
}
class AbortedError extends WebrpcError {
  constructor(name = 'Aborted', code = 1005, message = 'Request aborted', status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, AbortedError.prototype);
  }
}
class InvalidArgumentError extends WebrpcError {
  constructor(name = 'InvalidArgument', code = 2001, message = 'Invalid argument', status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, InvalidArgumentError.prototype);
  }
}
class UnavailableError extends WebrpcError {
  constructor(name = 'Unavailable', code = 2002, message = 'Unavailable resource', status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, UnavailableError.prototype);
  }
}
class QueryFailedError extends WebrpcError {
  constructor(name = 'QueryFailed', code = 2003, message = 'Query failed', status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, QueryFailedError.prototype);
  }
}
class ValidationFailedError extends WebrpcError {
  constructor(name = 'ValidationFailed', code = 2004, message = 'Validation Failed', status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, ValidationFailedError.prototype);
  }
}
class NotFoundError extends WebrpcError {
  constructor(name = 'NotFound', code = 3000, message = 'Resource not found', status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, NotFoundError.prototype);
  }
}
const webrpcErrorByCode = {
  [0]: WebrpcEndpointError,
  [-1]: WebrpcRequestFailedError,
  [-2]: WebrpcBadRouteError,
  [-3]: WebrpcBadMethodError,
  [-4]: WebrpcBadRequestError,
  [-5]: WebrpcBadResponseError,
  [-6]: WebrpcServerPanicError,
  [-7]: WebrpcInternalErrorError,
  [-8]: WebrpcClientDisconnectedError,
  [-9]: WebrpcStreamLostError,
  [-10]: WebrpcStreamFinishedError,
  [1000]: UnauthorizedError,
  [1002]: SessionExpiredError,
  [1005]: AbortedError,
  [2001]: InvalidArgumentError,
  [2002]: UnavailableError,
  [2003]: QueryFailedError,
  [2004]: ValidationFailedError,
  [3000]: NotFoundError
};

const fetch = globalThis.fetch;
class GuardSigner {
  constructor(address, url, appendSuffix = false) {
    this.address = address;
    this.url = url;
    this.appendSuffix = appendSuffix;
    this.guard = void 0;
    this.guard = new Guard(url, fetch);
  }
  async getAddress() {
    return this.address;
  }
  async buildDeployTransaction(_metadata) {
    return undefined;
  }
  async predecorateSignedTransactions(_metadata) {
    return [];
  }
  async decorateTransactions(bundle, _metadata) {
    return bundle;
  }
  async sign(message, metadata) {
    var _metadata$parts;
    if (!commons.isWalletSignRequestMetadata(metadata)) {
      throw new Error('expected sequence signature request metadata');
    }
    const guardTotpCode = metadata.guardTotpCode;

    // Building auxData, notice: this uses the old v1 format
    // TODO: We should update the guard API so we can pass the metadata directly
    const coder = universal.genericCoderFor(metadata.config.version);
    const {
      encoded
    } = coder.signature.encodeSigners(metadata.config, (_metadata$parts = metadata.parts) != null ? _metadata$parts : new Map(), [], metadata.chainId);
    return (await this.guard.signWith({
      signer: this.address,
      request: {
        msg: ethers.hexlify(message),
        auxData: this.packMsgAndSig(metadata.address, metadata.digest, encoded, metadata.chainId),
        chainId: Number(metadata.chainId)
      },
      token: guardTotpCode ? {
        id: AuthMethod.TOTP,
        token: guardTotpCode
      } : undefined
    })).sig;
  }
  notifyStatusChange(_id, _status, _metadata) {}
  async getAuthMethods(proof) {
    let response;
    if ('jwt' in proof) {
      response = await this.guard.authMethods({}, {
        Authorization: `BEARER ${proof.jwt}`
      });
    } else {
      const signedProof = await signOwnershipProof(proof);
      response = await this.guard.authMethods({
        proof: {
          wallet: signedProof.walletAddress,
          timestamp: signedProof.timestamp.getTime(),
          signer: signedProof.signerAddress,
          signature: signedProof.signature
        }
      });
    }
    return _extends({}, response, {
      methods: response.methods.map(parseAuthMethod)
    });
  }
  async setPin(pin, proof) {
    const signedProof = await signAuthUpdateProof(proof);
    if (pin === undefined) {
      await this.guard.resetPIN({
        timestamp: signedProof.timestamp.getTime(),
        signature: signedProof.signature
      }, {
        Authorization: `BEARER ${proof.jwt}`
      });
    } else {
      await this.guard.setPIN({
        pin,
        timestamp: signedProof.timestamp.getTime(),
        signature: signedProof.signature
      }, {
        Authorization: `BEARER ${proof.jwt}`
      });
    }
  }
  resetPin(proof) {
    return this.setPin(undefined, proof);
  }
  async createTotp(proof) {
    const signedProof = await signAuthUpdateProof(proof);
    const {
      uri
    } = await this.guard.createTOTP({
      timestamp: signedProof.timestamp.getTime(),
      signature: signedProof.signature
    }, {
      Authorization: `BEARER ${proof.jwt}`
    });
    return new URL(uri);
  }
  async commitTotp(token, jwt) {
    const {
      codes
    } = await this.guard.commitTOTP({
      token
    }, {
      Authorization: `BEARER ${jwt}`
    });
    return codes;
  }
  async resetTotp(proof) {
    const signedProof = await signAuthUpdateProof(proof);
    await this.guard.resetTOTP({
      timestamp: signedProof.timestamp.getTime(),
      signature: signedProof.signature
    }, {
      Authorization: `BEARER ${proof.jwt}`
    });
  }
  async reset2fa(recoveryCode, proof) {
    if ('jwt' in proof) {
      await this.guard.reset2FA({
        code: recoveryCode
      }, {
        Authorization: `BEARER ${proof.jwt}`
      });
    } else {
      const signedProof = await signOwnershipProof(proof);
      await this.guard.reset2FA({
        code: recoveryCode,
        proof: {
          wallet: signedProof.walletAddress,
          timestamp: signedProof.timestamp.getTime(),
          signer: signedProof.signerAddress,
          signature: signedProof.signature
        }
      });
    }
  }
  async getRecoveryCodes(proof) {
    const signedProof = await signAuthUpdateProof(proof);
    const {
      codes
    } = await this.guard.recoveryCodes({
      timestamp: signedProof.timestamp.getTime(),
      signature: signedProof.signature
    }, {
      Authorization: `BEARER ${proof.jwt}`
    });
    return codes;
  }
  async resetRecoveryCodes(proof) {
    const signedProof = await signAuthUpdateProof(proof);
    const {
      codes
    } = await this.guard.resetRecoveryCodes({
      timestamp: signedProof.timestamp.getTime(),
      signature: signedProof.signature
    }, {
      Authorization: `BEARER ${proof.jwt}`
    });
    return codes;
  }
  packMsgAndSig(address, msg, sig, chainId) {
    return ethers.AbiCoder.defaultAbiCoder().encode(['address', 'uint256', 'bytes', 'bytes'], [address, chainId, msg, sig]);
  }
  suffix() {
    return new Uint8Array(this.appendSuffix ? [3] : []);
  }
}
let AuthMethod = /*#__PURE__*/function (AuthMethod) {
  AuthMethod["PIN"] = "PIN";
  AuthMethod["TOTP"] = "TOTP";
  return AuthMethod;
}({});
function parseAuthMethod(method) {
  switch (method) {
    case AuthMethod.PIN:
    case AuthMethod.TOTP:
      return method;
    default:
      throw new Error(`unknown auth method '${method}'`);
  }
}
function isSignedOwnershipProof(proof) {
  return 'signerAddress' in proof && typeof proof.signerAddress === 'string';
}
async function signOwnershipProof(proof) {
  if (isSignedOwnershipProof(proof)) {
    return proof;
  } else {
    const signer = signers.isSapientSigner(proof.signer) ? proof.signer : new signers.SignerWrapper(proof.signer);
    const signerAddress = await signer.getAddress();
    const timestamp = new Date();
    const typedData = getOwnershipProofTypedData(proof.walletAddress, timestamp);
    const digest = encodeTypedDataDigest(typedData);
    return {
      walletAddress: proof.walletAddress,
      timestamp,
      signerAddress,
      signature: ethers.hexlify(await signer.sign(digest, {}))
    };
  }
}
async function signAuthUpdateProof(proof) {
  if ('wallet' in proof) {
    var _typedData$domain$cha;
    const timestamp = new Date();
    const typedData = getAuthUpdateProofTypedData(timestamp);
    const signature = await proof.wallet.signTypedData(typedData.domain, typedData.types, typedData.message, (_typedData$domain$cha = typedData.domain.chainId) != null ? _typedData$domain$cha : 1, 'eip6492');
    return {
      jwt: proof.jwt,
      timestamp,
      signature
    };
  } else {
    return proof;
  }
}
function getOwnershipProofTypedData(wallet, timestamp) {
  return {
    domain,
    types: {
      AuthMethods: [{
        name: 'wallet',
        type: 'address'
      }, {
        name: 'timestamp',
        type: 'string'
      }]
    },
    message: {
      wallet: ethers.getAddress(wallet),
      timestamp: toUTCString(timestamp)
    }
  };
}
function getAuthUpdateProofTypedData(timestamp) {
  return {
    domain,
    types: {
      AuthUpdate: [{
        name: 'timestamp',
        type: 'string'
      }]
    },
    message: {
      timestamp: toUTCString(timestamp)
    }
  };
}
const domain = {
  name: 'Sequence Guard',
  version: '1',
  chainId: 1
};
function toUTCString(date) {
  return date.toUTCString().replace('GMT', 'UTC');
}

export { AuthMethod, Guard, GuardSigner, getAuthUpdateProofTypedData, getOwnershipProofTypedData, isSignedOwnershipProof, signOwnershipProof };
