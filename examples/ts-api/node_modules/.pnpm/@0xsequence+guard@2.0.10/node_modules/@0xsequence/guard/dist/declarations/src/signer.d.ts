import { Account } from '@0xsequence/account';
import { commons } from '@0xsequence/core';
import { signers, Status } from '@0xsequence/signhub';
import { TypedData } from '@0xsequence/utils';
import { ethers } from 'ethers';
import { RecoveryCode as GuardRecoveryCode } from "./guard.gen.js";
export declare class GuardSigner implements signers.SapientSigner {
    readonly address: string;
    readonly url: string;
    readonly appendSuffix: boolean;
    private guard;
    constructor(address: string, url: string, appendSuffix?: boolean);
    getAddress(): Promise<string>;
    buildDeployTransaction(_metadata: object): Promise<commons.transaction.TransactionBundle | undefined>;
    predecorateSignedTransactions(_metadata: object): Promise<commons.transaction.SignedTransactionBundle[]>;
    decorateTransactions(bundle: commons.transaction.IntendedTransactionBundle, _metadata: object): Promise<commons.transaction.IntendedTransactionBundle>;
    sign(message: ethers.BytesLike, metadata: object): Promise<ethers.BytesLike>;
    notifyStatusChange(_id: string, _status: Status, _metadata: object): void;
    getAuthMethods(proof: OwnershipProof): Promise<{
        methods: AuthMethod[];
        active: boolean;
    }>;
    setPin(pin: string | undefined, proof: AuthUpdateProof): Promise<void>;
    resetPin(proof: AuthUpdateProof): Promise<void>;
    createTotp(proof: AuthUpdateProof): Promise<URL>;
    commitTotp(token: string, jwt: string): Promise<RecoveryCode[]>;
    resetTotp(proof: AuthUpdateProof): Promise<void>;
    reset2fa(recoveryCode: string, proof: OwnershipProof): Promise<void>;
    getRecoveryCodes(proof: AuthUpdateProof): Promise<RecoveryCode[]>;
    resetRecoveryCodes(proof: AuthUpdateProof): Promise<RecoveryCode[]>;
    private packMsgAndSig;
    suffix(): ethers.BytesLike;
}
export type RecoveryCode = GuardRecoveryCode;
export declare enum AuthMethod {
    PIN = "PIN",
    TOTP = "TOTP"
}
export type SignedOwnershipProof = {
    walletAddress: string;
    timestamp: Date;
    signerAddress: string;
    signature: string;
};
export type OwnershipProof = SignedOwnershipProof | {
    jwt: string;
} | {
    walletAddress: string;
    signer: ethers.Signer | signers.SapientSigner;
};
export declare function isSignedOwnershipProof(proof: OwnershipProof): proof is SignedOwnershipProof;
export declare function signOwnershipProof(proof: Exclude<OwnershipProof, {
    jwt: string;
}>): Promise<SignedOwnershipProof>;
export type AuthUpdateProof = {
    jwt: string;
} & ({
    timestamp: Date;
    signature: string;
} | {
    wallet: Account;
});
export declare function getOwnershipProofTypedData(wallet: string, timestamp: Date): TypedData;
export declare function getAuthUpdateProofTypedData(timestamp: Date): TypedData;
