import { ethers } from 'ethers';
import { NetworkConfig, ChainIdLike } from '@0xsequence/network';
import { FeeQuote, Relayer } from '@0xsequence/relayer';
import { commons } from '@0xsequence/core';
export declare abstract class Signer extends ethers.AbstractSigner {
    static isSequenceSigner(cand: any): cand is Signer;
    abstract getProvider(chainId?: number): Promise<ethers.JsonRpcProvider | undefined>;
    abstract getRelayer(chainId?: number): Promise<Relayer | undefined>;
    abstract getWalletConfig(chainId?: ChainIdLike): Promise<commons.config.Config>;
    abstract getNetworks(): Promise<NetworkConfig[]>;
    abstract getSigners(): Promise<string[]>;
    abstract signMessage(message: ethers.BytesLike, chainId?: ChainIdLike, allSigners?: boolean, isDigest?: boolean): Promise<string>;
    abstract signTypedData(domain: ethers.TypedDataDomain, types: Record<string, Array<ethers.TypedDataField>>, message: Record<string, any>, chainId?: ChainIdLike, allSigners?: boolean): Promise<string>;
    abstract sendTransaction(transaction: commons.transaction.Transactionish, chainId?: ChainIdLike, allSigners?: boolean, quote?: FeeQuote): Promise<commons.transaction.TransactionResponse>;
    abstract sendTransactionBatch(transactions: ethers.TransactionRequest[] | commons.transaction.Transaction[], chainId?: ChainIdLike, allSigners?: boolean, quote?: FeeQuote): Promise<commons.transaction.TransactionResponse>;
    abstract signTransactions(txs: commons.transaction.Transactionish, chainId?: ChainIdLike, allSigners?: boolean): Promise<commons.transaction.SignedTransactionBundle>;
    abstract sendSignedTransactions(signedTxs: commons.transaction.SignedTransactionBundle, chainId?: ChainIdLike, quote?: FeeQuote): Promise<commons.transaction.TransactionResponse>;
    abstract updateConfig(newConfig?: commons.config.Config): Promise<[commons.config.Config, commons.transaction.TransactionResponse | undefined]>;
    abstract publishConfig(): Promise<commons.transaction.TransactionResponse | undefined>;
    abstract isDeployed(chainId?: ChainIdLike): Promise<boolean>;
}
export type SignedTransactionsCallback = (signedTxs: commons.transaction.SignedTransactionBundle, metaTxnHash: string) => void;
export declare function isSequenceSigner(signer: any): signer is Signer;
export declare class InvalidSigner extends Error {
}
export declare class NotEnoughSigners extends Error {
}
