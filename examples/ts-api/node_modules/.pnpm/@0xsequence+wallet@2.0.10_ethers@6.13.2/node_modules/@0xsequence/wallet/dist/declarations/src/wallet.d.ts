import { ethers } from 'ethers';
import { commons, v1, v2 } from '@0xsequence/core';
import { SignatureOrchestrator } from '@0xsequence/signhub';
import { FeeQuote, Relayer } from '@0xsequence/relayer';
export type WalletOptions<T extends commons.signature.Signature<Y>, Y extends commons.config.Config, Z extends commons.signature.UnrecoveredSignature> = {
    coders: {
        config: commons.config.ConfigCoder<Y>;
        signature: commons.signature.SignatureCoder<Y, T, Z>;
    };
    context: commons.context.WalletContext;
    config: Y;
    chainId: ethers.BigNumberish;
    address: string;
    orchestrator: SignatureOrchestrator;
    reader?: commons.reader.Reader;
    provider?: ethers.Provider;
    relayer?: Relayer;
};
export type WalletV2 = Wallet<v2.config.WalletConfig, v2.signature.Signature, v2.signature.UnrecoveredSignature>;
export type WalletV1 = Wallet<v1.config.WalletConfig, v1.signature.Signature, v1.signature.UnrecoveredSignature>;
/**
 * The wallet is the minimum interface to interact with a single Sequence wallet/contract.
 * it doesn't have any knowledge of any on-chain state, instead it relies solely on the information
 * provided by the user. This building block is used to create higher level abstractions.
 *
 * Wallet can also be used to create Sequence wallets, but it's not recommended to use it directly.
 */
export declare class Wallet<Y extends commons.config.Config = commons.config.Config, T extends commons.signature.Signature<Y> = commons.signature.Signature<Y>, Z extends commons.signature.UnrecoveredSignature = commons.signature.UnrecoveredSignature> extends ethers.AbstractSigner {
    context: commons.context.WalletContext;
    config: Y;
    address: string;
    chainId: ethers.BigNumberish;
    relayer?: Relayer;
    coders: {
        signature: commons.signature.SignatureCoder<Y, T, Z>;
        config: commons.config.ConfigCoder<Y>;
    };
    private orchestrator;
    private _reader?;
    constructor(options: WalletOptions<T, Y, Z>);
    static newWallet<Y extends commons.config.Config = commons.config.Config, T extends commons.signature.Signature<Y> = commons.signature.Signature<Y>, Z extends commons.signature.UnrecoveredSignature = commons.signature.UnrecoveredSignature>(options: Omit<WalletOptions<T, Y, Z>, 'address'>): Wallet<Y, T, Z>;
    reader(): commons.reader.Reader;
    setConfig(config: Y): void;
    setOrchestrator(orchestrator: SignatureOrchestrator): void;
    setAddress(address: string): void;
    getSigners(): Promise<string[]>;
    getAddress(): Promise<string>;
    decorateTransactions(bundle: commons.transaction.IntendedTransactionBundle): Promise<commons.transaction.IntendedTransactionBundle>;
    buildDeployTransaction(metadata?: commons.WalletDeployMetadata): Promise<commons.transaction.TransactionBundle | undefined>;
    deploy(metadata?: commons.WalletDeployMetadata): Promise<ethers.TransactionResponse | undefined>;
    static buildDeployTransaction(context: commons.context.WalletContext, imageHash: string): commons.transaction.TransactionBundle;
    buildUpdateConfigurationTransaction(config: Y): Promise<commons.transaction.TransactionBundle>;
    getNonce(space?: ethers.BigNumberish): Promise<number>;
    signDigest(digest: ethers.BytesLike, metadata?: object): Promise<string>;
    signMessage(message: ethers.BytesLike): Promise<string>;
    signTypedData(domain: ethers.TypedDataDomain, types: Record<string, ethers.TypedDataField[]>, value: Record<string, any>): Promise<string>;
    signTransactionBundle(bundle: commons.transaction.TransactionBundle): Promise<commons.transaction.SignedTransactionBundle>;
    fetchNonceOrSpace(nonce?: ethers.BigNumberish | {
        space: ethers.BigNumberish;
    } | {
        serial: boolean;
    }): Promise<ethers.BigNumberish>;
    randomNonce(): ethers.BigNumberish;
    signTransactions(txs: commons.transaction.Transactionish, nonce?: ethers.BigNumberish | {
        space: ethers.BigNumberish;
    } | {
        serial: boolean;
    }, metadata?: object): Promise<commons.transaction.SignedTransactionBundle>;
    sendSignedTransaction(signedBundle: commons.transaction.IntendedTransactionBundle, quote?: FeeQuote): Promise<ethers.TransactionResponse>;
    sendTransaction(txs: commons.transaction.Transactionish, options?: {
        quote?: FeeQuote;
        nonce?: ethers.BigNumberish;
        serial?: boolean;
    }): Promise<ethers.TransactionResponse>;
    fillGasLimits(txs: commons.transaction.Transactionish): Promise<commons.transaction.SimulatedTransaction[]>;
    connect(provider: ethers.Provider, relayer?: Relayer): Wallet<Y, T, Z>;
    signTransaction(transaction: ethers.TransactionRequest): Promise<string>;
}
