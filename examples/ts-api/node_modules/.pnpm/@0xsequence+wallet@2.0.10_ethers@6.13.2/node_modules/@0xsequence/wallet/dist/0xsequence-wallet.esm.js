import { ethers } from 'ethers';
import { commons } from '@0xsequence/core';
import { SignerState } from '@0xsequence/signhub';
import { subDigestOf, encodeTypedDataDigest } from '@0xsequence/utils';
import { walletContracts } from '@0xsequence/abi';

// TODO: Move to account ?
class Signer extends ethers.AbstractSigner {
  static isSequenceSigner(cand) {
    return isSequenceSigner(cand);
  }

  // abstract getWalletContext(): Promise<WalletContext>

  // abstract getWalletState(chainId?: ChainIdLike): Promise<WalletState[]>

  // getSigners returns a list of available / attached signers to the interface. Note: you need
  // enough signers in order to meet the signing threshold that satisfies a wallet config.

  // signMessage .....

  // signTypedData ..

  // sendTransaction takes an unsigned transaction, or list of unsigned transactions, and then has it signed by
  // the signer, and finally sends it to the relayer for submission to an Ethereum network.

  // sendTransactionBatch provides the ability to send an array/batch of transactions as a single native on-chain transaction.
  // This method works identically to sendTransaction but offers a different syntax for convience, readability and type clarity.

  // Low-level methods to sign and send/relayer signed transactions separately. The combination of these methods
  // is like calling just sendTransaction(..) above. Also note that sendSignedTransactions is identical
  // to calling getRelayer().relay(signedTxs), but included in this interface for convenience.

  // updateConfig will update the wallet image hash on-chain, aka deploying a smart wallet config to chain. If
  // newConfig argument is undefined, then it will use the existing config. Config contents will also be
  // automatically published to the authChain when updating the config image hash.

  // publishConfig will store the raw WalletConfig object on-chain, note: this may be expensive,
  // and is only necessary for config data-availability, in case of Account the contents are published
  // to the authChain.

  // isDeployed ..
}
function isSequenceSigner(signer) {
  const cand = signer;
  return cand && cand.updateConfig !== undefined && cand.publishConfig !== undefined && cand.getWalletConfig !== undefined;
}

// TODO: move to error.ts, along with others..
class InvalidSigner extends Error {}
class NotEnoughSigners extends Error {}

function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}

async function resolveArrayProperties(object) {
  if (Array.isArray(object)) {
    // T must include array type
    return Promise.all(object.map(o => ethers.resolveProperties(o)));
  }
  return ethers.resolveProperties(object);
}
async function findLatestLog(provider, filter) {
  const toBlock = filter.toBlock === 'latest' ? await provider.getBlockNumber() : filter.toBlock;
  const fromBlock = filter.fromBlock;
  try {
    const logs = await provider.getLogs(_extends({}, filter, {
      toBlock: toBlock
    }));
    return logs.length === 0 ? undefined : logs[logs.length - 1];
  } catch (e) {
    // TODO Don't assume all errors are bad
    const pivot = Math.floor((toBlock - fromBlock) / 2 + fromBlock);
    const nhalf = await findLatestLog(provider, _extends({}, filter, {
      fromBlock: pivot,
      toBlock: toBlock
    }));
    if (nhalf !== undefined) return nhalf;
    return findLatestLog(provider, _extends({}, filter, {
      fromBlock: fromBlock,
      toBlock: pivot
    }));
  }
}

const statusToSignatureParts = status => {
  const parts = new Map();
  for (const signer of Object.keys(status.signers)) {
    const value = status.signers[signer];
    if (value.state === SignerState.SIGNED) {
      const suffix = ethers.getBytes(value.suffix);
      const suffixed = ethers.solidityPacked(['bytes', 'bytes'], [value.signature, suffix]);
      parts.set(signer, {
        signature: suffixed,
        isDynamic: suffix.length !== 1 || suffix[0] !== 2
      });
    }
  }
  return parts;
};
/**
 * The wallet is the minimum interface to interact with a single Sequence wallet/contract.
 * it doesn't have any knowledge of any on-chain state, instead it relies solely on the information
 * provided by the user. This building block is used to create higher level abstractions.
 *
 * Wallet can also be used to create Sequence wallets, but it's not recommended to use it directly.
 */
class Wallet extends ethers.AbstractSigner {
  constructor(options) {
    var _options$provider;
    if (BigInt(options.chainId) === 0n && !options.coders.signature.supportsNoChainId) {
      throw new Error(`Sequence version ${options.config.version} doesn't support chainId 0`);
    }
    super((_options$provider = options.provider) != null ? _options$provider : null);
    this.context = void 0;
    this.config = void 0;
    this.address = void 0;
    this.chainId = void 0;
    this.relayer = void 0;
    this.coders = void 0;
    this.orchestrator = void 0;
    this._reader = void 0;
    this.context = options.context;
    this.config = options.config;
    this.orchestrator = options.orchestrator;
    this.coders = options.coders;
    this.address = options.address;
    this.chainId = options.chainId;
    this.relayer = options.relayer;
    this._reader = options.reader;
  }
  static newWallet(options) {
    const address = commons.context.addressOf(options.context, options.coders.config.imageHashOf(options.config));
    return new Wallet(_extends({}, options, {
      address
    }));
  }
  reader() {
    if (this._reader) return this._reader;
    if (!this.provider) throw new Error('Wallet status provider requires a provider');
    return new commons.reader.OnChainReader(this.provider);
  }
  setConfig(config) {
    this.config = config;
  }
  setOrchestrator(orchestrator) {
    this.orchestrator = orchestrator;
  }
  setAddress(address) {
    this.address = address;
  }
  getSigners() {
    return this.orchestrator.getSigners();
  }
  async getAddress() {
    return this.address;
  }
  async decorateTransactions(bundle) {
    // Allow children to decorate
    const decorated = await this.orchestrator.decorateTransactions(bundle);
    if (await this.reader().isDeployed(this.address)) {
      // Deployed - No decorating at this level
      return decorated;
    }
    const transactions = [{
      to: decorated.entrypoint,
      data: commons.transaction.encodeBundleExecData(decorated),
      revertOnError: true
    }];

    // Add deployment tx
    const deployTx = await this.buildDeployTransaction();
    if (deployTx) {
      transactions.unshift(...deployTx.transactions);
    }

    // TODO: If entrypoint is guestModule we can flatten the bundle
    // and avoid calling guestModule twice

    return {
      entrypoint: this.context.guestModule,
      chainId: this.chainId,
      intent: decorated.intent,
      transactions
    };
  }
  async buildDeployTransaction(metadata) {
    if (metadata != null && metadata.ignoreDeployed && (await this.reader().isDeployed(this.address))) {
      return;
    }
    const imageHash = this.coders.config.imageHashOf(this.config);
    if (commons.context.addressOf(this.context, imageHash) !== this.address) {
      throw new Error(`First address of config ${imageHash} doesn't match wallet address ${this.address}`);
    }
    const bundle = Wallet.buildDeployTransaction(this.context, imageHash);
    if (metadata != null && metadata.includeChildren) {
      const childBundle = await this.orchestrator.buildDeployTransaction(metadata);
      if (childBundle) {
        // Deploy children first
        bundle.transactions = childBundle.transactions.concat(bundle.transactions);
      }
    }
    return bundle;
  }
  async deploy(metadata) {
    const deployTx = await this.buildDeployTransaction(metadata);
    if (deployTx === undefined) {
      // Already deployed
      return;
    }
    if (!this.relayer) throw new Error('Wallet deploy requires a relayer');
    return this.relayer.relay(_extends({}, deployTx, {
      chainId: this.chainId,
      intent: {
        id: ethers.hexlify(ethers.randomBytes(32)),
        wallet: this.address
      }
    }));
  }
  static buildDeployTransaction(context, imageHash) {
    const factoryInterface = new ethers.Interface(walletContracts.factory.abi);
    return {
      entrypoint: context.guestModule,
      transactions: [{
        to: context.factory,
        data: factoryInterface.encodeFunctionData(factoryInterface.getFunction('deploy'), [context.mainModule, imageHash]),
        gasLimit: 100000,
        delegateCall: false,
        revertOnError: true,
        value: 0
      }]
    };
  }
  async buildUpdateConfigurationTransaction(config) {
    if (this.coders.config.update.isKindUsed) {
      const implementation = await this.reader().implementation(this.address);
      const isLaterUpdate = implementation && implementation === this.context.mainModuleUpgradable;
      return this.coders.config.update.buildTransaction(this.address, config, this.context, isLaterUpdate ? 'later' : 'first');
    }
    return this.coders.config.update.buildTransaction(this.address, config, this.context);
  }
  async getNonce(space = 0) {
    const nonce = await this.reader().nonce(this.address, space);
    if (nonce === undefined) throw new Error('Unable to determine nonce');
    return Number(nonce);
  }
  async signDigest(digest, metadata) {
    // The subdigest may be statically defined on the configuration
    // in that case we just encode the proof, no need to sign anything
    const subdigest = subDigestOf(this.address, this.chainId, digest);
    if (this.coders.config.hasSubdigest(this.config, subdigest)) {
      return this.coders.signature.encodeSigners(this.config, new Map(), [subdigest], this.chainId).encoded;
    }

    // We build the metadata object, this contains additional information
    // that may be needed to sign the digest (by the other signers, or by the guard)
    const childMetadata = _extends({}, metadata, {
      // Keep other metadata fields
      digest,
      chainId: this.chainId,
      address: this.address,
      config: this.config
    });

    // We ask the orchestrator to sign the digest, as soon as we have enough signature parts
    // to reach the threshold we returns true, that means the orchestrator will stop asking
    // and we can encode the final signature
    const subdigestBytes = ethers.getBytes(subdigest);
    const signature = await this.orchestrator.signMessage({
      candidates: this.coders.config.signersOf(this.config).map(s => s.address),
      message: subdigestBytes,
      metadata: childMetadata,
      callback: (status, onNewMetadata) => {
        const parts = statusToSignatureParts(status);
        const newMetadata = _extends({}, childMetadata, {
          parts
        });
        onNewMetadata(newMetadata);
        return this.coders.signature.hasEnoughSigningPower(this.config, parts);
      }
    });
    const parts = statusToSignatureParts(signature);
    return this.coders.signature.encodeSigners(this.config, parts, [], this.chainId).encoded;
  }
  signMessage(message) {
    return this.signDigest(ethers.keccak256(message), {
      message
    });
  }

  // XXX This method is not implemented in the original code but required by the AbstractSigner interface
  signTypedData(domain, types, value) {
    const digest = encodeTypedDataDigest({
      domain,
      types,
      message: value
    });
    return this.signDigest(digest);
  }
  signTransactionBundle(bundle) {
    if (bundle.entrypoint !== this.address) {
      throw new Error(`Invalid entrypoint: ${bundle.entrypoint} !== ${this.address}`);
    }
    return this.signTransactions(bundle.transactions, bundle.nonce);
  }
  async fetchNonceOrSpace(nonce) {
    let spaceValue;
    if (nonce && nonce.space !== undefined) {
      // specified nonce "space"
      spaceValue = BigInt(nonce.space);
    } else if (nonce === undefined) {
      // default is random, aka parallel
      return this.randomNonce();
    } else if (nonce && nonce.serial === true) {
      // next nonce determined from the chain
      spaceValue = 0;
    } else {
      // specific nonce is used
      return nonce;
    }
    const resultNonce = await this.reader().nonce(this.address, spaceValue);
    if (resultNonce === undefined) throw new Error('Unable to determine nonce');
    return commons.transaction.encodeNonce(spaceValue, resultNonce);
  }

  // Generate nonce with random space
  randomNonce() {
    const randomNonceSpace = BigInt(ethers.hexlify(ethers.randomBytes(12)));
    const randomNonce = commons.transaction.encodeNonce(randomNonceSpace, 0);
    return randomNonce;
  }
  async signTransactions(txs, nonce, metadata) {
    const transaction = await resolveArrayProperties(txs);
    const transactions = commons.transaction.fromTransactionish(this.address, transaction);

    // NOTICE: If the `transactions` list is empty, then we add a dummy transaction
    // otherwise the `TxExecuted` event will not be emitted, and we won't be able to
    // find the transaction hash
    if (transactions.length === 0) {
      transactions.push({
        to: this.address,
        data: '0x',
        value: 0,
        gasLimit: 0,
        delegateCall: false,
        revertOnError: true
      });
    }
    const defaultedNonce = await this.fetchNonceOrSpace(nonce);
    const digest = commons.transaction.digestOfTransactions(defaultedNonce, transactions);
    const meta = _extends({
      digest,
      transactions
    }, metadata);
    const signature = await this.signDigest(digest, meta);
    return {
      intent: {
        // Maybe is better if signDigest returns the subdigest directly
        id: subDigestOf(this.address, this.chainId, digest),
        wallet: this.address
      },
      chainId: this.chainId,
      transactions,
      entrypoint: this.address,
      nonce: defaultedNonce,
      signature
    };
  }
  async sendSignedTransaction(signedBundle, quote) {
    if (!this.relayer) throw new Error('Wallet sendTransaction requires a relayer');
    return this.relayer.relay(signedBundle, quote);
  }

  // sendTransaction will dispatch the transaction to the relayer for submission to the network.
  // This method is able to send transactions in serial or parallel (default). You can specify
  // a specific nonce, or let the wallet determine the next nonce on-chain (serial:true).
  //
  // By default, nonces are generated randomly and assigned so transactioned can be executed
  // in parallel. However, if you'd like to execute serially, pass { serial: true } as an option.
  async sendTransaction(txs, options) {
    let nonce;
    if ((options == null ? void 0 : options.nonce) !== undefined) {
      // specific nonce is used
      nonce = options.nonce;
    } else if (options != null && options.serial) {
      // next nonce on wallet is used and detected on-chain
      nonce = {
        serial: true
      };
    } else {
      // default is random, aka parallel
      nonce = this.randomNonce();
    }
    const signed = await this.signTransactions(txs, nonce);
    const decorated = await this.decorateTransactions(signed);
    return this.sendSignedTransaction(decorated, options == null ? void 0 : options.quote);
  }
  async fillGasLimits(txs) {
    const transaction = await resolveArrayProperties(txs);
    const transactions = commons.transaction.fromTransactionish(this.address, transaction);
    const relayer = this.relayer;
    if (!relayer) throw new Error('Wallet fillGasLimits requires a relayer');
    const simulations = await relayer.simulate(this.address, ...transactions);
    return transactions.map((tx, i) => {
      const gasLimit = tx.gasLimit ? Number(tx.gasLimit) : simulations[i].gasLimit;
      return _extends({}, tx, simulations[i], {
        gasLimit
      });
    });
  }
  connect(provider, relayer) {
    return new Wallet({
      // Sequence version configurator
      coders: this.coders,
      context: this.context,
      config: this.config,
      chainId: this.chainId,
      address: this.address,
      orchestrator: this.orchestrator,
      reader: this._reader,
      provider,
      relayer: relayer != null ? relayer : this.relayer
    });
  }
  signTransaction(transaction) {
    throw new Error('Method not implemented.');
  }
}

// Implements a wrapper for using Sequence wallets as nested signers
// in the signhub orchestrator. It only works for nested signatures.
class SequenceOrchestratorWrapper {
  constructor(wallet) {
    this.wallet = wallet;
  }
  async getAddress() {
    return this.wallet.address;
  }
  async buildDeployTransaction(metadata) {
    return this.wallet.buildDeployTransaction(metadata);
  }
  async predecorateSignedTransactions(_metadata) {
    // Wallets do not predecorate as they have no off chain knowledge
    return [];
  }
  async decorateTransactions(bundle, _metadata) {
    return this.wallet.decorateTransactions(bundle);
  }
  sign(message, metadata) {
    if (!commons.isWalletSignRequestMetadata(metadata)) {
      throw new Error('SequenceOrchestratorWrapper only supports nested Sequence signatures');
    }

    // For Sequence nested signatures we must use `signDigest` and not `signMessage`
    // otherwise the wallet will hash the digest and the signature will be invalid.
    return this.wallet.signDigest(message, {
      nested: metadata
    });
  }
  notifyStatusChange(_i, _s, _m) {}
  suffix() {
    return new Uint8Array([3]);
  }
}

export { InvalidSigner, NotEnoughSigners, SequenceOrchestratorWrapper, Signer, Wallet, findLatestLog, isSequenceSigner, resolveArrayProperties };
