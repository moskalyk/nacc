import { ethers } from 'ethers';
import { walletContracts } from '@0xsequence/abi';
import { commons } from '@0xsequence/core';

function useGateway(uri, gateway) {
  const clean = uri.replace('ipfs://ipfs/', '').replace('ipfs://', '');
  if (uri.startsWith('ipfs://')) return `${gateway}${clean}`;
  return uri;
}
function isIPFS(uri) {
  return uri.startsWith('ipfs://');
}

class CachedEIP5719 {
  constructor(provider, solver, window = 1000) {
    this.provider = provider;
    this.solver = solver;
    this.window = window;
    this.pending = new Map();
  }
  async runByEIP5719(address, digest, signature) {
    const key = `${address}-${digest}-${signature}`;
    const now = Date.now();
    if (this.pending.has(key) && now - this.pending.get(key).timestamp < this.window) {
      return this.pending.get(key).promise;
    }
    const promise = runByEIP5719(address, this.provider, digest, signature, this.solver);
    this.pending.set(key, {
      timestamp: now,
      promise
    });
    return promise;
  }
}

function eip5719Contract(address, provider) {
  // TODO: for some reason walletContracts is not being loaded from local
  // remove this code once fixed
  const abi = [{
    inputs: [{
      internalType: 'bytes32',
      type: 'bytes32'
    }],
    name: 'getAlternativeSignature',
    outputs: [{
      internalType: 'string',
      type: 'string'
    }],
    stateMutability: 'view',
    type: 'function'
  }];
  return new ethers.Contract(address, abi, provider);
}
function eip1271Contract(address, provider) {
  return new ethers.Contract(address, walletContracts.erc1271.abi, provider);
}
async function isValidSignature(address, provider, digest, signature) {
  // First we try to validate the signature using Ethers
  try {
    const addr = ethers.recoverAddress(digest, ethers.hexlify(signature));
    if (addr.toLowerCase() === address.toLowerCase()) return true;
  } catch (_unused) {}

  // Then we try to validate the signature using EIP1271
  try {
    const contract = eip1271Contract(address, provider);
    const value = await contract.isValidSignature(digest, signature);
    if (value === walletContracts.erc1271.returns) return true;
  } catch (_unused2) {}

  // If all else fails, we return false
  return false;
}
async function tryAwait(promise) {
  try {
    return await promise;
  } catch (_unused3) {
    return undefined;
  }
}
async function runByEIP5719(address, provider, digest, signature, solver, tries = 0) {
  if (tries > 10) throw new Error('EIP5719 - Too many tries');
  if (commons.signer.canRecover(signature)) {
    const recoveredAddr = commons.signer.recoverSigner(digest, signature);
    if (recoveredAddr && recoveredAddr.toLowerCase() === address.toLowerCase()) return signature;
  }
  try {
    if (await commons.signer.isValidSignature(address, digest, signature, provider)) {
      return signature;
    }
  } catch (_unused4) {}
  const altUri = await tryAwait(eip5719Contract(address, provider).getAlternativeSignature(digest));
  if (!altUri || altUri === '') throw new Error('EIP5719 - Invalid signature and no alternative signature');
  const altSignature = ethers.hexlify(await (solver || new URISolverIPFS()).resolve(altUri));
  if (!altSignature || altSignature === '') throw new Error('EIP5719 - Empty alternative signature');
  if (altSignature === ethers.hexlify(signature)) {
    throw new Error('EIP5719 - Alternative signature is invalid or the same');
  }
  return runByEIP5719(address, provider, digest, altSignature, solver, tries + 1);
}
class URISolverIPFS {
  constructor(gateway = 'https://cloudflare-ipfs.com/ipfs/') {
    var _this = this;
    this.gateway = gateway;
    this.uri = uri => {
      if (isIPFS(uri)) return useGateway(uri, this.gateway);
      return uri;
    };
    this.resolve = async function (uri) {
      const url = _this.uri(uri);
      const res = await fetch(url);
      if (!res.ok) throw new Error(`URISolverIPFS - Failed to fetch ${url}`);
      return await res.text();
    };
  }
}

export { CachedEIP5719, URISolverIPFS, eip1271Contract, eip5719Contract, isValidSignature, runByEIP5719 };
