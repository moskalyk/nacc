import { Base64 } from 'js-base64';
import { ethers } from 'ethers';

const extractProjectIdFromAccessKey = accessKey => {
  // Convert URL-safe base64 string to standard base64 string
  const base64String = accessKey.replace(/-/g, '+').replace(/_/g, '/');
  // Decode the base64 string to a binary string
  const binaryString = atob(base64String);

  // Convert the binary string to a byte array (Uint8Array)
  const byteArray = new Uint8Array(binaryString.length);
  for (let i = 0; i < binaryString.length; i++) {
    byteArray[i] = binaryString.charCodeAt(i);
  }
  if (byteArray[0] !== 1) {
    throw new Error('UnsupportedVersion');
  }

  // Extract the project ID from bytes 2 to 9 (8 bytes)
  const projectIdBytes = byteArray.slice(1, 9);
  const projectId = projectIdBytes[7] | projectIdBytes[6] << 8 | projectIdBytes[5] << 16 | projectIdBytes[4] << 24 | projectIdBytes[3] << 32 | projectIdBytes[2] << 40 | projectIdBytes[1] << 48 | projectIdBytes[0] << 56;
  return projectId;
};

const MAX_UINT_256 = BigInt('0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff');

// ethers implement this method but doesn't exports it
const isBigNumberish = value => {
  return value != null && (typeof value === 'number' && value % 1 === 0 || typeof value === 'string' && !!value.match(/^-?[0-9]+$/) || ethers.isHexString(value) || typeof value === 'bigint');
};

// Even length zero-padded hex string with 0x prefix
const toHexString = value => {
  const result = value.toString(16);
  return `${result.length % 2 === 0 ? '0x' : '0x0'}${result}`;
};
const parseUnits = (value, decimals = 18) => {
  let [integer, fraction = '0'] = value.split('.');
  const negative = integer.startsWith('-');
  if (negative) {
    integer = integer.slice(1);
  }

  // trim trailing zeros.
  fraction = fraction.replace(/(0+)$/, '');

  // round off if the fraction is larger than the number of decimals.
  if (decimals === 0) {
    integer = `${Math.round(Number(`${integer}.${fraction}`))}`;
    fraction = '';
  } else if (fraction.length > decimals) {
    const [left, unit, right] = [fraction.slice(0, decimals - 1), fraction.slice(decimals - 1, decimals), fraction.slice(decimals)];
    const rounded = Math.round(Number(`${unit}.${right}`));
    if (rounded > 9) {
      fraction = `${BigInt(left) + 1n}0`.padStart(left.length + 1, '0');
    } else {
      fraction = `${left}${rounded}`;
    }
    if (fraction.length > decimals) {
      fraction = fraction.slice(1);
      integer = `${BigInt(integer) + 1n}`;
    }
    fraction = fraction.slice(0, decimals);
  } else {
    fraction = fraction.padEnd(decimals, '0');
  }
  return BigInt(`${negative ? '-' : ''}${integer}${fraction}`);
};
const parseEther = value => parseUnits(value, 18);
const formatUnits = (value, decimals = 18) => {
  let display = value.toString();
  const negative = display.startsWith('-');
  if (negative) {
    display = display.slice(1);
  }
  display = display.padStart(decimals, '0');
  const integer = display.slice(0, display.length - decimals);
  let fraction = display.slice(display.length - decimals);
  fraction = fraction.replace(/(0+)$/, '');
  return `${negative ? '-' : ''}${integer || '0'}${fraction ? `.${fraction}` : ''}`;
};
const formatEther = value => formatUnits(value, 18);

// JSON.stringify doesn't handle BigInts, so we need to replace them with objects
const bigintReplacer = (key, value) => {
  if (typeof value === 'bigint') {
    return {
      $bigint: value.toString()
    };
  }
  return value;
};

// JSON.parse will need to convert our serialized bigints back into BigInt
const bigintReviver = (key, value) => {
  if (value !== null && typeof value === 'object' && '$bigint' in value && typeof value.$bigint === 'string') {
    return BigInt(value.$bigint);
  }

  // BigNumber compatibility with older versions of sequence.js with ethers v5
  if (value !== null && typeof value === 'object' && value.type === 'BigNumber' && ethers.isHexString(value.hex)) {
    return BigInt(value.hex);
  }
  return value;
};

const base64Encode = val => {
  return Base64.encode(val, true);
};
const base64EncodeObject = obj => {
  return Base64.encode(JSON.stringify(obj, bigintReplacer), true);
};
const base64Decode = encodedString => {
  if (encodedString === null || encodedString === undefined) {
    return undefined;
  }
  return Base64.decode(encodedString);
};
const base64DecodeObject = encodedObject => {
  if (encodedObject === null || encodedObject === undefined) {
    return undefined;
  }
  return JSON.parse(Base64.decode(encodedObject), bigintReviver);
};

const encodeMessageDigest = message => {
  if (typeof message === 'string') {
    return ethers.getBytes(ethers.id(message));
  } else {
    return ethers.getBytes(ethers.keccak256(message));
  }
};

// packMessageData encodes the specified data ready for the Sequence Wallet contracts.
const packMessageData = (walletAddress, chainId, digest) => {
  return ethers.solidityPacked(['string', 'uint256', 'address', 'bytes32'], ['\x19\x01', chainId, walletAddress, digest]);
};
const subDigestOf = (address, chainId, digest) => {
  return ethers.keccak256(packMessageData(address, chainId, digest));
};

const isNode = () => {
  if (typeof window === 'undefined' && typeof process === 'object') {
    return true;
  } else {
    return false;
  }
};
const isBrowser = () => !isNode();

const jwtDecodeClaims = jwt => {
  const parts = jwt.split('.');
  if (parts.length !== 3) {
    throw new Error('invalid jwt');
  }
  const claims = JSON.parse(Base64.decode(parts[1]));
  return claims;
};

function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}

var logLevel = /*#__PURE__*/function (logLevel) {
  logLevel[logLevel["DEBUG"] = 1] = "DEBUG";
  logLevel[logLevel["INFO"] = 2] = "INFO";
  logLevel[logLevel["WARN"] = 3] = "WARN";
  logLevel[logLevel["ERROR"] = 4] = "ERROR";
  logLevel[logLevel["DISABLED"] = 5] = "DISABLED";
  return logLevel;
}(logLevel || {});
class Logger {
  constructor(config) {
    this.config = config;
    this.logLevel = void 0;
    this.configure(config);
  }
  configure(config) {
    this.config = _extends({}, this.config, config);
    switch (this.config.logLevel) {
      case 'DEBUG':
        this.logLevel = logLevel.DEBUG;
        break;
      case 'INFO':
        this.logLevel = logLevel.INFO;
        break;
      case 'WARN':
        this.logLevel = logLevel.WARN;
        break;
      case 'ERROR':
        this.logLevel = logLevel.ERROR;
        break;
      case 'DISABLED':
        this.logLevel = logLevel.DISABLED;
        break;
      default:
        this.logLevel = logLevel.INFO;
        break;
    }

    // undefined silence value will disable the default silence flag
    if (this.config.silence === undefined) {
      this.config.silence = false;
    }
  }
  debug(message, ...optionalParams) {
    if (this.config.silence === true) return;
    if (this.logLevel === logLevel.DEBUG) {
      console.log(message, ...optionalParams);
    }
  }
  info(message, ...optionalParams) {
    if (this.config.silence === true) return;
    if (this.logLevel <= logLevel.INFO) {
      console.log(message, ...optionalParams);
    }
  }
  warn(message, ...optionalParams) {
    if (this.config.silence === true) return;
    if (this.logLevel <= logLevel.WARN) {
      console.warn(message, ...optionalParams);
      if (this.config.onwarn) {
        this.config.onwarn(message, optionalParams);
      }
    }
  }
  error(message, ...optionalParams) {
    if (this.config.silence === true) return;
    if (this.logLevel <= logLevel.ERROR) {
      console.error(message, ...optionalParams);
      if (this.config.onerror) {
        this.config.onerror(message, optionalParams);
      }
    }
  }
}
const logger = new Logger({
  logLevel: 'INFO',
  // By default we silence the logger. In tests we should call `configureLogger`
  // below to set silence: false.
  silence: true
});
const configureLogger = config => logger.configure(config);

class Base {
  static bufferIndexOf(array, element, isSorted = false) {
    if (isSorted) {
      return Base.binarySearch(array, element, Base.compare);
    }
    const eqChecker = (buffer1, buffer2) => {
      if (buffer1 === buffer2) {
        return true;
      }
      if (buffer1.length !== buffer2.length) {
        return false;
      }
      for (let i = 0; i < buffer1.length; i++) {
        if (buffer1[i] !== buffer2[i]) {
          return false;
        }
      }
      return true;
    };
    return Base.linearSearch(array, element, eqChecker);
  }
  static binarySearch(array, element, compareFunction) {
    let start = 0;
    let end = array.length - 1;

    // Iterate while start not meets end
    while (start <= end) {
      // Find the mid index
      const mid = Math.floor((start + end) / 2);

      // Check if the mid value is greater than, equal to, or less than search element.
      const ordering = compareFunction(array[mid], element);

      // If element is present at mid, start iterating for searching first appearance.
      if (ordering === 0) {
        // Linear reverse iteration until the first matching item index is found.
        for (let i = mid - 1; i >= 0; i--) {
          if (compareFunction(array[i], element) === 0) continue;
          return i + 1;
        }
        return 0;
      } /* Else look in left or right half accordingly */else if (ordering < 0) {
        start = mid + 1;
      } else {
        end = mid - 1;
      }
    }
    return -1;
  }
  static compare(a, b) {
    // Determine the minimum length to compare
    const len = Math.min(a.length, b.length);

    // Compare byte by byte
    for (let i = 0; i < len; i++) {
      if (a[i] !== b[i]) {
        return a[i] - b[i];
      }
    }

    // If all compared bytes are equal, compare lengths
    return a.length - b.length;
  }
  static linearSearch(array, element, eqChecker) {
    for (let i = 0; i < array.length; i++) {
      if (eqChecker(array[i], element)) {
        return i;
      }
    }
    return -1;
  }
  static bufferify(value) {
    if (typeof value === 'string') {
      return ethers.getBytes(value);
    }
    return value;
  }
  static isHexString(v) {
    return typeof v === 'string' && /^(0x)?[0-9A-Fa-f]*$/.test(v);
  }
  static bufferToHex(value, withPrefix = true) {
    const prefixed = ethers.hexlify(value);
    return withPrefix ? prefixed : prefixed.substring(2);
  }
  static bufferifyFn(f) {
    return value => {
      return Base.bufferify(f(value));
    };
  }
}

class MerkleTree extends Base {
  constructor(leaves, options = {}) {
    super();
    this.hashFn = void 0;
    this.leaves = [];
    this.layers = [];
    this.sortLeaves = false;
    this.sortPairs = false;
    this.sortLeaves = !!options.sortLeaves;
    this.sortPairs = !!options.sortPairs;
    this.hashFn = Base.bufferifyFn(ethers.keccak256);
    this.processLeaves(leaves);
  }
  getOptions() {
    return {
      sortLeaves: this.sortLeaves,
      sortPairs: this.sortPairs
    };
  }
  processLeaves(leaves) {
    this.leaves = leaves.map(Base.bufferify);
    if (this.sortLeaves) {
      this.leaves = this.leaves.sort(Base.compare);
    }
    this.createHashes(this.leaves);
  }
  createHashes(nodes) {
    this.layers = [nodes];
    while (nodes.length > 1) {
      const layerIndex = this.layers.length;
      this.layers.push([]);
      const layerLimit = nodes.length;
      for (let i = 0; i < nodes.length; i += 2) {
        if (i >= layerLimit) {
          this.layers[layerIndex].push(...nodes.slice(layerLimit));
          break;
        } else if (i + 1 === nodes.length) {
          if (nodes.length % 2 === 1) {
            // push copy of hash and continue iteration
            this.layers[layerIndex].push(nodes[i]);
            continue;
          }
        }
        const left = nodes[i];
        const right = i + 1 === nodes.length ? left : nodes[i + 1];
        const combined = [left, right];
        if (this.sortPairs) {
          combined.sort(Base.compare);
        }
        const hash = this.hashFn(ethers.concat(combined));
        this.layers[layerIndex].push(hash);
      }
      nodes = this.layers[layerIndex];
    }
  }
  getRoot() {
    if (this.layers.length === 0) {
      return Uint8Array.from([]);
    }
    return this.layers[this.layers.length - 1][0] || Uint8Array.from([]);
  }
  getHexRoot() {
    return Base.bufferToHex(this.getRoot());
  }
  getProof(leaf, index) {
    if (typeof leaf === 'undefined') {
      throw new Error('leaf is required');
    }
    leaf = Base.bufferify(leaf);
    const proof = [];
    if (!Number.isInteger(index)) {
      index = -1;
      for (let i = 0; i < this.leaves.length; i++) {
        if (Base.compare(leaf, this.leaves[i]) === 0) {
          index = i;
        }
      }
    }

    // Type fix
    index = index;
    if (index <= -1) {
      return [];
    }
    for (let i = 0; i < this.layers.length; i++) {
      const layer = this.layers[i];
      const isRightNode = index % 2;
      const pairIndex = isRightNode ? index - 1 : index + 1;
      if (pairIndex < layer.length) {
        proof.push({
          position: isRightNode ? 'left' : 'right',
          data: layer[pairIndex]
        });
      }

      // set index to parent index
      index = index / 2 | 0;
    }
    return proof;
  }
  getHexProof(leaf, index) {
    return this.getProof(leaf, index).map(item => Base.bufferToHex(item.data));
  }
  verify(proof, targetNode, root) {
    let hash = Base.bufferify(targetNode);
    root = Base.bufferify(root);
    if (!Array.isArray(proof) || !targetNode || !root) {
      return false;
    }
    for (let i = 0; i < proof.length; i++) {
      const node = proof[i];
      let data;
      let isLeftNode;
      if (typeof node === 'string') {
        data = Base.bufferify(node);
        isLeftNode = true;
      } else if (node instanceof Object) {
        data = node.data;
        isLeftNode = node.position === 'left';
      } else {
        throw new Error('Expected node to be of type string or object');
      }
      const buffers = [];
      if (this.sortPairs) {
        if (Base.compare(hash, data) < 0) {
          buffers.push(hash, data);
        } else {
          buffers.push(data, hash);
        }
        hash = this.hashFn(ethers.concat(buffers));
      } else {
        buffers.push(hash);
        buffers[isLeftNode ? 'unshift' : 'push'](data);
        hash = this.hashFn(ethers.concat(buffers));
      }
    }
    return Base.compare(hash, root) === 0;
  }
}

class MerkleTreeGenerator {
  constructor(elements, toLeaf) {
    this.elements = void 0;
    this.toLeaf = void 0;
    this.tree = void 0;
    this.elements = elements;
    this.toLeaf = toLeaf;
  }
  generateTree() {
    const hashed = this.elements.map(e => this.toLeaf(e));
    return new MerkleTree(hashed, {
      sortPairs: true,
      sortLeaves: true
    });
  }
  generateRoot() {
    if (!this.tree) this.tree = this.generateTree();
    return this.tree.getHexRoot();
  }
  generateProof(element) {
    if (!this.elements.includes(element)) throw new Error('Element not found');
    if (!this.tree) this.tree = this.generateTree();
    return this.tree.getHexProof(this.toLeaf(element));
  }
  verifyProof(element, proof) {
    if (!this.elements.includes(element)) throw new Error('Element not found');
    if (!this.tree) this.tree = this.generateTree();
    return this.tree.verify(proof, this.toLeaf(element), this.generateRoot());
  }
}
const getSaleItemsLeaf = element => ethers.solidityPackedKeccak256(['address', 'uint256'], [element.address.toLowerCase(), element.tokenId]);

// export const getEthersConnectionInfo = (url: string, projectAccessKey?: string, jwt?: string): ConnectionInfo => {
//   const headers: {
//     [key: string]: string | number
//   } = {}

//   if (jwt && jwt.length > 0) {
//     headers['Authorization'] = `BEARER ${jwt}`
//   }
//   if (projectAccessKey && projectAccessKey.length > 0) {
//     headers['X-Access-Key'] = projectAccessKey
//   }

//   return {
//     url,
//     headers,
//     skipFetchSetup: true,
//     fetchOptions: {
//       mode: 'cors',
//       cache: 'force-cache',
//       credentials: 'same-origin',
//       redirect: 'follow',
//       referrer: 'client'
//     }
//   }
// }

const getFetchRequest = (url, projectAccessKey, jwt) => {
  const req = new ethers.FetchRequest(url);
  if (jwt) {
    req.setHeader('Authorization', `BEARER ${jwt}`);
  }
  if (projectAccessKey) {
    req.setHeader('X-Access-Key', projectAccessKey);
  }
  return req;
};

class PromiseCache {
  constructor() {
    this.cache = void 0;
    this.cache = new Map();
  }
  do(key, validMilliseconds, task, ...args) {
    key = `${key}:${ethers.id(JSON.stringify(args, deterministically))}`;
    let entry = this.cache.get(key);
    if (entry) {
      if (entry.expiration) {
        if (new Date() >= entry.expiration) {
          entry = undefined;
          this.cache.delete(key);
        }
      }
    }
    if (!entry) {
      const entry_ = {
        promise: task(...args)
      };
      if (validMilliseconds !== undefined) {
        entry_.promise = entry_.promise.then(result => {
          entry_.expiration = new Date(Date.now() + validMilliseconds);
          return result;
        });
      }
      entry = entry_;
      this.cache.set(key, entry);
    }
    return entry.promise;
  }
}
function deterministically(_key, value) {
  if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
    return Object.fromEntries(Object.entries(value).sort());
  }
  return value;
}

function promisify(f, thisContext) {
  return function (...a) {
    const args = Array.prototype.slice.call(a);
    return new Promise(async (resolve, reject) => {
      try {
        args.push((err, result) => err ? reject(err) : resolve(result));
        await f.apply(thisContext, args);
      } catch (e) {
        reject(e);
      }
    });
  };
}

function queryStringFromObject(name, obj) {
  const k = encodeURIComponent(name);
  const v = encodeURIComponent(JSON.stringify(obj));
  return `${k}=${v}`;
}
function queryStringToObject(qs) {
  const p = qs.split('&');
  const o = {};
  for (const v of p) {
    const z = v.split('=');
    o[decodeURIComponent(z[0])] = JSON.parse(decodeURIComponent(z[1]));
  }
  return o;
}

const getRandomInt = (min = 0, max = Number.MAX_SAFE_INTEGER) => {
  min = Math.ceil(min);
  max = Math.floor(max);
  return Math.floor(Math.random() * (max - min + 1)) + min;
};

// sanitizeNumberString accepts a number string and returns back a clean number string.
// For example, input '1234.5678' will return '1234.5678' but '12javascript:{}etc' will return '12'
const sanitizeNumberString = numString => {
  if (!numString || typeof numString !== 'string') {
    return '';
  }
  const v = numString.match(/[\d.]+/);
  return v && v.length > 0 ? v[0].trim() : '';
};

// sanitizeAlphanumeric accepts any string and returns alphanumeric contents only
const sanitizeAlphanumeric = alphanum => {
  if (!alphanum || typeof alphanum !== 'string') {
    return '';
  }
  const v = alphanum.match(/[\w\s\d]+/);
  return v && v.length > 0 ? v[0].trim() : '';
};

// sanitizeHost accepts any string and returns valid host string
const sanitizeHost = host => {
  if (!host || typeof host !== 'string') {
    return '';
  }
  const v = host.match(/[\w\d.\-:\/]+/);
  return v && v.length > 0 ? v[0].trim() : '';
};

const sleep = t => {
  return new Promise(resolve => {
    const timeout = setTimeout(() => {
      clearTimeout(timeout);
      resolve();
    }, t);
  });
};

const encodeTypedDataHash = typedData => {
  const types = _extends({}, typedData.types);

  // remove EIP712Domain key from types as ethers will auto-gen it in
  // the hash encoder below
  delete types['EIP712Domain'];
  return ethers.TypedDataEncoder.hash(typedData.domain, types, typedData.message);
};
const encodeTypedDataDigest = typedData => {
  return ethers.getBytes(encodeTypedDataHash(typedData));
};

const {
  defineProperties,
  resolveProperties
} = ethers;

// urlClean removes double slashes from url path
const urlClean = url => url.replace(/([^:]\/)\/+/g, '$1');

export { Logger, MAX_UINT_256, MerkleTreeGenerator, PromiseCache, base64Decode, base64DecodeObject, base64Encode, base64EncodeObject, bigintReplacer, bigintReviver, configureLogger, defineProperties, encodeMessageDigest, encodeTypedDataDigest, encodeTypedDataHash, extractProjectIdFromAccessKey, formatEther, formatUnits, getFetchRequest, getRandomInt, getSaleItemsLeaf, isBigNumberish, isBrowser, isNode, jwtDecodeClaims, logger, packMessageData, parseEther, parseUnits, promisify, queryStringFromObject, queryStringToObject, resolveProperties, sanitizeAlphanumeric, sanitizeHost, sanitizeNumberString, sleep, subDigestOf, toHexString, urlClean };
