function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}

/* eslint-disable */
// sequence-indexer v0.4.0 9accea267e7db3d66f40d5e0f27db92eb5a29e2f
// --
// Code generated by webrpc-gen@v0.18.6 with typescript generator. DO NOT EDIT.
//
// webrpc-gen -schema=indexer.ridl -target=typescript -client -out=./clients/indexer.gen.ts

// WebRPC description and code-gen version
const WebRPCVersion = 'v1';

// Schema version of your RIDL schema
const WebRPCSchemaVersion = 'v0.4.0';

// Schema hash generated from your RIDL schema
const WebRPCSchemaHash = '9accea267e7db3d66f40d5e0f27db92eb5a29e2f';

//
// Types
//

let ContractType = /*#__PURE__*/function (ContractType) {
  ContractType["UNKNOWN"] = "UNKNOWN";
  ContractType["NATIVE"] = "NATIVE";
  ContractType["ERC20"] = "ERC20";
  ContractType["ERC721"] = "ERC721";
  ContractType["ERC1155"] = "ERC1155";
  ContractType["SEQUENCE_WALLET"] = "SEQUENCE_WALLET";
  ContractType["ERC20_BRIDGE"] = "ERC20_BRIDGE";
  ContractType["ERC721_BRIDGE"] = "ERC721_BRIDGE";
  ContractType["ERC1155_BRIDGE"] = "ERC1155_BRIDGE";
  ContractType["SEQ_MARKETPLACE"] = "SEQ_MARKETPLACE";
  return ContractType;
}({});
let EventLogType = /*#__PURE__*/function (EventLogType) {
  EventLogType["UNKNOWN"] = "UNKNOWN";
  EventLogType["BLOCK_ADDED"] = "BLOCK_ADDED";
  EventLogType["BLOCK_REMOVED"] = "BLOCK_REMOVED";
  return EventLogType;
}({});
let EventLogDataType = /*#__PURE__*/function (EventLogDataType) {
  EventLogDataType["EVENT"] = "EVENT";
  EventLogDataType["TOKEN_TRANSFER"] = "TOKEN_TRANSFER";
  EventLogDataType["NATIVE_TOKEN_TRANSFER"] = "NATIVE_TOKEN_TRANSFER";
  EventLogDataType["SEQUENCE_TXN"] = "SEQUENCE_TXN";
  return EventLogDataType;
}({});
let OrderStatus = /*#__PURE__*/function (OrderStatus) {
  OrderStatus["OPEN"] = "OPEN";
  OrderStatus["CLOSED"] = "CLOSED";
  OrderStatus["CANCELLED"] = "CANCELLED";
  return OrderStatus;
}({});
let TxnTransferType = /*#__PURE__*/function (TxnTransferType) {
  TxnTransferType["UNKNOWN"] = "UNKNOWN";
  TxnTransferType["SEND"] = "SEND";
  TxnTransferType["RECEIVE"] = "RECEIVE";
  return TxnTransferType;
}({});
let TransactionStatus = /*#__PURE__*/function (TransactionStatus) {
  TransactionStatus["FAILED"] = "FAILED";
  TransactionStatus["SUCCESSFUL"] = "SUCCESSFUL";
  return TransactionStatus;
}({});
let TransactionType = /*#__PURE__*/function (TransactionType) {
  TransactionType["LegacyTxnType"] = "LegacyTxnType";
  TransactionType["AccessListTxnType"] = "AccessListTxnType";
  TransactionType["DynamicFeeTxnType"] = "DynamicFeeTxnType";
  return TransactionType;
}({});
let SortOrder = /*#__PURE__*/function (SortOrder) {
  SortOrder["DESC"] = "DESC";
  SortOrder["ASC"] = "ASC";
  return SortOrder;
}({});
//
// Client
//
class Indexer {
  constructor(hostname, fetch) {
    this.hostname = void 0;
    this.fetch = void 0;
    this.path = '/rpc/Indexer/';
    this.ping = (headers, signal) => {
      return this.fetch(this.url('Ping'), createHTTPRequest({}, headers, signal)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            status: _data.status
          };
        });
      }, error => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ''}`
        });
      });
    };
    this.version = (headers, signal) => {
      return this.fetch(this.url('Version'), createHTTPRequest({}, headers, signal)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            version: _data.version
          };
        });
      }, error => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ''}`
        });
      });
    };
    this.runtimeStatus = (headers, signal) => {
      return this.fetch(this.url('RuntimeStatus'), createHTTPRequest({}, headers, signal)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            status: _data.status
          };
        });
      }, error => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ''}`
        });
      });
    };
    this.getChainID = (headers, signal) => {
      return this.fetch(this.url('GetChainID'), createHTTPRequest({}, headers, signal)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            chainID: _data.chainID
          };
        });
      }, error => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ''}`
        });
      });
    };
    this.getEtherBalance = (args, headers, signal) => {
      return this.fetch(this.url('GetEtherBalance'), createHTTPRequest(args, headers, signal)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            balance: _data.balance
          };
        });
      }, error => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ''}`
        });
      });
    };
    this.getTokenBalances = (args, headers, signal) => {
      return this.fetch(this.url('GetTokenBalances'), createHTTPRequest(args, headers, signal)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            page: _data.page,
            balances: _data.balances
          };
        });
      }, error => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ''}`
        });
      });
    };
    this.getTokenSupplies = (args, headers, signal) => {
      return this.fetch(this.url('GetTokenSupplies'), createHTTPRequest(args, headers, signal)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            page: _data.page,
            contractType: _data.contractType,
            tokenIDs: _data.tokenIDs
          };
        });
      }, error => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ''}`
        });
      });
    };
    this.getTokenSuppliesMap = (args, headers, signal) => {
      return this.fetch(this.url('GetTokenSuppliesMap'), createHTTPRequest(args, headers, signal)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            supplies: _data.supplies
          };
        });
      }, error => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ''}`
        });
      });
    };
    this.getBalanceUpdates = (args, headers, signal) => {
      return this.fetch(this.url('GetBalanceUpdates'), createHTTPRequest(args, headers, signal)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            page: _data.page,
            balances: _data.balances
          };
        });
      }, error => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ''}`
        });
      });
    };
    this.getTransactionHistory = (args, headers, signal) => {
      return this.fetch(this.url('GetTransactionHistory'), createHTTPRequest(args, headers, signal)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            page: _data.page,
            transactions: _data.transactions
          };
        });
      }, error => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ''}`
        });
      });
    };
    this.syncBalance = (args, headers, signal) => {
      return this.fetch(this.url('SyncBalance'), createHTTPRequest(args, headers, signal)).then(res => {
        return buildResponse(res).then(_data => {
          return {};
        });
      }, error => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ''}`
        });
      });
    };
    this.fetchTransactionReceipt = (args, headers, signal) => {
      return this.fetch(this.url('FetchTransactionReceipt'), createHTTPRequest(args, headers, signal)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            receipt: _data.receipt
          };
        });
      }, error => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ''}`
        });
      });
    };
    this.getOrderbookOrders = (args, headers, signal) => {
      return this.fetch(this.url('GetOrderbookOrders'), createHTTPRequest(args, headers, signal)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            page: _data.page,
            orders: _data.orders
          };
        });
      }, error => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ''}`
        });
      });
    };
    this.getTopOrders = (args, headers, signal) => {
      return this.fetch(this.url('GetTopOrders'), createHTTPRequest(args, headers, signal)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            orders: _data.orders
          };
        });
      }, error => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ''}`
        });
      });
    };
    this.fetchTransactionReceiptWithFilter = (args, headers, signal) => {
      return this.fetch(this.url('FetchTransactionReceiptWithFilter'), createHTTPRequest(args, headers, signal)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            receipt: _data.receipt
          };
        });
      }, error => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ''}`
        });
      });
    };
    this.getAllWebhookListeners = (args, headers, signal) => {
      return this.fetch(this.url('GetAllWebhookListeners'), createHTTPRequest(args, headers, signal)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            listeners: _data.listeners
          };
        });
      }, error => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ''}`
        });
      });
    };
    this.getWebhookListener = (args, headers, signal) => {
      return this.fetch(this.url('GetWebhookListener'), createHTTPRequest(args, headers, signal)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            listener: _data.listener
          };
        });
      }, error => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ''}`
        });
      });
    };
    this.addWebhookListener = (args, headers, signal) => {
      return this.fetch(this.url('AddWebhookListener'), createHTTPRequest(args, headers, signal)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            status: _data.status,
            listener: _data.listener
          };
        });
      }, error => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ''}`
        });
      });
    };
    this.updateWebhookListener = (args, headers, signal) => {
      return this.fetch(this.url('UpdateWebhookListener'), createHTTPRequest(args, headers, signal)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            status: _data.status
          };
        });
      }, error => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ''}`
        });
      });
    };
    this.removeWebhookListener = (args, headers, signal) => {
      return this.fetch(this.url('RemoveWebhookListener'), createHTTPRequest(args, headers, signal)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            status: _data.status
          };
        });
      }, error => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ''}`
        });
      });
    };
    this.toggleWebhookListener = (args, headers, signal) => {
      return this.fetch(this.url('ToggleWebhookListener'), createHTTPRequest(args, headers, signal)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            webhookListener: _data.webhookListener
          };
        });
      }, error => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ''}`
        });
      });
    };
    this.pauseAllWebhookListeners = (args, headers, signal) => {
      return this.fetch(this.url('PauseAllWebhookListeners'), createHTTPRequest(args, headers, signal)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            status: _data.status
          };
        });
      }, error => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ''}`
        });
      });
    };
    this.resumeAllWebhookListeners = (args, headers, signal) => {
      return this.fetch(this.url('ResumeAllWebhookListeners'), createHTTPRequest(args, headers, signal)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            status: _data.status
          };
        });
      }, error => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ''}`
        });
      });
    };
    this.subscribeReceipts = (args, options) => {
      const _fetch = () => this.fetch(this.url('SubscribeReceipts'), createHTTPRequest(args, options.headers, options.signal)).then(async function (res) {
        await sseResponse(res, options, _fetch);
      }, error => {
        options.onError(error, _fetch);
      });
      return _fetch();
    };
    this.subscribeEvents = (args, options) => {
      const _fetch = () => this.fetch(this.url('SubscribeEvents'), createHTTPRequest(args, options.headers, options.signal)).then(async function (res) {
        await sseResponse(res, options, _fetch);
      }, error => {
        options.onError(error, _fetch);
      });
      return _fetch();
    };
    this.subscribeBalanceUpdates = (args, options) => {
      const _fetch = () => this.fetch(this.url('SubscribeBalanceUpdates'), createHTTPRequest(args, options.headers, options.signal)).then(async function (res) {
        await sseResponse(res, options, _fetch);
      }, error => {
        options.onError(error, _fetch);
      });
      return _fetch();
    };
    this.hostname = hostname;
    this.fetch = (input, init) => fetch(input, init);
  }
  url(name) {
    return this.hostname + this.path + name;
  }
}
const sseResponse = async (res, options, retryFetch) => {
  const {
    onMessage,
    onOpen,
    onClose,
    onError
  } = options;
  if (!res.ok) {
    try {
      await buildResponse(res);
    } catch (error) {
      // @ts-ignore
      onError(error, retryFetch);
    }
    return;
  }
  if (!res.body) {
    onError(WebrpcBadResponseError.new({
      status: res.status,
      cause: 'Invalid response, missing body'
    }), retryFetch);
    return;
  }
  onOpen && onOpen();
  const reader = res.body.getReader();
  const decoder = new TextDecoder();
  let buffer = '';
  let lastReadTime = Date.now();
  const timeout = (10 + 1) * 1000;
  let intervalId;
  try {
    intervalId = setInterval(() => {
      if (Date.now() - lastReadTime > timeout) {
        throw WebrpcStreamLostError.new({
          cause: 'Stream timed out'
        });
      }
    }, timeout);
    while (true) {
      let value;
      let done;
      try {
        ;
        ({
          value,
          done
        } = await reader.read());
        lastReadTime = Date.now();
        buffer += decoder.decode(value, {
          stream: true
        });
      } catch (error) {
        let message = '';
        if (error instanceof Error) {
          message = error.message;
        }
        if (error instanceof DOMException && error.name === 'AbortError') {
          onError(WebrpcRequestFailedError.new({
            message: 'AbortError',
            cause: `AbortError: ${message}`
          }), () => {
            throw new Error('Abort signal cannot be used to reconnect');
          });
        } else {
          onError(WebrpcStreamLostError.new({
            cause: `reader.read(): ${message}`
          }), retryFetch);
        }
        return;
      }
      let lines = buffer.split('\n');
      for (let i = 0; i < lines.length - 1; i++) {
        if (lines[i].length == 0) {
          continue;
        }
        let data;
        try {
          data = JSON.parse(lines[i]);
          if (data.hasOwnProperty('webrpcError')) {
            const error = data.webrpcError;
            const code = typeof error.code === 'number' ? error.code : 0;
            onError((webrpcErrorByCode[code] || WebrpcError).new(error), retryFetch);
            return;
          }
        } catch (error) {
          if (error instanceof Error && error.message === 'Abort signal cannot be used to reconnect') {
            throw error;
          }
          onError(WebrpcBadResponseError.new({
            status: res.status,
            // @ts-ignore
            cause: `JSON.parse(): ${error.message}`
          }), retryFetch);
        }
        onMessage(data);
      }
      if (!done) {
        buffer = lines[lines.length - 1];
        continue;
      }
      onClose && onClose();
      return;
    }
  } catch (error) {
    // @ts-ignore
    if (error instanceof WebrpcStreamLostError) {
      onError(error, retryFetch);
    } else {
      throw error;
    }
  } finally {
    clearInterval(intervalId);
  }
};
const createHTTPRequest = (body = {}, headers = {}, signal = null) => {
  return {
    method: 'POST',
    headers: _extends({}, headers, {
      'Content-Type': 'application/json'
    }),
    body: JSON.stringify(body || {}),
    signal
  };
};
const buildResponse = res => {
  return res.text().then(text => {
    let data;
    try {
      data = JSON.parse(text);
    } catch (error) {
      let message = '';
      if (error instanceof Error) {
        message = error.message;
      }
      throw WebrpcBadResponseError.new({
        status: res.status,
        cause: `JSON.parse(): ${message}: response text: ${text}`
      });
    }
    if (!res.ok) {
      const code = typeof data.code === 'number' ? data.code : 0;
      throw (webrpcErrorByCode[code] || WebrpcError).new(data);
    }
    return data;
  });
};

//
// Errors
//

class WebrpcError extends Error {
  constructor(name, code, message, status, cause) {
    super(message);
    this.name = void 0;
    this.code = void 0;
    this.message = void 0;
    this.status = void 0;
    this.cause = void 0;
    /** @deprecated Use message instead of msg. Deprecated in webrpc v0.11.0. */
    this.msg = void 0;
    this.name = name || 'WebrpcError';
    this.code = typeof code === 'number' ? code : 0;
    this.message = message || `endpoint error ${this.code}`;
    this.msg = this.message;
    this.status = typeof status === 'number' ? status : 0;
    this.cause = cause;
    Object.setPrototypeOf(this, WebrpcError.prototype);
  }
  static new(payload) {
    return new this(payload.error, payload.code, payload.message || payload.msg, payload.status, payload.cause);
  }
}

// Webrpc errors

class WebrpcEndpointError extends WebrpcError {
  constructor(name = 'WebrpcEndpoint', code = 0, message = 'endpoint error', status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, WebrpcEndpointError.prototype);
  }
}
class WebrpcRequestFailedError extends WebrpcError {
  constructor(name = 'WebrpcRequestFailed', code = -1, message = 'request failed', status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, WebrpcRequestFailedError.prototype);
  }
}
class WebrpcBadRouteError extends WebrpcError {
  constructor(name = 'WebrpcBadRoute', code = -2, message = 'bad route', status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, WebrpcBadRouteError.prototype);
  }
}
class WebrpcBadMethodError extends WebrpcError {
  constructor(name = 'WebrpcBadMethod', code = -3, message = 'bad method', status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, WebrpcBadMethodError.prototype);
  }
}
class WebrpcBadRequestError extends WebrpcError {
  constructor(name = 'WebrpcBadRequest', code = -4, message = 'bad request', status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, WebrpcBadRequestError.prototype);
  }
}
class WebrpcBadResponseError extends WebrpcError {
  constructor(name = 'WebrpcBadResponse', code = -5, message = 'bad response', status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, WebrpcBadResponseError.prototype);
  }
}
class WebrpcServerPanicError extends WebrpcError {
  constructor(name = 'WebrpcServerPanic', code = -6, message = 'server panic', status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, WebrpcServerPanicError.prototype);
  }
}
class WebrpcInternalErrorError extends WebrpcError {
  constructor(name = 'WebrpcInternalError', code = -7, message = 'internal error', status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, WebrpcInternalErrorError.prototype);
  }
}
class WebrpcClientDisconnectedError extends WebrpcError {
  constructor(name = 'WebrpcClientDisconnected', code = -8, message = 'client disconnected', status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, WebrpcClientDisconnectedError.prototype);
  }
}
class WebrpcStreamLostError extends WebrpcError {
  constructor(name = 'WebrpcStreamLost', code = -9, message = 'stream lost', status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, WebrpcStreamLostError.prototype);
  }
}
class WebrpcStreamFinishedError extends WebrpcError {
  constructor(name = 'WebrpcStreamFinished', code = -10, message = 'stream finished', status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, WebrpcStreamFinishedError.prototype);
  }
}

// Schema errors

class UnauthorizedError extends WebrpcError {
  constructor(name = 'Unauthorized', code = 1000, message = 'Unauthorized access', status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, UnauthorizedError.prototype);
  }
}
class PermissionDeniedError extends WebrpcError {
  constructor(name = 'PermissionDenied', code = 1001, message = 'Permission denied', status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, PermissionDeniedError.prototype);
  }
}
class SessionExpiredError extends WebrpcError {
  constructor(name = 'SessionExpired', code = 1002, message = 'Session expired', status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, SessionExpiredError.prototype);
  }
}
class MethodNotFoundError extends WebrpcError {
  constructor(name = 'MethodNotFound', code = 1003, message = 'Method not found', status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, MethodNotFoundError.prototype);
  }
}
class RequestConflictError extends WebrpcError {
  constructor(name = 'RequestConflict', code = 1004, message = 'Conflict with target resource', status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, RequestConflictError.prototype);
  }
}
class AbortedError extends WebrpcError {
  constructor(name = 'Aborted', code = 1005, message = 'Request aborted', status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, AbortedError.prototype);
  }
}
class TimeoutError extends WebrpcError {
  constructor(name = 'Timeout', code = 2000, message = 'Request timed out', status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, TimeoutError.prototype);
  }
}
class InvalidArgumentError extends WebrpcError {
  constructor(name = 'InvalidArgument', code = 2001, message = 'Invalid argument', status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, InvalidArgumentError.prototype);
  }
}
class UnavailableError extends WebrpcError {
  constructor(name = 'Unavailable', code = 2002, message = 'Unavailable resource', status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, UnavailableError.prototype);
  }
}
class QueryFailedError extends WebrpcError {
  constructor(name = 'QueryFailed', code = 2003, message = 'Query failed', status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, QueryFailedError.prototype);
  }
}
class ResourceExhaustedError extends WebrpcError {
  constructor(name = 'ResourceExhausted', code = 2004, message = 'Resource exhausted', status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, ResourceExhaustedError.prototype);
  }
}
class NotFoundError extends WebrpcError {
  constructor(name = 'NotFound', code = 3000, message = 'Resource not found', status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, NotFoundError.prototype);
  }
}
class ProjectNotFoundError extends WebrpcError {
  constructor(name = 'ProjectNotFound', code = 3002, message = 'Project not found', status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, ProjectNotFoundError.prototype);
  }
}
class MetadataCallFailedError extends WebrpcError {
  constructor(name = 'MetadataCallFailed', code = 3003, message = 'Metadata service call failed', status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, MetadataCallFailedError.prototype);
  }
}
let errors = /*#__PURE__*/function (errors) {
  errors["WebrpcEndpoint"] = "WebrpcEndpoint";
  errors["WebrpcRequestFailed"] = "WebrpcRequestFailed";
  errors["WebrpcBadRoute"] = "WebrpcBadRoute";
  errors["WebrpcBadMethod"] = "WebrpcBadMethod";
  errors["WebrpcBadRequest"] = "WebrpcBadRequest";
  errors["WebrpcBadResponse"] = "WebrpcBadResponse";
  errors["WebrpcServerPanic"] = "WebrpcServerPanic";
  errors["WebrpcInternalError"] = "WebrpcInternalError";
  errors["WebrpcClientDisconnected"] = "WebrpcClientDisconnected";
  errors["WebrpcStreamLost"] = "WebrpcStreamLost";
  errors["WebrpcStreamFinished"] = "WebrpcStreamFinished";
  errors["Unauthorized"] = "Unauthorized";
  errors["PermissionDenied"] = "PermissionDenied";
  errors["SessionExpired"] = "SessionExpired";
  errors["MethodNotFound"] = "MethodNotFound";
  errors["RequestConflict"] = "RequestConflict";
  errors["Aborted"] = "Aborted";
  errors["Timeout"] = "Timeout";
  errors["InvalidArgument"] = "InvalidArgument";
  errors["Unavailable"] = "Unavailable";
  errors["QueryFailed"] = "QueryFailed";
  errors["ResourceExhausted"] = "ResourceExhausted";
  errors["NotFound"] = "NotFound";
  errors["ProjectNotFound"] = "ProjectNotFound";
  errors["MetadataCallFailed"] = "MetadataCallFailed";
  return errors;
}({});
const webrpcErrorByCode = {
  [0]: WebrpcEndpointError,
  [-1]: WebrpcRequestFailedError,
  [-2]: WebrpcBadRouteError,
  [-3]: WebrpcBadMethodError,
  [-4]: WebrpcBadRequestError,
  [-5]: WebrpcBadResponseError,
  [-6]: WebrpcServerPanicError,
  [-7]: WebrpcInternalErrorError,
  [-8]: WebrpcClientDisconnectedError,
  [-9]: WebrpcStreamLostError,
  [-10]: WebrpcStreamFinishedError,
  [1000]: UnauthorizedError,
  [1001]: PermissionDeniedError,
  [1002]: SessionExpiredError,
  [1003]: MethodNotFoundError,
  [1004]: RequestConflictError,
  [1005]: AbortedError,
  [2000]: TimeoutError,
  [2001]: InvalidArgumentError,
  [2002]: UnavailableError,
  [2003]: QueryFailedError,
  [2004]: ResourceExhaustedError,
  [3000]: NotFoundError,
  [3002]: ProjectNotFoundError,
  [3003]: MetadataCallFailedError
};

const fetch = globalThis.fetch;
class SequenceIndexer extends Indexer {
  constructor(hostname, projectAccessKey, jwtAuth) {
    super(hostname.endsWith('/') ? hostname.slice(0, -1) : hostname, fetch);
    this.projectAccessKey = projectAccessKey;
    this.jwtAuth = jwtAuth;
    this._fetch = (input, init) => {
      // automatically include jwt and access key auth header to requests
      // if its been set on the api client
      const headers = {};
      const jwtAuth = this.jwtAuth;
      const projectAccessKey = this.projectAccessKey;
      if (jwtAuth && jwtAuth.length > 0) {
        headers['Authorization'] = `BEARER ${jwtAuth}`;
      }
      if (projectAccessKey && projectAccessKey.length > 0) {
        headers['X-Access-Key'] = projectAccessKey;
      }

      // before the request is made
      init.headers = _extends({}, init.headers, headers);
      return fetch(input, init);
    };
    this.fetch = this._fetch;
  }
}

export { AbortedError, ContractType, EventLogDataType, EventLogType, Indexer, InvalidArgumentError, MetadataCallFailedError, MethodNotFoundError, NotFoundError, OrderStatus, PermissionDeniedError, ProjectNotFoundError, QueryFailedError, RequestConflictError, ResourceExhaustedError, SequenceIndexer, SessionExpiredError, SortOrder, TimeoutError, TransactionStatus, TransactionType, TxnTransferType, UnauthorizedError, UnavailableError, WebRPCSchemaHash, WebRPCSchemaVersion, WebRPCVersion, WebrpcBadMethodError, WebrpcBadRequestError, WebrpcBadResponseError, WebrpcBadRouteError, WebrpcClientDisconnectedError, WebrpcEndpointError, WebrpcError, WebrpcInternalErrorError, WebrpcRequestFailedError, WebrpcServerPanicError, WebrpcStreamFinishedError, WebrpcStreamLostError, errors };
