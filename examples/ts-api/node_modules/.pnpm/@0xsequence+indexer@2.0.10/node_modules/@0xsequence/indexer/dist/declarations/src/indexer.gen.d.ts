export declare const WebRPCVersion = "v1";
export declare const WebRPCSchemaVersion = "v0.4.0";
export declare const WebRPCSchemaHash = "9accea267e7db3d66f40d5e0f27db92eb5a29e2f";
export interface ContractInfo {
    chainId: number;
    address: string;
    name: string;
    type: string;
    symbol: string;
    decimals?: number;
    logoURI: string;
    deployed: boolean;
    bytecodeHash: string;
    extensions: ContractInfoExtensions;
    updatedAt: string;
}
export interface ContractInfoExtensions {
    link: string;
    description: string;
    ogImage: string;
    originChainId: number;
    originAddress: string;
    blacklist: boolean;
    verified: boolean;
    verifiedBy: string;
    featured: boolean;
}
export interface TokenMetadata {
    tokenId: string;
    name: string;
    description?: string;
    image?: string;
    video?: string;
    audio?: string;
    properties?: {
        [key: string]: any;
    };
    attributes: Array<{
        [key: string]: any;
    }>;
    image_data?: string;
    external_url?: string;
    background_color?: string;
    animation_url?: string;
    decimals?: number;
    updatedAt?: string;
    assets?: Array<Asset>;
}
export interface Asset {
    id: number;
    collectionId: number;
    tokenId?: string;
    url?: string;
    metadataField: string;
    name?: string;
    filesize?: number;
    mimeType?: string;
    width?: number;
    height?: number;
    updatedAt?: string;
}
export declare enum ContractType {
    UNKNOWN = "UNKNOWN",
    NATIVE = "NATIVE",
    ERC20 = "ERC20",
    ERC721 = "ERC721",
    ERC1155 = "ERC1155",
    SEQUENCE_WALLET = "SEQUENCE_WALLET",
    ERC20_BRIDGE = "ERC20_BRIDGE",
    ERC721_BRIDGE = "ERC721_BRIDGE",
    ERC1155_BRIDGE = "ERC1155_BRIDGE",
    SEQ_MARKETPLACE = "SEQ_MARKETPLACE"
}
export declare enum EventLogType {
    UNKNOWN = "UNKNOWN",
    BLOCK_ADDED = "BLOCK_ADDED",
    BLOCK_REMOVED = "BLOCK_REMOVED"
}
export declare enum EventLogDataType {
    EVENT = "EVENT",
    TOKEN_TRANSFER = "TOKEN_TRANSFER",
    NATIVE_TOKEN_TRANSFER = "NATIVE_TOKEN_TRANSFER",
    SEQUENCE_TXN = "SEQUENCE_TXN"
}
export declare enum OrderStatus {
    OPEN = "OPEN",
    CLOSED = "CLOSED",
    CANCELLED = "CANCELLED"
}
export declare enum TxnTransferType {
    UNKNOWN = "UNKNOWN",
    SEND = "SEND",
    RECEIVE = "RECEIVE"
}
export declare enum TransactionStatus {
    FAILED = "FAILED",
    SUCCESSFUL = "SUCCESSFUL"
}
export declare enum TransactionType {
    LegacyTxnType = "LegacyTxnType",
    AccessListTxnType = "AccessListTxnType",
    DynamicFeeTxnType = "DynamicFeeTxnType"
}
export declare enum SortOrder {
    DESC = "DESC",
    ASC = "ASC"
}
export interface Version {
    webrpcVersion: string;
    schemaVersion: string;
    schemaHash: string;
    appVersion: string;
}
export interface RuntimeStatus {
    healthOK: boolean;
    indexerEnabled: boolean;
    startTime: string;
    uptime: number;
    ver: string;
    branch: string;
    commitHash: string;
    chainID: number;
    checks: RuntimeChecks;
}
export interface WALWriterRuntimeStatus {
    healthOK: boolean;
    startTime: string;
    uptime: number;
    ver: string;
    branch: string;
    commitHash: string;
    chainID: number;
    percentWALWritten: number;
}
export interface RuntimeChecks {
    running: boolean;
    runnables: any;
    cgoEnabled: boolean;
    quotaControlEnabled: boolean;
    syncMode: string;
    percentIndexed: number;
    lastBlockNum: number;
    lastBlockNumWithState: number;
    bloomStatus: BloomStatus;
    bond: Bond;
    diskUsage: DiskUsage;
}
export interface DiskUsage {
    humanReadable: string;
    used: number;
    size: number;
    percent: number;
    dirs: {
        [key: string]: string;
    };
}
export interface Bond {
    pebble: PebbleMetrics;
    estimatedDiskUsagePerTable: any;
    estimatedDiskUsageTotal: string;
}
export interface PebbleMetrics {
    compactionCount: number;
    compactionEstimatedDebt: number;
    compactionInProgressBytes: number;
    compactionNumInProgress: number;
    compactionMarkedFiles: number;
}
export interface BloomStatus {
    enabled: boolean;
    initialized: boolean;
    bloomInitElapsedTime: string;
}
export interface EtherBalance {
    accountAddress: string;
    balanceWei: string;
}
export interface IndexState {
    chainId: string;
    lastBlockNum: number;
    lastBlockHash: string;
}
export interface IndexedBlock {
    blockNumber: number;
    blockShortHash: string;
}
export interface TxnInfo {
    from: string;
    to: string;
    value: string;
}
export interface EventLog {
    id: number;
    uid: string;
    type: EventLogType;
    blockNumber: number;
    blockHash: string;
    parentBlockHash: string;
    contractAddress: string;
    contractType: ContractType;
    txnHash: string;
    txnIndex: number;
    txnLogIndex: number;
    logDataType: EventLogDataType;
    ts: string;
    txnInfo?: TxnInfo;
    rawLog?: {
        [key: string]: any;
    };
    event?: EventDecoded;
}
export interface EventDecoded {
    topicHash: string;
    eventSig: string;
    types: Array<string>;
    names: Array<string>;
    values: Array<string>;
}
export interface TokenBalance {
    contractType: ContractType;
    contractAddress: string;
    accountAddress: string;
    tokenID?: string;
    balance: string;
    blockHash: string;
    blockNumber: number;
    chainId: number;
    contractInfo?: ContractInfo;
    tokenMetadata?: TokenMetadata;
}
export interface OrderbookOrder {
    orderId: string;
    tokenContract: string;
    tokenId: string;
    isListing: boolean;
    quantity: string;
    quantityRemaining: string;
    currencyAddress: string;
    pricePerToken: string;
    expiry: string;
    orderStatus: OrderStatus;
    createdBy: string;
    createdAt: number;
    orderbookContractAddress: string;
}
export interface OrderbookOrderFilter {
    isListing?: boolean;
    userAddress?: string;
    tokenIds: Array<string>;
    excludeUserAddress?: string;
}
export interface TokenHistory {
    blockNumber: number;
    blockHash: string;
    accountAddress: string;
    contractAddress: string;
    contractType: ContractType;
    fromAddress: string;
    toAddress: string;
    txnHash: string;
    txnIndex: number;
    txnLogIndex: number;
    logData: string;
    tokenIDs: string;
    Amounts: string;
    ts: string;
}
export interface TokenSupply {
    tokenID: string;
    supply: string;
    chainId: number;
    contractInfo?: ContractInfo;
    tokenMetadata?: TokenMetadata;
}
export interface Transaction {
    txnHash: string;
    blockNumber: number;
    blockHash: string;
    chainId: number;
    metaTxnID?: string;
    transfers?: Array<TxnTransfer>;
    timestamp: string;
}
export interface TxnTransfer {
    transferType: TxnTransferType;
    contractAddress: string;
    contractType: ContractType;
    from: string;
    to: string;
    tokenIds?: Array<string>;
    amounts: Array<string>;
    logIndex: number;
    contractInfo?: ContractInfo;
    tokenMetadata?: {
        [key: string]: TokenMetadata;
    };
}
export interface TransactionHistoryFilter {
    accountAddress?: string;
    contractAddress?: string;
    accountAddresses?: Array<string>;
    contractAddresses?: Array<string>;
    transactionHashes?: Array<string>;
    metaTransactionIDs?: Array<string>;
    fromBlock?: number;
    toBlock?: number;
    tokenID?: string;
}
export interface TransactionFilter {
    txnHash?: string;
    from?: string;
    to?: string;
    contractAddress?: string;
    event?: string;
}
export interface TransactionReceipt {
    txnHash: string;
    txnStatus: TransactionStatus;
    txnIndex: number;
    txnType: TransactionType;
    blockHash: string;
    blockNumber: number;
    gasUsed: number;
    effectiveGasPrice: string;
    from: string;
    to: string;
    logs: Array<TransactionLog>;
    final: boolean;
    reorged: boolean;
}
export interface TransactionLog {
    contractAddress: string;
    topics: Array<string>;
    data: string;
    index: number;
}
export interface Page {
    page?: number;
    column?: string;
    before?: any;
    after?: any;
    sort?: Array<SortBy>;
    pageSize?: number;
    more?: boolean;
}
export interface SortBy {
    column: string;
    order: SortOrder;
}
export interface WebhookListener {
    id: number;
    projectID: number;
    url: string;
    filters: EventFilter;
    name: string;
    updatedAt: string;
    active: boolean;
}
export interface EventFilter {
    events?: Array<string>;
    contractAddresses?: Array<string>;
    accounts?: Array<string>;
    tokenIDs?: Array<string>;
}
export interface TokenBalanceFilter {
    contractAddress: string;
    sinceBlockNumber: number;
}
export interface MetadataOptions {
    verifiedOnly?: boolean;
    unverifiedOnly?: boolean;
    includeContracts?: Array<string>;
}
export interface Indexer {
    ping(headers?: object, signal?: AbortSignal): Promise<PingReturn>;
    version(headers?: object, signal?: AbortSignal): Promise<VersionReturn>;
    runtimeStatus(headers?: object, signal?: AbortSignal): Promise<RuntimeStatusReturn>;
    getChainID(headers?: object, signal?: AbortSignal): Promise<GetChainIDReturn>;
    getEtherBalance(args: GetEtherBalanceArgs, headers?: object, signal?: AbortSignal): Promise<GetEtherBalanceReturn>;
    getTokenBalances(args: GetTokenBalancesArgs, headers?: object, signal?: AbortSignal): Promise<GetTokenBalancesReturn>;
    getTokenSupplies(args: GetTokenSuppliesArgs, headers?: object, signal?: AbortSignal): Promise<GetTokenSuppliesReturn>;
    getTokenSuppliesMap(args: GetTokenSuppliesMapArgs, headers?: object, signal?: AbortSignal): Promise<GetTokenSuppliesMapReturn>;
    getBalanceUpdates(args: GetBalanceUpdatesArgs, headers?: object, signal?: AbortSignal): Promise<GetBalanceUpdatesReturn>;
    getTransactionHistory(args: GetTransactionHistoryArgs, headers?: object, signal?: AbortSignal): Promise<GetTransactionHistoryReturn>;
    syncBalance(args: SyncBalanceArgs, headers?: object, signal?: AbortSignal): Promise<SyncBalanceReturn>;
    fetchTransactionReceipt(args: FetchTransactionReceiptArgs, headers?: object, signal?: AbortSignal): Promise<FetchTransactionReceiptReturn>;
    getOrderbookOrders(args: GetOrderbookOrdersArgs, headers?: object, signal?: AbortSignal): Promise<GetOrderbookOrdersReturn>;
    getTopOrders(args: GetTopOrdersArgs, headers?: object, signal?: AbortSignal): Promise<GetTopOrdersReturn>;
    fetchTransactionReceiptWithFilter(args: FetchTransactionReceiptWithFilterArgs, headers?: object, signal?: AbortSignal): Promise<FetchTransactionReceiptWithFilterReturn>;
    getAllWebhookListeners(args: GetAllWebhookListenersArgs, headers?: object, signal?: AbortSignal): Promise<GetAllWebhookListenersReturn>;
    getWebhookListener(args: GetWebhookListenerArgs, headers?: object, signal?: AbortSignal): Promise<GetWebhookListenerReturn>;
    addWebhookListener(args: AddWebhookListenerArgs, headers?: object, signal?: AbortSignal): Promise<AddWebhookListenerReturn>;
    updateWebhookListener(args: UpdateWebhookListenerArgs, headers?: object, signal?: AbortSignal): Promise<UpdateWebhookListenerReturn>;
    removeWebhookListener(args: RemoveWebhookListenerArgs, headers?: object, signal?: AbortSignal): Promise<RemoveWebhookListenerReturn>;
    toggleWebhookListener(args: ToggleWebhookListenerArgs, headers?: object, signal?: AbortSignal): Promise<ToggleWebhookListenerReturn>;
    pauseAllWebhookListeners(args: PauseAllWebhookListenersArgs, headers?: object, signal?: AbortSignal): Promise<PauseAllWebhookListenersReturn>;
    resumeAllWebhookListeners(args: ResumeAllWebhookListenersArgs, headers?: object, signal?: AbortSignal): Promise<ResumeAllWebhookListenersReturn>;
    subscribeReceipts(args: SubscribeReceiptsArgs, options: WebrpcStreamOptions<SubscribeReceiptsReturn>): Promise<void>;
    subscribeEvents(args: SubscribeEventsArgs, options: WebrpcStreamOptions<SubscribeEventsReturn>): Promise<void>;
    subscribeBalanceUpdates(args: SubscribeBalanceUpdatesArgs, options: WebrpcStreamOptions<SubscribeBalanceUpdatesReturn>): Promise<void>;
}
export interface PingArgs {
}
export interface PingReturn {
    status: boolean;
}
export interface VersionArgs {
}
export interface VersionReturn {
    version: Version;
}
export interface RuntimeStatusArgs {
}
export interface RuntimeStatusReturn {
    status: RuntimeStatus;
}
export interface GetChainIDArgs {
}
export interface GetChainIDReturn {
    chainID: number;
}
export interface GetEtherBalanceArgs {
    accountAddress?: string;
}
export interface GetEtherBalanceReturn {
    balance: EtherBalance;
}
export interface GetTokenBalancesArgs {
    accountAddress?: string;
    contractAddress?: string;
    tokenID?: string;
    includeMetadata?: boolean;
    metadataOptions?: MetadataOptions;
    includeCollectionTokens?: boolean;
    page?: Page;
}
export interface GetTokenBalancesReturn {
    page: Page;
    balances: Array<TokenBalance>;
}
export interface GetTokenSuppliesArgs {
    contractAddress: string;
    includeMetadata?: boolean;
    metadataOptions?: MetadataOptions;
    page?: Page;
}
export interface GetTokenSuppliesReturn {
    page: Page;
    contractType: ContractType;
    tokenIDs: Array<TokenSupply>;
}
export interface GetTokenSuppliesMapArgs {
    tokenMap: {
        [key: string]: Array<string>;
    };
    includeMetadata?: boolean;
    metadataOptions?: MetadataOptions;
}
export interface GetTokenSuppliesMapReturn {
    supplies: {
        [key: string]: Array<TokenSupply>;
    };
}
export interface GetBalanceUpdatesArgs {
    contractAddress: string;
    lastBlockNumber: number;
    lastBlockHash?: string;
    page?: Page;
}
export interface GetBalanceUpdatesReturn {
    page: Page;
    balances: Array<TokenBalance>;
}
export interface GetTransactionHistoryArgs {
    filter: TransactionHistoryFilter;
    page?: Page;
    includeMetadata?: boolean;
    metadataOptions?: MetadataOptions;
}
export interface GetTransactionHistoryReturn {
    page: Page;
    transactions: Array<Transaction>;
}
export interface SyncBalanceArgs {
    accountAddress: string;
    contractAddress: string;
    tokenID?: string;
}
export interface SyncBalanceReturn {
}
export interface FetchTransactionReceiptArgs {
    txnHash: string;
    maxBlockWait?: number;
}
export interface FetchTransactionReceiptReturn {
    receipt: TransactionReceipt;
}
export interface GetOrderbookOrdersArgs {
    page?: Page;
    orderbookContractAddress: string;
    collectionAddress: string;
    currencyAddresses: Array<string>;
    filters: Array<OrderbookOrderFilter>;
    orderStatuses: Array<OrderStatus>;
    beforeExpiryTimestamp: number;
}
export interface GetOrderbookOrdersReturn {
    page?: Page;
    orders: Array<OrderbookOrder>;
}
export interface GetTopOrdersArgs {
    orderbookContractAddress: string;
    collectionAddress: string;
    currencyAddresses: Array<string>;
    tokenIDs: Array<string>;
    isListing: boolean;
    priceSort: SortOrder;
    excludeUser?: string;
}
export interface GetTopOrdersReturn {
    orders: Array<OrderbookOrder>;
}
export interface FetchTransactionReceiptWithFilterArgs {
    filter: TransactionFilter;
    maxBlockWait?: number;
}
export interface FetchTransactionReceiptWithFilterReturn {
    receipt: TransactionReceipt;
}
export interface GetAllWebhookListenersArgs {
    projectId?: number;
}
export interface GetAllWebhookListenersReturn {
    listeners: Array<WebhookListener>;
}
export interface GetWebhookListenerArgs {
    id: number;
    projectId?: number;
}
export interface GetWebhookListenerReturn {
    listener: WebhookListener;
}
export interface AddWebhookListenerArgs {
    url: string;
    filters: EventFilter;
    projectId?: number;
}
export interface AddWebhookListenerReturn {
    status: boolean;
    listener: WebhookListener;
}
export interface UpdateWebhookListenerArgs {
    listener: WebhookListener;
    projectId?: number;
}
export interface UpdateWebhookListenerReturn {
    status: boolean;
}
export interface RemoveWebhookListenerArgs {
    id: number;
    projectId?: number;
}
export interface RemoveWebhookListenerReturn {
    status: boolean;
}
export interface ToggleWebhookListenerArgs {
    id: number;
    projectId?: number;
}
export interface ToggleWebhookListenerReturn {
    webhookListener: WebhookListener;
}
export interface PauseAllWebhookListenersArgs {
    projectId?: number;
}
export interface PauseAllWebhookListenersReturn {
    status: boolean;
}
export interface ResumeAllWebhookListenersArgs {
    projectId?: number;
}
export interface ResumeAllWebhookListenersReturn {
    status: boolean;
}
export interface SubscribeReceiptsArgs {
    filter: TransactionFilter;
}
export interface SubscribeReceiptsReturn {
    receipt: TransactionReceipt;
}
export interface SubscribeEventsArgs {
    filter: EventFilter;
}
export interface SubscribeEventsReturn {
    log: EventLog;
}
export interface SubscribeBalanceUpdatesArgs {
    contractAddress: string;
}
export interface SubscribeBalanceUpdatesReturn {
    balance: TokenBalance;
}
export declare class Indexer implements Indexer {
    protected hostname: string;
    protected fetch: Fetch;
    protected path: string;
    constructor(hostname: string, fetch: Fetch);
    private url;
    ping: (headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<PingReturn>;
    version: (headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<VersionReturn>;
    runtimeStatus: (headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<RuntimeStatusReturn>;
    getChainID: (headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<GetChainIDReturn>;
    getEtherBalance: (args: GetEtherBalanceArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<GetEtherBalanceReturn>;
    getTokenBalances: (args: GetTokenBalancesArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<GetTokenBalancesReturn>;
    getTokenSupplies: (args: GetTokenSuppliesArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<GetTokenSuppliesReturn>;
    getTokenSuppliesMap: (args: GetTokenSuppliesMapArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<GetTokenSuppliesMapReturn>;
    getBalanceUpdates: (args: GetBalanceUpdatesArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<GetBalanceUpdatesReturn>;
    getTransactionHistory: (args: GetTransactionHistoryArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<GetTransactionHistoryReturn>;
    syncBalance: (args: SyncBalanceArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<SyncBalanceReturn>;
    fetchTransactionReceipt: (args: FetchTransactionReceiptArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<FetchTransactionReceiptReturn>;
    getOrderbookOrders: (args: GetOrderbookOrdersArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<GetOrderbookOrdersReturn>;
    getTopOrders: (args: GetTopOrdersArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<GetTopOrdersReturn>;
    fetchTransactionReceiptWithFilter: (args: FetchTransactionReceiptWithFilterArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<FetchTransactionReceiptWithFilterReturn>;
    getAllWebhookListeners: (args: GetAllWebhookListenersArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<GetAllWebhookListenersReturn>;
    getWebhookListener: (args: GetWebhookListenerArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<GetWebhookListenerReturn>;
    addWebhookListener: (args: AddWebhookListenerArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<AddWebhookListenerReturn>;
    updateWebhookListener: (args: UpdateWebhookListenerArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<UpdateWebhookListenerReturn>;
    removeWebhookListener: (args: RemoveWebhookListenerArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<RemoveWebhookListenerReturn>;
    toggleWebhookListener: (args: ToggleWebhookListenerArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<ToggleWebhookListenerReturn>;
    pauseAllWebhookListeners: (args: PauseAllWebhookListenersArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<PauseAllWebhookListenersReturn>;
    resumeAllWebhookListeners: (args: ResumeAllWebhookListenersArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<ResumeAllWebhookListenersReturn>;
    subscribeReceipts: (args: SubscribeReceiptsArgs, options: WebrpcStreamOptions<SubscribeReceiptsReturn>) => Promise<void>;
    subscribeEvents: (args: SubscribeEventsArgs, options: WebrpcStreamOptions<SubscribeEventsReturn>) => Promise<void>;
    subscribeBalanceUpdates: (args: SubscribeBalanceUpdatesArgs, options: WebrpcStreamOptions<SubscribeBalanceUpdatesReturn>) => Promise<void>;
}
export declare class WebrpcError extends Error {
    name: string;
    code: number;
    message: string;
    status: number;
    cause?: string;
    /** @deprecated Use message instead of msg. Deprecated in webrpc v0.11.0. */
    msg: string;
    constructor(name: string, code: number, message: string, status: number, cause?: string);
    static new(payload: any): WebrpcError;
}
export declare class WebrpcEndpointError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class WebrpcRequestFailedError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class WebrpcBadRouteError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class WebrpcBadMethodError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class WebrpcBadRequestError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class WebrpcBadResponseError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class WebrpcServerPanicError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class WebrpcInternalErrorError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class WebrpcClientDisconnectedError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class WebrpcStreamLostError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class WebrpcStreamFinishedError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class UnauthorizedError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class PermissionDeniedError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class SessionExpiredError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class MethodNotFoundError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class RequestConflictError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class AbortedError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class TimeoutError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class InvalidArgumentError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class UnavailableError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class QueryFailedError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class ResourceExhaustedError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class NotFoundError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class ProjectNotFoundError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class MetadataCallFailedError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare enum errors {
    WebrpcEndpoint = "WebrpcEndpoint",
    WebrpcRequestFailed = "WebrpcRequestFailed",
    WebrpcBadRoute = "WebrpcBadRoute",
    WebrpcBadMethod = "WebrpcBadMethod",
    WebrpcBadRequest = "WebrpcBadRequest",
    WebrpcBadResponse = "WebrpcBadResponse",
    WebrpcServerPanic = "WebrpcServerPanic",
    WebrpcInternalError = "WebrpcInternalError",
    WebrpcClientDisconnected = "WebrpcClientDisconnected",
    WebrpcStreamLost = "WebrpcStreamLost",
    WebrpcStreamFinished = "WebrpcStreamFinished",
    Unauthorized = "Unauthorized",
    PermissionDenied = "PermissionDenied",
    SessionExpired = "SessionExpired",
    MethodNotFound = "MethodNotFound",
    RequestConflict = "RequestConflict",
    Aborted = "Aborted",
    Timeout = "Timeout",
    InvalidArgument = "InvalidArgument",
    Unavailable = "Unavailable",
    QueryFailed = "QueryFailed",
    ResourceExhausted = "ResourceExhausted",
    NotFound = "NotFound",
    ProjectNotFound = "ProjectNotFound",
    MetadataCallFailed = "MetadataCallFailed"
}
export type Fetch = (input: RequestInfo, init?: RequestInit) => Promise<Response>;
export interface WebrpcStreamOptions<T> extends WebrpcOptions {
    onMessage: (message: T) => void;
    onError: (error: WebrpcError, reconnect: () => void) => void;
    onOpen?: () => void;
    onClose?: () => void;
}
export interface WebrpcOptions {
    headers?: HeadersInit;
    signal?: AbortSignal;
}
