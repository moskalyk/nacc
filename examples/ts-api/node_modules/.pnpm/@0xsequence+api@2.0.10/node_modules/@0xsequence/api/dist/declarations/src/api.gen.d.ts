export declare const WebRPCVersion = "v1";
export declare const WebRPCSchemaVersion = "v0.4.0";
export declare const WebRPCSchemaHash = "d3f5f1338693d60d58f87bc408a076218201a097";
export declare enum SortOrder {
    DESC = "DESC",
    ASC = "ASC"
}
export declare enum TokenType {
    ERC20 = "ERC20",
    ERC721 = "ERC721",
    ERC1155 = "ERC1155"
}
export interface Version {
    webrpcVersion: string;
    schemaVersion: string;
    schemaHash: string;
    appVersion: string;
}
export interface RuntimeStatus {
    healthOK: boolean;
    startTime: string;
    uptime: number;
    ver: string;
    branch: string;
    commitHash: string;
    checks: RuntimeChecks;
    numTxnsRelayed: {
        [key: string]: NumTxnsRelayed;
    };
}
export interface NumTxnsRelayed {
    chainID: number;
    prev: number;
    current: number;
    period: number;
}
export interface RuntimeChecks {
}
export interface SequenceContext {
    factory: string;
    mainModule: string;
    mainModuleUpgradable: string;
    guestModule: string;
    utils: string;
}
export interface User {
    address: string;
    username: string;
    avatar: string;
    bio: string;
    location: string;
    locale: string;
    backup?: boolean;
    backupConfirmed?: boolean;
    maxInvites?: number;
    updatedAt?: string;
    createdAt?: string;
}
export interface WalletBackup {
    accountAddress: string;
    secretHash: string;
    encryptedWallet: string;
    userConfirmed: boolean;
    updatedAt?: string;
    createdAt?: string;
}
export interface Friend {
    id: number;
    userAddress: string;
    friendAddress: string;
    nickname: string;
    user?: User;
    createdAt?: string;
}
export interface InviteCode {
    usesLeft: number;
    ownerAccount: string;
    email?: string;
    url: string;
    createdAt?: string;
    expiresAt?: string;
}
export interface InviteCodeAccount {
    claimedByUserAddress: string;
    claimedAt?: string;
}
export interface InviteInfo {
    expiryInHours: number;
    max: number;
    invites: Array<InviteCode>;
}
export interface ContractCall {
    signature: string;
    function: string;
    args: Array<TupleComponent>;
}
export interface TupleComponent {
    name?: string;
    type: string;
    value: any;
}
export interface Transaction {
    delegateCall: boolean;
    revertOnError: boolean;
    gasLimit: string;
    target: string;
    value: string;
    data: string;
    call?: ContractCall;
}
export interface UserStorage {
    userAddress: string;
    key: string;
    value: any;
}
export interface Token {
    chainId: number;
    contractAddress: string;
    tokenId?: string;
}
export interface Price {
    value: number;
    currency: string;
}
export interface TokenPrice {
    token: Token;
    price?: Price;
    price24hChange?: Price;
    floorPrice: Price;
    buyPrice: Price;
    sellPrice: Price;
    updatedAt: string;
}
export interface ExchangeRate {
    name: string;
    symbol: string;
    value: number;
    vsCurrency: string;
    currencyType: string;
}
export interface LinkedWallet {
    id: number;
    walletAddress: string;
    linkedWalletAddress: string;
    createdAt?: string;
}
export interface Page {
    pageSize?: number;
    page?: number;
    totalRecords?: number;
    column?: string;
    before?: any;
    after?: any;
    sort?: Array<SortBy>;
    more?: boolean;
}
export interface SortBy {
    column: string;
    order: SortOrder;
}
export interface NftCheckoutParams {
    name: string;
    imageUrl: string;
    network: string;
    recipientAddress: string;
    blockchainNftId: string;
    contractAddress: string;
    quantity: number;
    decimals?: number;
    tokenAmount: string;
    tokenAddress: string;
    tokenSymbol: string;
    tokenDecimals?: number;
    calldata: string;
    platform: string;
    approvedSpenderAddress?: string;
}
export interface NftCheckout {
    token: string;
    expiresAt: string;
    orderId: string;
}
export interface SardineOrder {
    id: string;
    createdAt?: string;
    referenceId: string;
    status: string;
    fiatCurrency: string;
    fiatExchangeRateUSD: number;
    transactionId: string;
    expiresAt?: string;
    total: number;
    subTotal: number;
    transactionFee: number;
    networkFee: number;
    paymentCurrency?: string;
    paymentMethodType?: string;
    transactionType: string;
    name: string;
    price: number;
    imageUrl: string;
    contractAddress?: string;
    transactionHash?: string;
    recipientAddress: string;
}
export interface SwapQuote {
    currencyAddress: string;
    currencyBalance: string;
    price: string;
    maxPrice: string;
    to: string;
    transactionData: string;
    approveData: string;
}
export interface CurrencyGroup {
    id: number;
    name: string;
    tokens: Array<CurrencyGroupToken>;
}
export interface CurrencyGroupToken {
    id: number;
    currencyGroupId: number;
    chainId: number;
    tokenAddress: string;
}
export interface InventoryPaymentConfig {
    id: number;
    projectId: number;
    chainId: number;
    externalProductId: string;
    paymentTokenAddress: string;
    paymentTokenType: TokenType;
    paymentTokenId: number;
    paymentAmount: number;
    paymentRecipient: string;
    chainedCallAddress?: string;
    chainedCallData?: string;
    allowCrossChainPayments?: boolean;
    callbackURL?: string;
    createdAt: string;
    deletedAt?: string;
}
export interface InventoryPayment {
    id: number;
    inventoryPaymentConfigId: number;
    productRecipient: string;
    paymentChainId: number;
    paymentTokenAddress: string;
    expiration: string;
    createdAt: string;
    completedAt?: string;
    processedAt?: string;
}
export interface InventoryPaymentResponse {
    paymentId: number;
    inventoryPaymentConfigId: number;
    chainId: number;
    externalProductId: string;
    paymentTokenAddress: string;
    paymentTokenType: TokenType;
    paymentTokenId: number;
    paymentTotal: number;
    expiration: string;
    signature: string;
    txTo: string;
    txData: string;
}
export interface API {
    ping(headers?: object, signal?: AbortSignal): Promise<PingReturn>;
    version(headers?: object, signal?: AbortSignal): Promise<VersionReturn>;
    runtimeStatus(headers?: object, signal?: AbortSignal): Promise<RuntimeStatusReturn>;
    clock(headers?: object, signal?: AbortSignal): Promise<ClockReturn>;
    getSequenceContext(headers?: object, signal?: AbortSignal): Promise<GetSequenceContextReturn>;
    getAuthToken(args: GetAuthTokenArgs, headers?: object, signal?: AbortSignal): Promise<GetAuthTokenReturn>;
    getAuthToken2(args: GetAuthToken2Args, headers?: object, signal?: AbortSignal): Promise<GetAuthToken2Return>;
    sendPasswordlessLink(args: SendPasswordlessLinkArgs, headers?: object, signal?: AbortSignal): Promise<SendPasswordlessLinkReturn>;
    friendList(args: FriendListArgs, headers?: object, signal?: AbortSignal): Promise<FriendListReturn>;
    getFriendByAddress(args: GetFriendByAddressArgs, headers?: object, signal?: AbortSignal): Promise<GetFriendByAddressReturn>;
    searchFriends(args: SearchFriendsArgs, headers?: object, signal?: AbortSignal): Promise<SearchFriendsReturn>;
    addFriend(args: AddFriendArgs, headers?: object, signal?: AbortSignal): Promise<AddFriendReturn>;
    updateFriendNickname(args: UpdateFriendNicknameArgs, headers?: object, signal?: AbortSignal): Promise<UpdateFriendNicknameReturn>;
    removeFriend(args: RemoveFriendArgs, headers?: object, signal?: AbortSignal): Promise<RemoveFriendReturn>;
    contractCall(args: ContractCallArgs, headers?: object, signal?: AbortSignal): Promise<ContractCallReturn>;
    decodeContractCall(args: DecodeContractCallArgs, headers?: object, signal?: AbortSignal): Promise<DecodeContractCallReturn>;
    lookupContractCallSelectors(args: LookupContractCallSelectorsArgs, headers?: object, signal?: AbortSignal): Promise<LookupContractCallSelectorsReturn>;
    userStorageFetch(args: UserStorageFetchArgs, headers?: object, signal?: AbortSignal): Promise<UserStorageFetchReturn>;
    userStorageSave(args: UserStorageSaveArgs, headers?: object, signal?: AbortSignal): Promise<UserStorageSaveReturn>;
    userStorageDelete(args: UserStorageDeleteArgs, headers?: object, signal?: AbortSignal): Promise<UserStorageDeleteReturn>;
    userStorageFetchAll(args: UserStorageFetchAllArgs, headers?: object, signal?: AbortSignal): Promise<UserStorageFetchAllReturn>;
    getMoonpayLink(args: GetMoonpayLinkArgs, headers?: object, signal?: AbortSignal): Promise<GetMoonpayLinkReturn>;
    getSardineClientToken(headers?: object, signal?: AbortSignal): Promise<GetSardineClientTokenReturn>;
    getSardineNFTCheckoutToken(args: GetSardineNFTCheckoutTokenArgs, headers?: object, signal?: AbortSignal): Promise<GetSardineNFTCheckoutTokenReturn>;
    getSardineNFTCheckoutOrderStatus(args: GetSardineNFTCheckoutOrderStatusArgs, headers?: object, signal?: AbortSignal): Promise<GetSardineNFTCheckoutOrderStatusReturn>;
    resolveENSAddress(args: ResolveENSAddressArgs, headers?: object, signal?: AbortSignal): Promise<ResolveENSAddressReturn>;
    isValidSignature(args: IsValidSignatureArgs, headers?: object, signal?: AbortSignal): Promise<IsValidSignatureReturn>;
    isValidMessageSignature(args: IsValidMessageSignatureArgs, headers?: object, signal?: AbortSignal): Promise<IsValidMessageSignatureReturn>;
    isValidTypedDataSignature(args: IsValidTypedDataSignatureArgs, headers?: object, signal?: AbortSignal): Promise<IsValidTypedDataSignatureReturn>;
    isValidETHAuthProof(args: IsValidETHAuthProofArgs, headers?: object, signal?: AbortSignal): Promise<IsValidETHAuthProofReturn>;
    getCoinPrices(args: GetCoinPricesArgs, headers?: object, signal?: AbortSignal): Promise<GetCoinPricesReturn>;
    getCollectiblePrices(args: GetCollectiblePricesArgs, headers?: object, signal?: AbortSignal): Promise<GetCollectiblePricesReturn>;
    getExchangeRate(args: GetExchangeRateArgs, headers?: object, signal?: AbortSignal): Promise<GetExchangeRateReturn>;
    memoryStore(args: MemoryStoreArgs, headers?: object, signal?: AbortSignal): Promise<MemoryStoreReturn>;
    memoryLoad(args: MemoryLoadArgs, headers?: object, signal?: AbortSignal): Promise<MemoryLoadReturn>;
    getInviteInfo(headers?: object, signal?: AbortSignal): Promise<GetInviteInfoReturn>;
    isValidAccessCode(args: IsValidAccessCodeArgs, headers?: object, signal?: AbortSignal): Promise<IsValidAccessCodeReturn>;
    internalClaimAccessCode(args: InternalClaimAccessCodeArgs, headers?: object, signal?: AbortSignal): Promise<InternalClaimAccessCodeReturn>;
    blockNumberAtTime(args: BlockNumberAtTimeArgs, headers?: object, signal?: AbortSignal): Promise<BlockNumberAtTimeReturn>;
    paperSessionSecret(args: PaperSessionSecretArgs, headers?: object, signal?: AbortSignal): Promise<PaperSessionSecretReturn>;
    paperSessionSecret2(args: PaperSessionSecret2Args, headers?: object, signal?: AbortSignal): Promise<PaperSessionSecret2Return>;
    linkWallet(args: LinkWalletArgs, headers?: object, signal?: AbortSignal): Promise<LinkWalletReturn>;
    getLinkedWallets(args: GetLinkedWalletsArgs, headers?: object, signal?: AbortSignal): Promise<GetLinkedWalletsReturn>;
    removeLinkedWallet(args: RemoveLinkedWalletArgs, headers?: object, signal?: AbortSignal): Promise<RemoveLinkedWalletReturn>;
    generateWaaSVerificationURL(args: GenerateWaaSVerificationURLArgs, headers?: object, signal?: AbortSignal): Promise<GenerateWaaSVerificationURLReturn>;
    validateWaaSVerificationNonce(args: ValidateWaaSVerificationNonceArgs, headers?: object, signal?: AbortSignal): Promise<ValidateWaaSVerificationNonceReturn>;
    getSwapQuotes(args: GetSwapQuotesArgs, headers?: object, signal?: AbortSignal): Promise<GetSwapQuotesReturn>;
    addCurrencyGroup(args: AddCurrencyGroupArgs, headers?: object, signal?: AbortSignal): Promise<AddCurrencyGroupReturn>;
    updateCurrencyGroup(args: UpdateCurrencyGroupArgs, headers?: object, signal?: AbortSignal): Promise<UpdateCurrencyGroupReturn>;
    listCurrencyGroups(headers?: object, signal?: AbortSignal): Promise<ListCurrencyGroupsReturn>;
    deleteCurrencyGroup(args: DeleteCurrencyGroupArgs, headers?: object, signal?: AbortSignal): Promise<DeleteCurrencyGroupReturn>;
    addInventoryPaymentConfig(args: AddInventoryPaymentConfigArgs, headers?: object, signal?: AbortSignal): Promise<AddInventoryPaymentConfigReturn>;
    getInventoryPaymentConfig(args: GetInventoryPaymentConfigArgs, headers?: object, signal?: AbortSignal): Promise<GetInventoryPaymentConfigReturn>;
    listInventoryPaymentConfigs(args: ListInventoryPaymentConfigsArgs, headers?: object, signal?: AbortSignal): Promise<ListInventoryPaymentConfigsReturn>;
    updateInventoryPaymentConfig(args: UpdateInventoryPaymentConfigArgs, headers?: object, signal?: AbortSignal): Promise<UpdateInventoryPaymentConfigReturn>;
    deleteInventoryPaymentConfig(args: DeleteInventoryPaymentConfigArgs, headers?: object, signal?: AbortSignal): Promise<DeleteInventoryPaymentConfigReturn>;
    requestInventoryPayment(args: RequestInventoryPaymentArgs, headers?: object, signal?: AbortSignal): Promise<RequestInventoryPaymentReturn>;
}
export interface PingArgs {
}
export interface PingReturn {
    status: boolean;
}
export interface VersionArgs {
}
export interface VersionReturn {
    version: Version;
}
export interface RuntimeStatusArgs {
}
export interface RuntimeStatusReturn {
    status: RuntimeStatus;
}
export interface ClockArgs {
}
export interface ClockReturn {
    serverTime: string;
}
export interface GetSequenceContextArgs {
}
export interface GetSequenceContextReturn {
    data: SequenceContext;
}
export interface GetAuthTokenArgs {
    ewtString: string;
    testnetMode?: boolean;
}
export interface GetAuthTokenReturn {
    status: boolean;
    jwtToken: string;
    address: string;
    user?: User;
}
export interface GetAuthToken2Args {
    ewtString: string;
    chainID: string;
}
export interface GetAuthToken2Return {
    status: boolean;
    jwtToken: string;
    address: string;
    user?: User;
}
export interface SendPasswordlessLinkArgs {
    email: string;
    redirectUri: string;
    intent: string;
}
export interface SendPasswordlessLinkReturn {
    status: boolean;
}
export interface FriendListArgs {
    nickname?: string;
    page?: Page;
}
export interface FriendListReturn {
    page: Page;
    friends: Array<Friend>;
}
export interface GetFriendByAddressArgs {
    friendAddress: string;
}
export interface GetFriendByAddressReturn {
    status: boolean;
    friend: Friend;
}
export interface SearchFriendsArgs {
    filterUsername: string;
    page?: Page;
}
export interface SearchFriendsReturn {
    friends: Array<Friend>;
}
export interface AddFriendArgs {
    friendAddress: string;
    optionalNickname?: string;
}
export interface AddFriendReturn {
    status: boolean;
    friend?: Friend;
}
export interface UpdateFriendNicknameArgs {
    friendAddress: string;
    nickname: string;
}
export interface UpdateFriendNicknameReturn {
    status: boolean;
    friend?: Friend;
}
export interface RemoveFriendArgs {
    friendAddress: string;
}
export interface RemoveFriendReturn {
    status: boolean;
}
export interface ContractCallArgs {
    chainID: string;
    contract: string;
    inputExpr: string;
    outputExpr: string;
    args: Array<string>;
}
export interface ContractCallReturn {
    returns: Array<string>;
}
export interface DecodeContractCallArgs {
    callData: string;
}
export interface DecodeContractCallReturn {
    call: ContractCall;
}
export interface LookupContractCallSelectorsArgs {
    selectors: Array<string>;
}
export interface LookupContractCallSelectorsReturn {
    signatures: Array<Array<string>>;
}
export interface UserStorageFetchArgs {
    key: string;
}
export interface UserStorageFetchReturn {
    object: any;
}
export interface UserStorageSaveArgs {
    key: string;
    object: any;
}
export interface UserStorageSaveReturn {
    ok: boolean;
}
export interface UserStorageDeleteArgs {
    key: string;
}
export interface UserStorageDeleteReturn {
    ok: boolean;
}
export interface UserStorageFetchAllArgs {
    keys?: Array<string>;
}
export interface UserStorageFetchAllReturn {
    objects: {
        [key: string]: any;
    };
}
export interface GetMoonpayLinkArgs {
    url: string;
}
export interface GetMoonpayLinkReturn {
    signedUrl: string;
}
export interface GetSardineClientTokenArgs {
}
export interface GetSardineClientTokenReturn {
    token: string;
}
export interface GetSardineNFTCheckoutTokenArgs {
    params: NftCheckoutParams;
}
export interface GetSardineNFTCheckoutTokenReturn {
    resp: NftCheckout;
}
export interface GetSardineNFTCheckoutOrderStatusArgs {
    orderId: string;
}
export interface GetSardineNFTCheckoutOrderStatusReturn {
    resp: SardineOrder;
}
export interface ResolveENSAddressArgs {
    ens: string;
}
export interface ResolveENSAddressReturn {
    address: string;
    ok: boolean;
}
export interface IsValidSignatureArgs {
    chainId: string;
    walletAddress: string;
    digest: string;
    signature: string;
}
export interface IsValidSignatureReturn {
    isValid: boolean;
}
export interface IsValidMessageSignatureArgs {
    chainId: string;
    walletAddress: string;
    message: string;
    signature: string;
}
export interface IsValidMessageSignatureReturn {
    isValid: boolean;
}
export interface IsValidTypedDataSignatureArgs {
    chainId: string;
    walletAddress: string;
    typedData: any;
    signature: string;
}
export interface IsValidTypedDataSignatureReturn {
    isValid: boolean;
}
export interface IsValidETHAuthProofArgs {
    chainId: string;
    walletAddress: string;
    ethAuthProofString: string;
}
export interface IsValidETHAuthProofReturn {
    isValid: boolean;
}
export interface GetCoinPricesArgs {
    tokens: Array<Token>;
}
export interface GetCoinPricesReturn {
    tokenPrices: Array<TokenPrice>;
}
export interface GetCollectiblePricesArgs {
    tokens: Array<Token>;
}
export interface GetCollectiblePricesReturn {
    tokenPrices: Array<TokenPrice>;
}
export interface GetExchangeRateArgs {
    toCurrency: string;
}
export interface GetExchangeRateReturn {
    exchangeRate: ExchangeRate;
}
export interface MemoryStoreArgs {
    key: string;
    value: string;
}
export interface MemoryStoreReturn {
    ok: boolean;
}
export interface MemoryLoadArgs {
    key: string;
}
export interface MemoryLoadReturn {
    value: string;
}
export interface GetInviteInfoArgs {
}
export interface GetInviteInfoReturn {
    inviteInfo: InviteInfo;
}
export interface IsValidAccessCodeArgs {
    accessCode: string;
}
export interface IsValidAccessCodeReturn {
    status: boolean;
}
export interface InternalClaimAccessCodeArgs {
    address: string;
    accessCode: string;
}
export interface InternalClaimAccessCodeReturn {
    status: boolean;
}
export interface BlockNumberAtTimeArgs {
    chainId: number;
    timestamps: Array<number>;
}
export interface BlockNumberAtTimeReturn {
    blocks: Array<number>;
}
export interface PaperSessionSecretArgs {
    chainName: string;
    contractAddress: string;
    paramsJson: string;
    contractType: string;
}
export interface PaperSessionSecretReturn {
    secret: string;
}
export interface PaperSessionSecret2Args {
    chainName: string;
    contractAddress: string;
    paramsJson: string;
    abi: string;
}
export interface PaperSessionSecret2Return {
    secret: string;
}
export interface LinkWalletArgs {
    chainId: string;
    walletAddress: string;
    ethAuthProofString: string;
    linkedWalletMessage: string;
    linkedWalletSignature: string;
}
export interface LinkWalletReturn {
    status: boolean;
    linkedWalletAddress: string;
}
export interface GetLinkedWalletsArgs {
    walletAddress: string;
}
export interface GetLinkedWalletsReturn {
    linkedWallets: Array<string>;
}
export interface RemoveLinkedWalletArgs {
    chainId: string;
    walletAddress: string;
    ethAuthProofString: string;
    linkedWalletMessage: string;
    linkedWalletSignature: string;
}
export interface RemoveLinkedWalletReturn {
    status: boolean;
}
export interface GenerateWaaSVerificationURLArgs {
    walletAddress: string;
}
export interface GenerateWaaSVerificationURLReturn {
    nonce: string;
    verificationURL: string;
}
export interface ValidateWaaSVerificationNonceArgs {
    nonce: string;
    signature: string;
    sessionId: string;
    chainId: string;
}
export interface ValidateWaaSVerificationNonceReturn {
    walletAddress: string;
}
export interface GetSwapQuotesArgs {
    userAddress: string;
    currencyAddress: string;
    currencyAmount: string;
    chainId: number;
    includeApprove: boolean;
}
export interface GetSwapQuotesReturn {
    swapQuotes: Array<SwapQuote>;
}
export interface AddCurrencyGroupArgs {
    currencyGroup: CurrencyGroup;
}
export interface AddCurrencyGroupReturn {
    groupId: number;
}
export interface UpdateCurrencyGroupArgs {
    currencyGroup: CurrencyGroup;
}
export interface UpdateCurrencyGroupReturn {
}
export interface ListCurrencyGroupsArgs {
}
export interface ListCurrencyGroupsReturn {
    currencyGroups: Array<CurrencyGroup>;
}
export interface DeleteCurrencyGroupArgs {
    groupId: number;
}
export interface DeleteCurrencyGroupReturn {
    ok: boolean;
}
export interface AddInventoryPaymentConfigArgs {
    config: InventoryPaymentConfig;
}
export interface AddInventoryPaymentConfigReturn {
    configId: number;
}
export interface GetInventoryPaymentConfigArgs {
    configId: number;
}
export interface GetInventoryPaymentConfigReturn {
    config: InventoryPaymentConfig;
}
export interface ListInventoryPaymentConfigsArgs {
    projectId: number;
}
export interface ListInventoryPaymentConfigsReturn {
    configs: Array<InventoryPaymentConfig>;
}
export interface UpdateInventoryPaymentConfigArgs {
    config: InventoryPaymentConfig;
}
export interface UpdateInventoryPaymentConfigReturn {
}
export interface DeleteInventoryPaymentConfigArgs {
    configId: number;
}
export interface DeleteInventoryPaymentConfigReturn {
    ok: boolean;
}
export interface RequestInventoryPaymentArgs {
    configId: number;
    recipient: string;
    chainId?: number;
    tokenAddress?: string;
}
export interface RequestInventoryPaymentReturn {
    payment: InventoryPaymentResponse;
}
export declare class API implements API {
    protected hostname: string;
    protected fetch: Fetch;
    protected path: string;
    constructor(hostname: string, fetch: Fetch);
    private url;
    ping: (headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<PingReturn>;
    version: (headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<VersionReturn>;
    runtimeStatus: (headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<RuntimeStatusReturn>;
    clock: (headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<ClockReturn>;
    getSequenceContext: (headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<GetSequenceContextReturn>;
    getAuthToken: (args: GetAuthTokenArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<GetAuthTokenReturn>;
    getAuthToken2: (args: GetAuthToken2Args, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<GetAuthToken2Return>;
    sendPasswordlessLink: (args: SendPasswordlessLinkArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<SendPasswordlessLinkReturn>;
    friendList: (args: FriendListArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<FriendListReturn>;
    getFriendByAddress: (args: GetFriendByAddressArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<GetFriendByAddressReturn>;
    searchFriends: (args: SearchFriendsArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<SearchFriendsReturn>;
    addFriend: (args: AddFriendArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<AddFriendReturn>;
    updateFriendNickname: (args: UpdateFriendNicknameArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<UpdateFriendNicknameReturn>;
    removeFriend: (args: RemoveFriendArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<RemoveFriendReturn>;
    contractCall: (args: ContractCallArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<ContractCallReturn>;
    decodeContractCall: (args: DecodeContractCallArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<DecodeContractCallReturn>;
    lookupContractCallSelectors: (args: LookupContractCallSelectorsArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<LookupContractCallSelectorsReturn>;
    userStorageFetch: (args: UserStorageFetchArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<UserStorageFetchReturn>;
    userStorageSave: (args: UserStorageSaveArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<UserStorageSaveReturn>;
    userStorageDelete: (args: UserStorageDeleteArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<UserStorageDeleteReturn>;
    userStorageFetchAll: (args: UserStorageFetchAllArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<UserStorageFetchAllReturn>;
    getMoonpayLink: (args: GetMoonpayLinkArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<GetMoonpayLinkReturn>;
    getSardineClientToken: (headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<GetSardineClientTokenReturn>;
    getSardineNFTCheckoutToken: (args: GetSardineNFTCheckoutTokenArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<GetSardineNFTCheckoutTokenReturn>;
    getSardineNFTCheckoutOrderStatus: (args: GetSardineNFTCheckoutOrderStatusArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<GetSardineNFTCheckoutOrderStatusReturn>;
    resolveENSAddress: (args: ResolveENSAddressArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<ResolveENSAddressReturn>;
    isValidSignature: (args: IsValidSignatureArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<IsValidSignatureReturn>;
    isValidMessageSignature: (args: IsValidMessageSignatureArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<IsValidMessageSignatureReturn>;
    isValidTypedDataSignature: (args: IsValidTypedDataSignatureArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<IsValidTypedDataSignatureReturn>;
    isValidETHAuthProof: (args: IsValidETHAuthProofArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<IsValidETHAuthProofReturn>;
    getCoinPrices: (args: GetCoinPricesArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<GetCoinPricesReturn>;
    getCollectiblePrices: (args: GetCollectiblePricesArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<GetCollectiblePricesReturn>;
    getExchangeRate: (args: GetExchangeRateArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<GetExchangeRateReturn>;
    memoryStore: (args: MemoryStoreArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<MemoryStoreReturn>;
    memoryLoad: (args: MemoryLoadArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<MemoryLoadReturn>;
    getInviteInfo: (headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<GetInviteInfoReturn>;
    isValidAccessCode: (args: IsValidAccessCodeArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<IsValidAccessCodeReturn>;
    internalClaimAccessCode: (args: InternalClaimAccessCodeArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<InternalClaimAccessCodeReturn>;
    blockNumberAtTime: (args: BlockNumberAtTimeArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<BlockNumberAtTimeReturn>;
    paperSessionSecret: (args: PaperSessionSecretArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<PaperSessionSecretReturn>;
    paperSessionSecret2: (args: PaperSessionSecret2Args, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<PaperSessionSecret2Return>;
    linkWallet: (args: LinkWalletArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<LinkWalletReturn>;
    getLinkedWallets: (args: GetLinkedWalletsArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<GetLinkedWalletsReturn>;
    removeLinkedWallet: (args: RemoveLinkedWalletArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<RemoveLinkedWalletReturn>;
    generateWaaSVerificationURL: (args: GenerateWaaSVerificationURLArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<GenerateWaaSVerificationURLReturn>;
    validateWaaSVerificationNonce: (args: ValidateWaaSVerificationNonceArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<ValidateWaaSVerificationNonceReturn>;
    getSwapQuotes: (args: GetSwapQuotesArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<GetSwapQuotesReturn>;
    addCurrencyGroup: (args: AddCurrencyGroupArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<AddCurrencyGroupReturn>;
    updateCurrencyGroup: (args: UpdateCurrencyGroupArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<UpdateCurrencyGroupReturn>;
    listCurrencyGroups: (headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<ListCurrencyGroupsReturn>;
    deleteCurrencyGroup: (args: DeleteCurrencyGroupArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<DeleteCurrencyGroupReturn>;
    addInventoryPaymentConfig: (args: AddInventoryPaymentConfigArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<AddInventoryPaymentConfigReturn>;
    getInventoryPaymentConfig: (args: GetInventoryPaymentConfigArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<GetInventoryPaymentConfigReturn>;
    listInventoryPaymentConfigs: (args: ListInventoryPaymentConfigsArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<ListInventoryPaymentConfigsReturn>;
    updateInventoryPaymentConfig: (args: UpdateInventoryPaymentConfigArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<UpdateInventoryPaymentConfigReturn>;
    deleteInventoryPaymentConfig: (args: DeleteInventoryPaymentConfigArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<DeleteInventoryPaymentConfigReturn>;
    requestInventoryPayment: (args: RequestInventoryPaymentArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<RequestInventoryPaymentReturn>;
}
export declare class WebrpcError extends Error {
    name: string;
    code: number;
    message: string;
    status: number;
    cause?: string;
    /** @deprecated Use message instead of msg. Deprecated in webrpc v0.11.0. */
    msg: string;
    constructor(name: string, code: number, message: string, status: number, cause?: string);
    static new(payload: any): WebrpcError;
}
export declare class WebrpcEndpointError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class WebrpcRequestFailedError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class WebrpcBadRouteError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class WebrpcBadMethodError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class WebrpcBadRequestError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class WebrpcBadResponseError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class WebrpcServerPanicError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class WebrpcInternalErrorError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class WebrpcClientDisconnectedError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class WebrpcStreamLostError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class WebrpcStreamFinishedError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class UnauthorizedError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class PermissionDeniedError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class SessionExpiredError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class AbortedError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class GeoblockedError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class InvalidArgumentError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class UnavailableError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class QueryFailedError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class NotFoundError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare enum errors {
    WebrpcEndpoint = "WebrpcEndpoint",
    WebrpcRequestFailed = "WebrpcRequestFailed",
    WebrpcBadRoute = "WebrpcBadRoute",
    WebrpcBadMethod = "WebrpcBadMethod",
    WebrpcBadRequest = "WebrpcBadRequest",
    WebrpcBadResponse = "WebrpcBadResponse",
    WebrpcServerPanic = "WebrpcServerPanic",
    WebrpcInternalError = "WebrpcInternalError",
    WebrpcClientDisconnected = "WebrpcClientDisconnected",
    WebrpcStreamLost = "WebrpcStreamLost",
    WebrpcStreamFinished = "WebrpcStreamFinished",
    Unauthorized = "Unauthorized",
    PermissionDenied = "PermissionDenied",
    SessionExpired = "SessionExpired",
    Aborted = "Aborted",
    Geoblocked = "Geoblocked",
    InvalidArgument = "InvalidArgument",
    Unavailable = "Unavailable",
    QueryFailed = "QueryFailed",
    NotFound = "NotFound"
}
export type Fetch = (input: RequestInfo, init?: RequestInit) => Promise<Response>;
