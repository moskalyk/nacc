import { ChainId } from '@0xsequence/network';
import { Account } from "./account.js";
import { ethers } from 'ethers';
import { commons } from '@0xsequence/core';
import { FeeOption } from '@0xsequence/relayer';
export type AccountSignerOptions = {
    nonceSpace?: ethers.BigNumberish;
    cantValidateBehavior?: 'ignore' | 'eip6492' | 'throw';
    stubSignatureOverrides?: Map<string, string>;
    selectFee?: (txs: ethers.TransactionRequest | commons.transaction.Transactionish, options: FeeOption[]) => Promise<FeeOption | undefined>;
};
export declare class AccountSigner implements ethers.AbstractSigner<ethers.Provider> {
    account: Account;
    chainId: ChainId;
    readonly options?: AccountSignerOptions | undefined;
    constructor(account: Account, chainId: ChainId, options?: AccountSignerOptions | undefined);
    get provider(): ethers.Provider;
    getAddress(): Promise<string>;
    signMessage(message: string | ethers.BytesLike): Promise<string>;
    signTypedData(domain: ethers.TypedDataDomain, types: Record<string, Array<ethers.TypedDataField>>, value: Record<string, any>): Promise<string>;
    private defaultSelectFee;
    sendTransaction(txs: commons.transaction.Transactionish, options?: {
        simulateForFeeOptions?: boolean;
    }): Promise<ethers.TransactionResponse>;
    getBalance(blockTag?: ethers.BlockTag | undefined): Promise<bigint>;
    call(transaction: ethers.TransactionRequest, blockTag?: ethers.BlockTag): Promise<string>;
    resolveName(name: string): Promise<string>;
    connect(_provider: ethers.Provider): ethers.Signer;
    signTransaction(transaction: ethers.TransactionRequest): Promise<string>;
    getTransactionCount(blockTag?: ethers.BlockTag | undefined): Promise<number>;
    estimateGas(transaction: ethers.TransactionRequest): Promise<bigint>;
    getChainId(): Promise<number>;
    getGasPrice(): Promise<bigint>;
    getFeeData(): Promise<ethers.FeeData>;
    getNonce(blockTag?: ethers.BlockTag): Promise<number>;
    populateCall(tx: ethers.TransactionRequest): Promise<ethers.TransactionLike<string>>;
    checkTransaction(transaction: ethers.TransactionRequest): ethers.TransactionRequest;
    populateTransaction(tx: ethers.TransactionRequest): Promise<ethers.TransactionLike<string>>;
    _checkProvider(operation?: string | undefined): void;
}
