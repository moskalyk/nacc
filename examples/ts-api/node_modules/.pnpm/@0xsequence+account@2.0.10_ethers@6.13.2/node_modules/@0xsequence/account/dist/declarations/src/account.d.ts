import { commons } from '@0xsequence/core';
import { migrator } from '@0xsequence/migration';
import { ChainId, NetworkConfig } from '@0xsequence/network';
import { FeeOption, FeeQuote, Relayer } from '@0xsequence/relayer';
import { tracker } from '@0xsequence/sessions';
import { SignatureOrchestrator } from '@0xsequence/signhub';
import { Wallet } from '@0xsequence/wallet';
import { ethers } from 'ethers';
import { AccountSigner, AccountSignerOptions } from "./signer.js";
export type AccountStatus = {
    original: {
        version: number;
        imageHash: string;
        context: commons.context.WalletContext;
    };
    onChain: {
        imageHash: string;
        config: commons.config.Config;
        version: number;
        deployed: boolean;
    };
    fullyMigrated: boolean;
    signedMigrations: migrator.SignedMigration[];
    version: number;
    presignedConfigurations: tracker.PresignedConfigLink[];
    imageHash: string;
    config: commons.config.Config;
    checkpoint: ethers.BigNumberish;
    canOnchainValidate: boolean;
};
export type AccountOptions = {
    address: string;
    tracker: tracker.ConfigTracker & migrator.PresignedMigrationTracker;
    contexts: commons.context.VersionedContext;
    migrations?: migrator.Migrations;
    orchestrator: SignatureOrchestrator;
    networks: NetworkConfig[];
    jwt?: string;
    projectAccessKey?: string;
};
export interface PreparedTransactions {
    transactions: commons.transaction.SimulatedTransaction[];
    flatDecorated: commons.transaction.Transaction[];
    feeOptions: FeeOption[];
    feeQuote?: FeeQuote;
}
export declare class Account {
    readonly address: string;
    readonly networks: NetworkConfig[];
    readonly tracker: tracker.ConfigTracker & migrator.PresignedMigrationTracker;
    readonly contexts: commons.context.VersionedContext;
    readonly migrator: migrator.Migrator;
    readonly migrations: migrator.Migrations;
    private orchestrator;
    private jwt?;
    private projectAccessKey?;
    constructor(options: AccountOptions);
    getSigner(chainId: ChainId, options?: AccountSignerOptions): AccountSigner;
    static new(options: {
        config: commons.config.SimpleConfig;
        tracker: tracker.ConfigTracker & migrator.PresignedMigrationTracker;
        contexts: commons.context.VersionedContext;
        orchestrator: SignatureOrchestrator;
        networks: NetworkConfig[];
        migrations?: migrator.Migrations;
        projectAccessKey?: string;
    }): Promise<Account>;
    getAddress(): Promise<string>;
    get version(): number;
    get coders(): {
        signature: commons.signature.SignatureCoder;
        config: commons.config.ConfigCoder;
    };
    network(chainId: ethers.BigNumberish): NetworkConfig;
    providerFor(chainId: ethers.BigNumberish): ethers.Provider;
    reader(chainId: ethers.BigNumberish): commons.reader.Reader;
    relayer(chainId: ethers.BigNumberish): Relayer;
    setOrchestrator(orchestrator: SignatureOrchestrator): void;
    setJwt(jwt: string): void;
    contextFor(version: number): commons.context.WalletContext;
    walletForStatus(chainId: ethers.BigNumberish, status: Pick<AccountStatus, 'version'> & Pick<AccountStatus, 'config'>): Wallet;
    walletFor(chainId: ethers.BigNumberish, context: commons.context.WalletContext, config: commons.config.Config, coders: typeof this.coders): Wallet;
    status(chainId: ethers.BigNumberish, longestPath?: boolean): Promise<AccountStatus>;
    private mustBeFullyMigrated;
    predecorateSignedTransactions(status: AccountStatus, chainId: ethers.BigNumberish): Promise<commons.transaction.SignedTransactionBundle[]>;
    predecorateTransactions(txs: commons.transaction.Transactionish, status: AccountStatus, chainId: ethers.BigNumberish): Promise<commons.transaction.Transactionish>;
    decorateTransactions(bundles: commons.transaction.IntendedTransactionBundle | commons.transaction.IntendedTransactionBundle[], status: AccountStatus, chainId?: ethers.BigNumberish): Promise<commons.transaction.IntendedTransactionBundle>;
    decorateSignature<T extends ethers.BytesLike>(signature: T, status: Partial<Pick<AccountStatus, 'presignedConfigurations'>>): Promise<T | string>;
    publishWitness(): Promise<void>;
    signDigest(digest: ethers.BytesLike, chainId: ethers.BigNumberish, decorate?: boolean, cantValidateBehavior?: 'ignore' | 'eip6492' | 'throw', metadata?: object): Promise<string>;
    buildOnChainSignature(digest: ethers.BytesLike): {
        bundle: commons.transaction.TransactionBundle;
        signature: string;
    };
    private buildEIP6492Signature;
    editConfig(changes: {
        add?: commons.config.SimpleSigner[];
        remove?: string[];
        threshold?: ethers.BigNumberish;
    }): Promise<void>;
    updateConfig(config: commons.config.Config): Promise<void>;
    /**
     *  This method is used to bootstrap the wallet on a given chain.
     *  this deploys the wallets and executes all the necessary transactions
     *  for that wallet to start working with the given version.
     *
     *  This usually involves: (a) deploying the wallet, (b) executing migrations
     *
     *  Notice: It should NOT explicitly include chained signatures. Unless internally used
     *  by any of the migrations.
     *
     */
    buildBootstrapTransactions(status: AccountStatus, chainId: ethers.BigNumberish): Promise<commons.transaction.IntendedTransactionBundle>;
    bootstrapTransactions(chainId: ethers.BigNumberish, prestatus?: AccountStatus): Promise<Omit<commons.transaction.IntendedTransactionBundle, 'chainId'>>;
    doBootstrap(chainId: ethers.BigNumberish, feeQuote?: FeeQuote, prestatus?: AccountStatus): Promise<commons.transaction.TransactionResponse<any>>;
    signMessage(message: ethers.BytesLike, chainId: ethers.BigNumberish, cantValidateBehavior?: 'ignore' | 'eip6492' | 'throw'): Promise<string>;
    signTransactions(txs: commons.transaction.Transactionish, chainId: ethers.BigNumberish, pstatus?: AccountStatus, options?: {
        nonceSpace?: ethers.BigNumberish;
        serial?: boolean;
    }): Promise<commons.transaction.SignedTransactionBundle>;
    signMigrations(chainId: ethers.BigNumberish, editConfig: (prevConfig: commons.config.Config) => commons.config.Config): Promise<boolean>;
    signAllMigrations(editConfig: (prevConfig: commons.config.Config) => commons.config.Config): Promise<{
        signedMigrations: Array<any>;
        failedChains: number[];
    }>;
    isMigratedAllChains(): Promise<{
        migratedAllChains: boolean;
        failedChains: number[];
    }>;
    sendSignedTransactions(signedBundle: commons.transaction.IntendedTransactionBundle | commons.transaction.IntendedTransactionBundle[], chainId: ethers.BigNumberish, quote?: FeeQuote, pstatus?: AccountStatus, callback?: (bundle: commons.transaction.IntendedTransactionBundle) => void): Promise<ethers.TransactionResponse>;
    fillGasLimits(txs: commons.transaction.Transactionish, chainId: ethers.BigNumberish, status?: AccountStatus): Promise<commons.transaction.SimulatedTransaction[]>;
    gasRefundQuotes(txs: commons.transaction.Transactionish, chainId: ethers.BigNumberish, stubSignatureOverrides: Map<string, string>, status?: AccountStatus, options?: {
        simulate?: boolean;
    }): Promise<{
        options: FeeOption[];
        quote?: FeeQuote;
        decorated: commons.transaction.IntendedTransactionBundle;
    }>;
    prepareTransactions(args: {
        txs: commons.transaction.Transactionish;
        chainId: ethers.BigNumberish;
        stubSignatureOverrides: Map<string, string>;
        simulateForFeeOptions?: boolean;
    }): Promise<PreparedTransactions>;
    sendTransaction(txs: commons.transaction.Transactionish, chainId: ethers.BigNumberish, quote?: FeeQuote, skipPreDecorate?: boolean, callback?: (bundle: commons.transaction.IntendedTransactionBundle) => void, options?: {
        nonceSpace?: ethers.BigNumberish;
        serial?: boolean;
    }): Promise<ethers.TransactionResponse | undefined>;
    signTypedData(domain: ethers.TypedDataDomain, types: Record<string, Array<ethers.TypedDataField>>, message: Record<string, any>, chainId: ethers.BigNumberish, cantValidateBehavior?: 'ignore' | 'eip6492' | 'throw'): Promise<string>;
    getSigners(): Promise<Array<{
        address: string;
        network: ChainId;
        weight: number;
    }>>;
    getAllSigners(): Promise<{
        address: string;
        weight: number;
        network: number;
        flaggedForRemoval: boolean;
    }[]>;
}
export declare function isAccount(value: any): value is Account;
