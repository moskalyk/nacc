export declare const WebRPCVersion = "v1";
export declare const WebRPCSchemaVersion = "v0.4.0";
export declare const WebRPCSchemaHash = "9d0976f6ff345b6a688b69cff647454e7fd0e3a6";
export declare enum ContractType {
    UNKNOWN = "UNKNOWN",
    ERC20 = "ERC20",
    ERC721 = "ERC721",
    ERC1155 = "ERC1155"
}
export declare enum PropertyType {
    INT = "INT",
    STRING = "STRING",
    ARRAY = "ARRAY",
    GENERIC = "GENERIC"
}
export declare enum SwapType {
    UNKNOWN = "UNKNOWN",
    BUY = "BUY",
    SELL = "SELL"
}
export declare enum TaskStatus {
    PENDING = "PENDING",
    PAUSED = "PAUSED",
    FAILED = "FAILED",
    COMPLETED = "COMPLETED",
    DISABLED = "DISABLED"
}
export interface Version {
    webrpcVersion: string;
    schemaVersion: string;
    schemaHash: string;
    appVersion: string;
}
export interface RuntimeStatus {
    healthOK: boolean;
    startTime: string;
    uptime: number;
    ver: string;
    branch: string;
    commitHash: string;
    checks: RuntimeChecks;
}
export interface RuntimeChecks {
}
export interface ContractIndex {
    chainId: number;
    address: string;
    type: ContractType;
    metadata: {
        [key: string]: any;
    };
    contentHash: number;
    deployed: boolean;
    bytecodeHash: string;
    notFound: boolean;
    updatedAt: string;
}
export interface TokenIndex {
    key: string;
    chainId: number;
    contractAddress: string;
    tokenId: string;
    metadata: {
        [key: string]: any;
    };
    notFound?: boolean;
    lastFetched?: string;
    fetchCount?: number;
    updatedAt: string;
}
export interface ContractInfo {
    chainId: number;
    address: string;
    name: string;
    type: string;
    symbol: string;
    decimals?: number;
    logoURI: string;
    deployed: boolean;
    bytecodeHash: string;
    extensions: ContractInfoExtensions;
    updatedAt: string;
}
export interface ContractInfoExtensions {
    link: string;
    description: string;
    ogImage: string;
    ogName: string;
    originChainId: number;
    originAddress: string;
    blacklist: boolean;
    verified: boolean;
    verifiedBy: string;
    featured: boolean;
    private: boolean;
}
export interface TokenMetadata {
    tokenId: string;
    name: string;
    description?: string;
    image?: string;
    video?: string;
    audio?: string;
    properties?: {
        [key: string]: any;
    };
    attributes: Array<{
        [key: string]: any;
    }>;
    image_data?: string;
    external_url?: string;
    background_color?: string;
    animation_url?: string;
    decimals?: number;
    updatedAt?: string;
    assets?: Array<Asset>;
}
export interface PropertyFilter {
    name: string;
    type: PropertyType;
    min?: number;
    max?: number;
    values?: Array<any>;
}
export interface Filter {
    text?: string;
    properties?: Array<PropertyFilter>;
}
export interface Collection {
    id: number;
    projectId: number;
    metadata: CollectionMetadata;
    private: boolean;
    revealKey?: string;
    tokenCount?: number;
    createdAt?: string;
    updatedAt?: string;
    deletedAt?: string;
    baseURIs?: CollectionBaseURIs;
    assets?: Array<Asset>;
}
export interface CollectionMetadata {
    name: string;
    description?: string;
    image?: string;
    external_link?: string;
    properties?: {
        [key: string]: any;
    };
    attributes?: Array<{
        [key: string]: any;
    }>;
}
export interface CollectionBaseURIs {
    contractMetadataURI: string;
    tokenMetadataURI: string;
}
export interface ContractCollection {
    id: number;
    chainId: number;
    contractAddress: string;
    collectionId: number;
}
export interface Asset {
    id: number;
    collectionId: number;
    tokenId?: string;
    url?: string;
    metadataField: string;
    name?: string;
    filesize?: number;
    mimeType?: string;
    width?: number;
    height?: number;
    updatedAt?: string;
}
export interface Token {
    collectionId: number;
    tokenId: string;
    metadata: TokenMetadata;
    private: boolean;
    updatedAt?: string;
}
export interface GetNiftyswapUnitPricesRequest {
    swapType: SwapType;
    ids: Array<string>;
    amounts: Array<string>;
}
export interface GetNiftyswapUnitPricesResponse {
    unitPrice: string;
    unitAmount: string;
    availableAmount: string;
}
export interface Page {
    page?: number;
    column?: string;
    before?: any;
    after?: any;
    pageSize?: number;
    more?: boolean;
}
export interface TaskRunner {
    id: number;
    workGroup: string;
    runAt: string;
}
export interface Task {
    id: number;
    queue: string;
    status?: TaskStatus;
    try: number;
    runAt?: string;
    lastRanAt?: string;
    createdAt?: string;
    payload: Array<string>;
    hash?: string;
}
export interface Metadata {
    ping(headers?: object, signal?: AbortSignal): Promise<PingReturn>;
    version(headers?: object, signal?: AbortSignal): Promise<VersionReturn>;
    runtimeStatus(headers?: object, signal?: AbortSignal): Promise<RuntimeStatusReturn>;
    getTokenMetadata(args: GetTokenMetadataArgs, headers?: object, signal?: AbortSignal): Promise<GetTokenMetadataReturn>;
    refreshTokenMetadata(args: RefreshTokenMetadataArgs, headers?: object, signal?: AbortSignal): Promise<RefreshTokenMetadataReturn>;
    enqueueTokensForRefresh(args: EnqueueTokensForRefreshArgs, headers?: object, signal?: AbortSignal): Promise<EnqueueTokensForRefreshReturn>;
    getTokenRefreshStatus(args: GetTokenRefreshStatusArgs, headers?: object, signal?: AbortSignal): Promise<GetTokenRefreshStatusReturn>;
    getTokenRefreshResult(args: GetTokenRefreshResultArgs, headers?: object, signal?: AbortSignal): Promise<GetTokenRefreshResultReturn>;
    cancelRefreshJob(args: CancelRefreshJobArgs, headers?: object, signal?: AbortSignal): Promise<CancelRefreshJobReturn>;
    getTokenMetadataBatch(args: GetTokenMetadataBatchArgs, headers?: object, signal?: AbortSignal): Promise<GetTokenMetadataBatchReturn>;
    searchTokenMetadata(args: SearchTokenMetadataArgs, headers?: object, signal?: AbortSignal): Promise<SearchTokenMetadataReturn>;
    searchTokenIDs(args: SearchTokenIDsArgs, headers?: object, signal?: AbortSignal): Promise<SearchTokenIDsReturn>;
    tokenCollectionFilters(args: TokenCollectionFiltersArgs, headers?: object, signal?: AbortSignal): Promise<TokenCollectionFiltersReturn>;
    getContractInfo(args: GetContractInfoArgs, headers?: object, signal?: AbortSignal): Promise<GetContractInfoReturn>;
    getContractInfoBatch(args: GetContractInfoBatchArgs, headers?: object, signal?: AbortSignal): Promise<GetContractInfoBatchReturn>;
    searchContractInfo(args: SearchContractInfoArgs, headers?: object, signal?: AbortSignal): Promise<SearchContractInfoReturn>;
    searchContractInfoBatch(args: SearchContractInfoBatchArgs, headers?: object, signal?: AbortSignal): Promise<SearchContractInfoBatchReturn>;
    searchMetadata(args: SearchMetadataArgs, headers?: object, signal?: AbortSignal): Promise<SearchMetadataReturn>;
    searchTokens(args: SearchTokensArgs, headers?: object, signal?: AbortSignal): Promise<SearchTokensReturn>;
    searchContracts(args: SearchContractsArgs, headers?: object, signal?: AbortSignal): Promise<SearchContractsReturn>;
    getNiftyswapTokenQuantity(args: GetNiftyswapTokenQuantityArgs, headers?: object, signal?: AbortSignal): Promise<GetNiftyswapTokenQuantityReturn>;
    getNiftyswapUnitPrices(args: GetNiftyswapUnitPricesArgs, headers?: object, signal?: AbortSignal): Promise<GetNiftyswapUnitPricesReturn>;
    getNiftyswapUnitPricesWithQuantities(args: GetNiftyswapUnitPricesWithQuantitiesArgs, headers?: object, signal?: AbortSignal): Promise<GetNiftyswapUnitPricesWithQuantitiesReturn>;
    addContractToMintMonitor(args: AddContractToMintMonitorArgs, headers?: object, signal?: AbortSignal): Promise<AddContractToMintMonitorReturn>;
    removeContractFromMintMonitor(args: RemoveContractFromMintMonitorArgs, headers?: object, signal?: AbortSignal): Promise<RemoveContractFromMintMonitorReturn>;
    mintMonitorJobStatus(args: MintMonitorJobStatusArgs, headers?: object, signal?: AbortSignal): Promise<MintMonitorJobStatusReturn>;
    mintMonitorTriggerJob(args: MintMonitorTriggerJobArgs, headers?: object, signal?: AbortSignal): Promise<MintMonitorTriggerJobReturn>;
    syncContractTokens(args: SyncContractTokensArgs, headers?: object, signal?: AbortSignal): Promise<SyncContractTokensReturn>;
    abortContractSync(args: AbortContractSyncArgs, headers?: object, signal?: AbortSignal): Promise<AbortContractSyncReturn>;
    contractSyncJobStatus(args: ContractSyncJobStatusArgs, headers?: object, signal?: AbortSignal): Promise<ContractSyncJobStatusReturn>;
    directoryGetNetworks(args: DirectoryGetNetworksArgs, headers?: object, signal?: AbortSignal): Promise<DirectoryGetNetworksReturn>;
    directoryGetCollections(args: DirectoryGetCollectionsArgs, headers?: object, signal?: AbortSignal): Promise<DirectoryGetCollectionsReturn>;
    directorySearchCollections(args: DirectorySearchCollectionsArgs, headers?: object, signal?: AbortSignal): Promise<DirectorySearchCollectionsReturn>;
}
export interface PingArgs {
}
export interface PingReturn {
    status: boolean;
}
export interface VersionArgs {
}
export interface VersionReturn {
    version: Version;
}
export interface RuntimeStatusArgs {
}
export interface RuntimeStatusReturn {
    status: RuntimeStatus;
}
export interface GetTokenMetadataArgs {
    chainID: string;
    contractAddress: string;
    tokenIDs: Array<string>;
}
export interface GetTokenMetadataReturn {
    tokenMetadata: Array<TokenMetadata>;
}
export interface RefreshTokenMetadataArgs {
    chainID: string;
    contractAddress: string;
    tokenIDs?: Array<string>;
    refreshAll?: boolean;
}
export interface RefreshTokenMetadataReturn {
    taskId: number;
}
export interface EnqueueTokensForRefreshArgs {
    chainID: string;
    contractAddress: string;
    tokenIDs?: Array<string>;
    refreshAll?: boolean;
}
export interface EnqueueTokensForRefreshReturn {
    taskId: number;
}
export interface GetTokenRefreshStatusArgs {
    taskId: number;
}
export interface GetTokenRefreshStatusReturn {
    status?: TaskStatus;
}
export interface GetTokenRefreshResultArgs {
    taskId: number;
}
export interface GetTokenRefreshResultReturn {
    status?: TaskStatus;
    tokens: {
        [key: string]: boolean;
    };
    failureReasons: {
        [key: string]: string;
    };
}
export interface CancelRefreshJobArgs {
    taskId: number;
}
export interface CancelRefreshJobReturn {
    ok: boolean;
}
export interface GetTokenMetadataBatchArgs {
    chainID: string;
    contractTokenMap: {
        [key: string]: Array<string>;
    };
}
export interface GetTokenMetadataBatchReturn {
    contractTokenMetadata: {
        [key: string]: Array<TokenMetadata>;
    };
}
export interface SearchTokenMetadataArgs {
    chainID: string;
    contractAddress: string;
    filter: Filter;
    page?: Page;
}
export interface SearchTokenMetadataReturn {
    page: Page;
    tokenMetadata: Array<TokenMetadata>;
}
export interface SearchTokenIDsArgs {
    chainID: string;
    contractAddress: string;
    filter: Filter;
    page?: Page;
}
export interface SearchTokenIDsReturn {
    page: Page;
    tokenIds: Array<string>;
}
export interface TokenCollectionFiltersArgs {
    chainID: string;
    contractAddress: string;
}
export interface TokenCollectionFiltersReturn {
    filters: Array<PropertyFilter>;
}
export interface GetContractInfoArgs {
    chainID: string;
    contractAddress: string;
}
export interface GetContractInfoReturn {
    contractInfo: ContractInfo;
}
export interface GetContractInfoBatchArgs {
    chainID: string;
    contractAddresses: Array<string>;
}
export interface GetContractInfoBatchReturn {
    contractInfoMap: {
        [key: string]: ContractInfo;
    };
}
export interface SearchContractInfoArgs {
    contractAddress: string;
}
export interface SearchContractInfoReturn {
    contractInfoList: Array<ContractInfo>;
}
export interface SearchContractInfoBatchArgs {
    contractAddresses: Array<string>;
}
export interface SearchContractInfoBatchReturn {
    contractInfoByChain: {
        [key: string]: Array<ContractInfo>;
    };
}
export interface SearchMetadataArgs {
    filter: string;
    chainID?: string;
    types?: Array<ContractType>;
    excludeTokenMetadata?: boolean;
}
export interface SearchMetadataReturn {
    tokenMetadata: Array<TokenMetadata>;
    contractInfo: Array<ContractInfo>;
}
export interface SearchTokensArgs {
    q: string;
    chainID?: string;
    page?: Page;
}
export interface SearchTokensReturn {
    tokenMetadata: Array<TokenMetadata>;
    nextPage: Page;
}
export interface SearchContractsArgs {
    q: string;
    chainID?: string;
    chainIDs?: Array<string>;
    types?: Array<ContractType>;
    page?: Page;
}
export interface SearchContractsReturn {
    contractInfo: Array<ContractInfo>;
    nextPage: Page;
}
export interface GetNiftyswapTokenQuantityArgs {
    chainID: string;
    contractAddress: string;
    tokenIDs: Array<string>;
}
export interface GetNiftyswapTokenQuantityReturn {
    quantity: {
        [key: string]: string;
    };
}
export interface GetNiftyswapUnitPricesArgs {
    chainID: string;
    contractAddress: string;
    req: GetNiftyswapUnitPricesRequest;
    fresh: boolean;
}
export interface GetNiftyswapUnitPricesReturn {
    prices: {
        [key: string]: string;
    };
}
export interface GetNiftyswapUnitPricesWithQuantitiesArgs {
    chainID: string;
    contractAddress: string;
    req: GetNiftyswapUnitPricesRequest;
    fresh: boolean;
}
export interface GetNiftyswapUnitPricesWithQuantitiesReturn {
    prices: {
        [key: string]: GetNiftyswapUnitPricesResponse;
    };
}
export interface AddContractToMintMonitorArgs {
    chainID: string;
    contractAddress: string;
}
export interface AddContractToMintMonitorReturn {
    ok: boolean;
}
export interface RemoveContractFromMintMonitorArgs {
    chainID: string;
    contractAddress: string;
}
export interface RemoveContractFromMintMonitorReturn {
    ok: boolean;
}
export interface MintMonitorJobStatusArgs {
    chainID: string;
    contractAddress: string;
}
export interface MintMonitorJobStatusReturn {
    task: Task;
}
export interface MintMonitorTriggerJobArgs {
    chainID: string;
    contractAddress: string;
}
export interface MintMonitorTriggerJobReturn {
    ok: boolean;
}
export interface SyncContractTokensArgs {
    chainID: string;
    contractAddress: string;
}
export interface SyncContractTokensReturn {
    taskID: number;
}
export interface AbortContractSyncArgs {
    taskID: number;
}
export interface AbortContractSyncReturn {
    ok: boolean;
}
export interface ContractSyncJobStatusArgs {
    taskID: number;
}
export interface ContractSyncJobStatusReturn {
    refreshTask: Task;
    syncTask: Task;
}
export interface DirectoryGetNetworksArgs {
    includeTestnets?: boolean;
    onlyFeatured?: boolean;
}
export interface DirectoryGetNetworksReturn {
    networks: Array<number>;
}
export interface DirectoryGetCollectionsArgs {
    chainId?: number;
    includeTestnets?: boolean;
    onlyFeatured?: boolean;
    page?: Page;
}
export interface DirectoryGetCollectionsReturn {
    collections: Array<ContractInfo>;
    page: Page;
}
export interface DirectorySearchCollectionsArgs {
    query: string;
    chainId?: number;
    includeTestnets?: boolean;
    onlyFeatured?: boolean;
    page?: Page;
}
export interface DirectorySearchCollectionsReturn {
    collections: Array<ContractInfo>;
    page: Page;
}
export interface Collections {
    createCollection(args: CreateCollectionArgs, headers?: object, signal?: AbortSignal): Promise<CreateCollectionReturn>;
    getCollection(args: GetCollectionArgs, headers?: object, signal?: AbortSignal): Promise<GetCollectionReturn>;
    listCollections(args: ListCollectionsArgs, headers?: object, signal?: AbortSignal): Promise<ListCollectionsReturn>;
    updateCollection(args: UpdateCollectionArgs, headers?: object, signal?: AbortSignal): Promise<UpdateCollectionReturn>;
    deleteCollection(args: DeleteCollectionArgs, headers?: object, signal?: AbortSignal): Promise<DeleteCollectionReturn>;
    publishCollection(args: PublishCollectionArgs, headers?: object, signal?: AbortSignal): Promise<PublishCollectionReturn>;
    unpublishCollection(args: UnpublishCollectionArgs, headers?: object, signal?: AbortSignal): Promise<UnpublishCollectionReturn>;
    createContractCollection(args: CreateContractCollectionArgs, headers?: object, signal?: AbortSignal): Promise<CreateContractCollectionReturn>;
    getContractCollection(args: GetContractCollectionArgs, headers?: object, signal?: AbortSignal): Promise<GetContractCollectionReturn>;
    listContractCollections(args: ListContractCollectionsArgs, headers?: object, signal?: AbortSignal): Promise<ListContractCollectionsReturn>;
    updateContractCollection(args: UpdateContractCollectionArgs, headers?: object, signal?: AbortSignal): Promise<UpdateContractCollectionReturn>;
    deleteContractCollection(args: DeleteContractCollectionArgs, headers?: object, signal?: AbortSignal): Promise<DeleteContractCollectionReturn>;
    createToken(args: CreateTokenArgs, headers?: object, signal?: AbortSignal): Promise<CreateTokenReturn>;
    getToken(args: GetTokenArgs, headers?: object, signal?: AbortSignal): Promise<GetTokenReturn>;
    listTokens(args: ListTokensArgs, headers?: object, signal?: AbortSignal): Promise<ListTokensReturn>;
    updateToken(args: UpdateTokenArgs, headers?: object, signal?: AbortSignal): Promise<UpdateTokenReturn>;
    deleteToken(args: DeleteTokenArgs, headers?: object, signal?: AbortSignal): Promise<DeleteTokenReturn>;
    createAsset(args: CreateAssetArgs, headers?: object, signal?: AbortSignal): Promise<CreateAssetReturn>;
    getAsset(args: GetAssetArgs, headers?: object, signal?: AbortSignal): Promise<GetAssetReturn>;
    updateAsset(args: UpdateAssetArgs, headers?: object, signal?: AbortSignal): Promise<UpdateAssetReturn>;
    deleteAsset(args: DeleteAssetArgs, headers?: object, signal?: AbortSignal): Promise<DeleteAssetReturn>;
}
export interface CreateCollectionArgs {
    projectId?: number;
    collection: Collection;
}
export interface CreateCollectionReturn {
    collection: Collection;
}
export interface GetCollectionArgs {
    projectId?: number;
    collectionId: number;
}
export interface GetCollectionReturn {
    collection: Collection;
}
export interface ListCollectionsArgs {
    projectId?: number;
    page?: Page;
}
export interface ListCollectionsReturn {
    page: Page;
    collections: Array<Collection>;
}
export interface UpdateCollectionArgs {
    projectId?: number;
    collection: Collection;
}
export interface UpdateCollectionReturn {
    collection: Collection;
}
export interface DeleteCollectionArgs {
    projectId?: number;
    collectionId: number;
}
export interface DeleteCollectionReturn {
    status: boolean;
}
export interface PublishCollectionArgs {
    projectId?: number;
    collectionId: number;
    recursive?: boolean;
}
export interface PublishCollectionReturn {
    collection: Collection;
}
export interface UnpublishCollectionArgs {
    projectId?: number;
    collectionId: number;
}
export interface UnpublishCollectionReturn {
    collection: Collection;
}
export interface CreateContractCollectionArgs {
    projectId: number;
    contractCollection: ContractCollection;
}
export interface CreateContractCollectionReturn {
    contractCollection: ContractCollection;
}
export interface GetContractCollectionArgs {
    projectId: number;
    chainId: number;
    contractAddress: string;
}
export interface GetContractCollectionReturn {
    contractCollection: ContractCollection;
}
export interface ListContractCollectionsArgs {
    projectId: number;
    collectionId?: number;
    page?: Page;
}
export interface ListContractCollectionsReturn {
    contractCollections: Array<ContractCollection>;
    collections: Array<Collection>;
    page: Page;
}
export interface UpdateContractCollectionArgs {
    projectId: number;
    contractCollection: ContractCollection;
}
export interface UpdateContractCollectionReturn {
    ok: boolean;
}
export interface DeleteContractCollectionArgs {
    projectId: number;
    chainId: number;
    contractAddress: string;
}
export interface DeleteContractCollectionReturn {
    ok: boolean;
}
export interface CreateTokenArgs {
    projectId?: number;
    collectionId: number;
    token: TokenMetadata;
    private?: boolean;
}
export interface CreateTokenReturn {
    token: TokenMetadata;
    assets: Array<Asset>;
}
export interface GetTokenArgs {
    projectId?: number;
    collectionId: number;
    tokenId: string;
}
export interface GetTokenReturn {
    token: TokenMetadata;
    assets: Array<Asset>;
}
export interface ListTokensArgs {
    projectId?: number;
    collectionId: number;
    page?: Page;
}
export interface ListTokensReturn {
    page: Page;
    tokens: Array<TokenMetadata>;
}
export interface UpdateTokenArgs {
    projectId?: number;
    collectionId: number;
    tokenId: string;
    token: TokenMetadata;
    private?: boolean;
}
export interface UpdateTokenReturn {
    token: TokenMetadata;
}
export interface DeleteTokenArgs {
    projectId?: number;
    collectionId: number;
    tokenId: string;
}
export interface DeleteTokenReturn {
    status: boolean;
}
export interface CreateAssetArgs {
    projectId?: number;
    asset: Asset;
}
export interface CreateAssetReturn {
    asset: Asset;
}
export interface GetAssetArgs {
    projectId?: number;
    assetId: number;
}
export interface GetAssetReturn {
    asset: Asset;
}
export interface UpdateAssetArgs {
    projectId?: number;
    asset: Asset;
}
export interface UpdateAssetReturn {
    asset: Asset;
}
export interface DeleteAssetArgs {
    projectId?: number;
    assetId: number;
}
export interface DeleteAssetReturn {
    status: boolean;
}
export interface Admin {
    addContractsToTokenDirectory(args: AddContractsToTokenDirectoryArgs, headers?: object, signal?: AbortSignal): Promise<AddContractsToTokenDirectoryReturn>;
    removeContractsFromTokenDirectory(args: RemoveContractsFromTokenDirectoryArgs, headers?: object, signal?: AbortSignal): Promise<RemoveContractsFromTokenDirectoryReturn>;
    modifyFeatureIndex(args: ModifyFeatureIndexArgs, headers?: object, signal?: AbortSignal): Promise<ModifyFeatureIndexReturn>;
    getFeatureIndex(args: GetFeatureIndexArgs, headers?: object, signal?: AbortSignal): Promise<GetFeatureIndexReturn>;
    listTokenDirectory(args: ListTokenDirectoryArgs, headers?: object, signal?: AbortSignal): Promise<ListTokenDirectoryReturn>;
}
export interface AddContractsToTokenDirectoryArgs {
    contracts: Array<ContractInfo>;
    featureIndexes: Array<number>;
}
export interface AddContractsToTokenDirectoryReturn {
    ok: boolean;
}
export interface RemoveContractsFromTokenDirectoryArgs {
    chainHandle: string;
    contracts: Array<string>;
}
export interface RemoveContractsFromTokenDirectoryReturn {
    ok: boolean;
}
export interface ModifyFeatureIndexArgs {
    chainHandle: string;
    contractAddress: string;
    featured: number;
}
export interface ModifyFeatureIndexReturn {
    ok: boolean;
}
export interface GetFeatureIndexArgs {
    chainHandle: string;
    contractAddress: string;
}
export interface GetFeatureIndexReturn {
    featured: number;
}
export interface ListTokenDirectoryArgs {
    chainID?: number;
    includeTestnets?: boolean;
    onlyFeatured?: boolean;
    page?: Page;
}
export interface ListTokenDirectoryReturn {
    page: Page;
    collections: Array<ContractInfo>;
}
export declare class Metadata implements Metadata {
    protected hostname: string;
    protected fetch: Fetch;
    protected path: string;
    constructor(hostname: string, fetch: Fetch);
    private url;
    ping: (headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<PingReturn>;
    version: (headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<VersionReturn>;
    runtimeStatus: (headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<RuntimeStatusReturn>;
    getTokenMetadata: (args: GetTokenMetadataArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<GetTokenMetadataReturn>;
    refreshTokenMetadata: (args: RefreshTokenMetadataArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<RefreshTokenMetadataReturn>;
    enqueueTokensForRefresh: (args: EnqueueTokensForRefreshArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<EnqueueTokensForRefreshReturn>;
    getTokenRefreshStatus: (args: GetTokenRefreshStatusArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<GetTokenRefreshStatusReturn>;
    getTokenRefreshResult: (args: GetTokenRefreshResultArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<GetTokenRefreshResultReturn>;
    cancelRefreshJob: (args: CancelRefreshJobArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<CancelRefreshJobReturn>;
    getTokenMetadataBatch: (args: GetTokenMetadataBatchArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<GetTokenMetadataBatchReturn>;
    searchTokenMetadata: (args: SearchTokenMetadataArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<SearchTokenMetadataReturn>;
    searchTokenIDs: (args: SearchTokenIDsArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<SearchTokenIDsReturn>;
    tokenCollectionFilters: (args: TokenCollectionFiltersArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<TokenCollectionFiltersReturn>;
    getContractInfo: (args: GetContractInfoArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<GetContractInfoReturn>;
    getContractInfoBatch: (args: GetContractInfoBatchArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<GetContractInfoBatchReturn>;
    searchContractInfo: (args: SearchContractInfoArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<SearchContractInfoReturn>;
    searchContractInfoBatch: (args: SearchContractInfoBatchArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<SearchContractInfoBatchReturn>;
    searchMetadata: (args: SearchMetadataArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<SearchMetadataReturn>;
    searchTokens: (args: SearchTokensArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<SearchTokensReturn>;
    searchContracts: (args: SearchContractsArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<SearchContractsReturn>;
    getNiftyswapTokenQuantity: (args: GetNiftyswapTokenQuantityArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<GetNiftyswapTokenQuantityReturn>;
    getNiftyswapUnitPrices: (args: GetNiftyswapUnitPricesArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<GetNiftyswapUnitPricesReturn>;
    getNiftyswapUnitPricesWithQuantities: (args: GetNiftyswapUnitPricesWithQuantitiesArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<GetNiftyswapUnitPricesWithQuantitiesReturn>;
    addContractToMintMonitor: (args: AddContractToMintMonitorArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<AddContractToMintMonitorReturn>;
    removeContractFromMintMonitor: (args: RemoveContractFromMintMonitorArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<RemoveContractFromMintMonitorReturn>;
    mintMonitorJobStatus: (args: MintMonitorJobStatusArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<MintMonitorJobStatusReturn>;
    mintMonitorTriggerJob: (args: MintMonitorTriggerJobArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<MintMonitorTriggerJobReturn>;
    syncContractTokens: (args: SyncContractTokensArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<SyncContractTokensReturn>;
    abortContractSync: (args: AbortContractSyncArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<AbortContractSyncReturn>;
    contractSyncJobStatus: (args: ContractSyncJobStatusArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<ContractSyncJobStatusReturn>;
    directoryGetNetworks: (args: DirectoryGetNetworksArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<DirectoryGetNetworksReturn>;
    directoryGetCollections: (args: DirectoryGetCollectionsArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<DirectoryGetCollectionsReturn>;
    directorySearchCollections: (args: DirectorySearchCollectionsArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<DirectorySearchCollectionsReturn>;
}
export declare class Collections implements Collections {
    protected hostname: string;
    protected fetch: Fetch;
    protected path: string;
    constructor(hostname: string, fetch: Fetch);
    private url;
    createCollection: (args: CreateCollectionArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<CreateCollectionReturn>;
    getCollection: (args: GetCollectionArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<GetCollectionReturn>;
    listCollections: (args: ListCollectionsArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<ListCollectionsReturn>;
    updateCollection: (args: UpdateCollectionArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<UpdateCollectionReturn>;
    deleteCollection: (args: DeleteCollectionArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<DeleteCollectionReturn>;
    publishCollection: (args: PublishCollectionArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<PublishCollectionReturn>;
    unpublishCollection: (args: UnpublishCollectionArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<UnpublishCollectionReturn>;
    createContractCollection: (args: CreateContractCollectionArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<CreateContractCollectionReturn>;
    getContractCollection: (args: GetContractCollectionArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<GetContractCollectionReturn>;
    listContractCollections: (args: ListContractCollectionsArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<ListContractCollectionsReturn>;
    updateContractCollection: (args: UpdateContractCollectionArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<UpdateContractCollectionReturn>;
    deleteContractCollection: (args: DeleteContractCollectionArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<DeleteContractCollectionReturn>;
    createToken: (args: CreateTokenArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<CreateTokenReturn>;
    getToken: (args: GetTokenArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<GetTokenReturn>;
    listTokens: (args: ListTokensArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<ListTokensReturn>;
    updateToken: (args: UpdateTokenArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<UpdateTokenReturn>;
    deleteToken: (args: DeleteTokenArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<DeleteTokenReturn>;
    createAsset: (args: CreateAssetArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<CreateAssetReturn>;
    getAsset: (args: GetAssetArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<GetAssetReturn>;
    updateAsset: (args: UpdateAssetArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<UpdateAssetReturn>;
    deleteAsset: (args: DeleteAssetArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<DeleteAssetReturn>;
}
export declare class Admin implements Admin {
    protected hostname: string;
    protected fetch: Fetch;
    protected path: string;
    constructor(hostname: string, fetch: Fetch);
    private url;
    addContractsToTokenDirectory: (args: AddContractsToTokenDirectoryArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<AddContractsToTokenDirectoryReturn>;
    removeContractsFromTokenDirectory: (args: RemoveContractsFromTokenDirectoryArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<RemoveContractsFromTokenDirectoryReturn>;
    modifyFeatureIndex: (args: ModifyFeatureIndexArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<ModifyFeatureIndexReturn>;
    getFeatureIndex: (args: GetFeatureIndexArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<GetFeatureIndexReturn>;
    listTokenDirectory: (args: ListTokenDirectoryArgs, headers?: object | undefined, signal?: AbortSignal | undefined) => Promise<ListTokenDirectoryReturn>;
}
export declare class WebrpcError extends Error {
    name: string;
    code: number;
    message: string;
    status: number;
    cause?: string;
    /** @deprecated Use message instead of msg. Deprecated in webrpc v0.11.0. */
    msg: string;
    constructor(name: string, code: number, message: string, status: number, cause?: string);
    static new(payload: any): WebrpcError;
}
export declare class WebrpcEndpointError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class WebrpcRequestFailedError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class WebrpcBadRouteError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class WebrpcBadMethodError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class WebrpcBadRequestError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class WebrpcBadResponseError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class WebrpcServerPanicError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class WebrpcInternalErrorError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class WebrpcClientDisconnectedError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class WebrpcStreamLostError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class WebrpcStreamFinishedError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class UnauthorizedError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class PermissionDeniedError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class SessionExpiredError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class MethodNotFoundError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class RequestConflictError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class FailError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class GeoblockedError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class TimeoutError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class InvalidArgumentError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class RequiredArgumentError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class QueryFailedError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class ValidationFailedError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class RateLimitedError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class NotFoundError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class ProjectNotFoundError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class ChainNotFoundError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare class TokenDirectoryDisabledError extends WebrpcError {
    constructor(name?: string, code?: number, message?: string, status?: number, cause?: string);
}
export declare enum errors {
    WebrpcEndpoint = "WebrpcEndpoint",
    WebrpcRequestFailed = "WebrpcRequestFailed",
    WebrpcBadRoute = "WebrpcBadRoute",
    WebrpcBadMethod = "WebrpcBadMethod",
    WebrpcBadRequest = "WebrpcBadRequest",
    WebrpcBadResponse = "WebrpcBadResponse",
    WebrpcServerPanic = "WebrpcServerPanic",
    WebrpcInternalError = "WebrpcInternalError",
    WebrpcClientDisconnected = "WebrpcClientDisconnected",
    WebrpcStreamLost = "WebrpcStreamLost",
    WebrpcStreamFinished = "WebrpcStreamFinished",
    Unauthorized = "Unauthorized",
    PermissionDenied = "PermissionDenied",
    SessionExpired = "SessionExpired",
    MethodNotFound = "MethodNotFound",
    RequestConflict = "RequestConflict",
    Fail = "Fail",
    Geoblocked = "Geoblocked",
    Timeout = "Timeout",
    InvalidArgument = "InvalidArgument",
    RequiredArgument = "RequiredArgument",
    QueryFailed = "QueryFailed",
    ValidationFailed = "ValidationFailed",
    RateLimited = "RateLimited",
    NotFound = "NotFound",
    ProjectNotFound = "ProjectNotFound",
    ChainNotFound = "ChainNotFound",
    TokenDirectoryDisabled = "TokenDirectoryDisabled"
}
export type Fetch = (input: RequestInfo, init?: RequestInit) => Promise<Response>;
