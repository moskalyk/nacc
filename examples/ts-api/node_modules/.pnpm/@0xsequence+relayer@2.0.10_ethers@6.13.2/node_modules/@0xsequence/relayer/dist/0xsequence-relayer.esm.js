import { ethers } from 'ethers';
import { logger, getFetchRequest, bigintReplacer, toHexString } from '@0xsequence/utils';
import { walletContracts } from '@0xsequence/abi';
import { commons } from '@0xsequence/core';

function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}

const DEFAULT_GAS_LIMIT = 800000n;
const ProviderRelayerDefaults = {
  waitPollRate: 1000,
  deltaBlocksLog: 12,
  fromBlockLog: -1024
};
function isProviderRelayerOptions(obj) {
  return typeof obj === 'object' && obj.provider instanceof ethers.AbstractProvider;
}
class ProviderRelayer {
  constructor(options) {
    this.provider = void 0;
    this.waitPollRate = void 0;
    this.deltaBlocksLog = void 0;
    this.fromBlockLog = void 0;
    const opts = _extends({}, ProviderRelayerDefaults, options);
    this.provider = opts.provider;
    this.waitPollRate = opts.waitPollRate;
    this.deltaBlocksLog = opts.deltaBlocksLog;
    this.fromBlockLog = opts.fromBlockLog;
  }
  async simulate(wallet, ...transactions) {
    var _this = this;
    return (await Promise.all(transactions.map(async function (tx) {
      // Respect gasLimit request of the transaction (as long as its not 0)
      if (tx.gasLimit && BigInt(tx.gasLimit || 0) !== 0n) {
        return tx.gasLimit;
      }

      // Fee can't be estimated locally for delegateCalls
      if (tx.delegateCall) {
        return DEFAULT_GAS_LIMIT;
      }

      // Fee can't be estimated for self-called if wallet hasn't been deployed
      if (tx.to === wallet && (await _this.provider.getCode(wallet).then(code => ethers.getBytes(code).length === 0))) {
        return DEFAULT_GAS_LIMIT;
      }
      if (!_this.provider) {
        throw new Error('signer.provider is not set, but is required');
      }

      // TODO: If the wallet address has been deployed, gas limits can be
      // estimated with more accurately by using self-calls with the batch transactions one by one
      return _this.provider.estimateGas({
        from: wallet,
        to: tx.to,
        data: tx.data,
        value: tx.value
      });
    }))).map(gasLimit => ({
      executed: true,
      succeeded: true,
      gasUsed: Number(gasLimit),
      gasLimit: Number(gasLimit)
    }));
  }
  async getNonce(address, space, blockTag) {
    if (!this.provider) {
      throw new Error('provider is not set');
    }
    if ((await this.provider.getCode(address)) === '0x') {
      return 0;
    }
    if (space === undefined) {
      space = 0;
    }
    const module = new ethers.Contract(address, walletContracts.mainModule.abi, this.provider);
    const nonce = await module.readNonce(space, {
      blockTag: blockTag
    });
    return commons.transaction.encodeNonce(space, nonce);
  }
  async wait(metaTxnId, timeoutDuration, delay = this.waitPollRate, maxFails = 5) {
    var _this2 = this;
    if (typeof metaTxnId !== 'string') {
      metaTxnId = commons.transaction.intendedTransactionID(metaTxnId);
    }
    let timedOut = false;
    const retry = async function retry(f, errorMessage) {
      let fails = 0;
      while (!timedOut) {
        try {
          return await f();
        } catch (error) {
          fails++;
          if (maxFails !== undefined && fails >= maxFails) {
            logger.error(`giving up after ${fails} failed attempts${errorMessage ? `: ${errorMessage}` : ''}`, error);
            throw error;
          } else {
            logger.warn(`attempt #${fails} failed${errorMessage ? `: ${errorMessage}` : ''}`, error);
          }
        }
        if (delay > 0) {
          await new Promise(resolve => setTimeout(resolve, delay));
        }
      }
      throw new Error(`timed out after ${fails} failed attempts${errorMessage ? `: ${errorMessage}` : ''}`);
    };
    const waitReceipt = async function waitReceipt() {
      // Transactions can only get executed on nonce change
      // get all nonce changes and look for metaTxnIds in between logs
      let lastBlock = _this2.fromBlockLog;
      if (lastBlock < 0) {
        const block = await retry(() => _this2.provider.getBlockNumber(), 'unable to get latest block number');
        lastBlock = block + lastBlock;
      }
      if (typeof metaTxnId !== 'string') {
        throw new Error('impossible');
      }
      const normalMetaTxnId = metaTxnId.replace('0x', '');
      while (!timedOut) {
        const block = await retry(() => _this2.provider.getBlockNumber(), 'unable to get latest block number');
        const logs = await retry(() => _this2.provider.getLogs({
          fromBlock: Math.max(0, lastBlock - _this2.deltaBlocksLog),
          toBlock: block,
          // Nonce change event topic
          topics: ['0x1f180c27086c7a39ea2a7b25239d1ab92348f07ca7bb59d1438fcf527568f881']
        }), `unable to get NonceChange logs for blocks ${Math.max(0, lastBlock - _this2.deltaBlocksLog)} to ${block}`);
        lastBlock = block;

        // Get receipts of all transactions
        const txs = await Promise.all(logs.map(l => retry(() => _this2.provider.getTransactionReceipt(l.transactionHash), `unable to get receipt for transaction ${l.transactionHash}`)));

        // Find a transaction with a TxExecuted log
        const found = txs.find(tx => tx == null ? void 0 : tx.logs.find(l => l.topics.length === 0 && l.data.replace('0x', '') === normalMetaTxnId || l.topics.length === 1 &&
        // TxFailed event topic
        l.topics[0] === '0x3dbd1590ea96dd3253a91f24e64e3a502e1225d602a5731357bc12643070ccd7' && l.data.length >= 64 && l.data.replace('0x', '').startsWith(normalMetaTxnId)));

        // If found return that
        if (found) {
          const response = await retry(() => _this2.provider.getTransaction(found.hash), `unable to get transaction ${found.hash}`);
          if (!response) {
            throw new Error(`Transaction response not found for  ${metaTxnId}`);
          }

          // NOTE: we have to do this, because ethers-v6 uses private fields
          // and we can't just extend the class and override the method, so
          // we just modify the response object directly by adding the receipt to it.
          const out = response;
          out.receipt = found;
          return out;
        }

        // Otherwise wait and try again
        if (!timedOut) {
          await new Promise(r => setTimeout(r, delay));
        }
      }
      throw new Error(`Timeout waiting for transaction receipt ${metaTxnId}`);
    };
    if (timeoutDuration !== undefined) {
      return Promise.race([waitReceipt(), new Promise((_, reject) => setTimeout(() => {
        timedOut = true;
        reject(`Timeout waiting for transaction receipt ${metaTxnId}`);
      }, timeoutDuration))]);
    } else {
      return waitReceipt();
    }
  }
}

function isLocalRelayerOptions(obj) {
  return typeof obj === 'object' && obj.signer instanceof ethers.AbstractSigner;
}
class LocalRelayer extends ProviderRelayer {
  constructor(options) {
    super(options instanceof ethers.AbstractSigner ? {
      provider: options.provider
    } : _extends({}, options, {
      provider: options.signer.provider
    }));
    this.signer = void 0;
    this.txnOptions = void 0;
    this.signer = options instanceof ethers.AbstractSigner ? options : options.signer;
    if (!this.signer.provider) throw new Error('Signer must have a provider');
  }
  async getFeeOptions(_address, ..._transactions) {
    return {
      options: []
    };
  }
  async getFeeOptionsRaw(_entrypoint, _data, _options) {
    return {
      options: []
    };
  }
  async gasRefundOptions(address, ...transactions) {
    const {
      options
    } = await this.getFeeOptions(address, ...transactions);
    return options;
  }
  setTransactionOptions(transactionRequest) {
    this.txnOptions = transactionRequest;
  }
  async relay(signedTxs, quote, waitForReceipt = true) {
    if (quote !== undefined) {
      logger.warn(`LocalRelayer doesn't accept fee quotes`);
    }
    const data = commons.transaction.encodeBundleExecData(signedTxs);

    // TODO: think about computing gas limit individually, summing together and passing across
    // NOTE: we expect that all txns have set their gasLimit ahead of time through proper estimation
    // const gasLimit = signedTxs.transactions.reduce((sum, tx) => sum + tx.gasLimit, 0n)
    // txRequest.gasLimit = gasLimit

    const responsePromise = this.signer.sendTransaction(_extends({
      to: signedTxs.entrypoint,
      data
    }, this.txnOptions, {
      gasLimit: 9000000
    }));
    if (waitForReceipt) {
      const response = await responsePromise;
      response.receipt = await response.wait();
      return response;
    } else {
      return responsePromise;
    }
  }
}

/* eslint-disable */
// sequence-relayer v0.4.1 1e27d0fd295aa5897878939595ef0c6adc54b1a3
// --
// Code generated by webrpc-gen@v0.18.6 with typescript generator. DO NOT EDIT.
//
// webrpc-gen -schema=relayer.ridl -target=typescript -client -out=./clients/relayer.gen.ts

// WebRPC description and code-gen version
const WebRPCVersion = 'v1';

// Schema version of your RIDL schema
const WebRPCSchemaVersion = 'v0.4.1';

// Schema hash generated from your RIDL schema
const WebRPCSchemaHash = '1e27d0fd295aa5897878939595ef0c6adc54b1a3';

//
// Types
//

let ETHTxnStatus = /*#__PURE__*/function (ETHTxnStatus) {
  ETHTxnStatus["UNKNOWN"] = "UNKNOWN";
  ETHTxnStatus["DROPPED"] = "DROPPED";
  ETHTxnStatus["QUEUED"] = "QUEUED";
  ETHTxnStatus["SENT"] = "SENT";
  ETHTxnStatus["SUCCEEDED"] = "SUCCEEDED";
  ETHTxnStatus["PARTIALLY_FAILED"] = "PARTIALLY_FAILED";
  ETHTxnStatus["FAILED"] = "FAILED";
  return ETHTxnStatus;
}({});
let TransferType = /*#__PURE__*/function (TransferType) {
  TransferType["SEND"] = "SEND";
  TransferType["RECEIVE"] = "RECEIVE";
  TransferType["BRIDGE_DEPOSIT"] = "BRIDGE_DEPOSIT";
  TransferType["BRIDGE_WITHDRAW"] = "BRIDGE_WITHDRAW";
  TransferType["BURN"] = "BURN";
  TransferType["UNKNOWN"] = "UNKNOWN";
  return TransferType;
}({});
let FeeTokenType = /*#__PURE__*/function (FeeTokenType) {
  FeeTokenType["UNKNOWN"] = "UNKNOWN";
  FeeTokenType["ERC20_TOKEN"] = "ERC20_TOKEN";
  FeeTokenType["ERC1155_TOKEN"] = "ERC1155_TOKEN";
  return FeeTokenType;
}({});
let SortOrder = /*#__PURE__*/function (SortOrder) {
  SortOrder["DESC"] = "DESC";
  SortOrder["ASC"] = "ASC";
  return SortOrder;
}({});
//
// Client
//
class Relayer {
  constructor(hostname, fetch) {
    this.hostname = void 0;
    this.fetch = void 0;
    this.path = '/rpc/Relayer/';
    this.ping = (headers, signal) => {
      return this.fetch(this.url('Ping'), createHTTPRequest({}, headers, signal)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            status: _data.status
          };
        });
      }, error => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ''}`
        });
      });
    };
    this.version = (headers, signal) => {
      return this.fetch(this.url('Version'), createHTTPRequest({}, headers, signal)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            version: _data.version
          };
        });
      }, error => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ''}`
        });
      });
    };
    this.runtimeStatus = (headers, signal) => {
      return this.fetch(this.url('RuntimeStatus'), createHTTPRequest({}, headers, signal)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            status: _data.status
          };
        });
      }, error => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ''}`
        });
      });
    };
    this.getSequenceContext = (headers, signal) => {
      return this.fetch(this.url('GetSequenceContext'), createHTTPRequest({}, headers, signal)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            data: _data.data
          };
        });
      }, error => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ''}`
        });
      });
    };
    this.getChainID = (headers, signal) => {
      return this.fetch(this.url('GetChainID'), createHTTPRequest({}, headers, signal)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            chainID: _data.chainID
          };
        });
      }, error => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ''}`
        });
      });
    };
    this.sendMetaTxn = (args, headers, signal) => {
      return this.fetch(this.url('SendMetaTxn'), createHTTPRequest(args, headers, signal)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            status: _data.status,
            txnHash: _data.txnHash
          };
        });
      }, error => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ''}`
        });
      });
    };
    this.getMetaTxnNonce = (args, headers, signal) => {
      return this.fetch(this.url('GetMetaTxnNonce'), createHTTPRequest(args, headers, signal)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            nonce: _data.nonce
          };
        });
      }, error => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ''}`
        });
      });
    };
    this.getMetaTxnReceipt = (args, headers, signal) => {
      return this.fetch(this.url('GetMetaTxnReceipt'), createHTTPRequest(args, headers, signal)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            receipt: _data.receipt
          };
        });
      }, error => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ''}`
        });
      });
    };
    this.simulate = (args, headers, signal) => {
      return this.fetch(this.url('Simulate'), createHTTPRequest(args, headers, signal)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            results: _data.results
          };
        });
      }, error => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ''}`
        });
      });
    };
    this.updateMetaTxnGasLimits = (args, headers, signal) => {
      return this.fetch(this.url('UpdateMetaTxnGasLimits'), createHTTPRequest(args, headers, signal)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            payload: _data.payload
          };
        });
      }, error => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ''}`
        });
      });
    };
    this.feeTokens = (headers, signal) => {
      return this.fetch(this.url('FeeTokens'), createHTTPRequest({}, headers, signal)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            isFeeRequired: _data.isFeeRequired,
            tokens: _data.tokens
          };
        });
      }, error => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ''}`
        });
      });
    };
    this.feeOptions = (args, headers, signal) => {
      return this.fetch(this.url('FeeOptions'), createHTTPRequest(args, headers, signal)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            options: _data.options,
            sponsored: _data.sponsored,
            quote: _data.quote
          };
        });
      }, error => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ''}`
        });
      });
    };
    this.getMetaTxnNetworkFeeOptions = (args, headers, signal) => {
      return this.fetch(this.url('GetMetaTxnNetworkFeeOptions'), createHTTPRequest(args, headers, signal)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            options: _data.options
          };
        });
      }, error => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ''}`
        });
      });
    };
    this.getMetaTransactions = (args, headers, signal) => {
      return this.fetch(this.url('GetMetaTransactions'), createHTTPRequest(args, headers, signal)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            page: _data.page,
            transactions: _data.transactions
          };
        });
      }, error => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ''}`
        });
      });
    };
    this.sentTransactions = (args, headers, signal) => {
      return this.fetch(this.url('SentTransactions'), createHTTPRequest(args, headers, signal)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            page: _data.page,
            transactions: _data.transactions
          };
        });
      }, error => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ''}`
        });
      });
    };
    this.pendingTransactions = (args, headers, signal) => {
      return this.fetch(this.url('PendingTransactions'), createHTTPRequest(args, headers, signal)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            page: _data.page,
            transactions: _data.transactions
          };
        });
      }, error => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ''}`
        });
      });
    };
    this.getGasTank = (args, headers, signal) => {
      return this.fetch(this.url('GetGasTank'), createHTTPRequest(args, headers, signal)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            gasTank: _data.gasTank
          };
        });
      }, error => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ''}`
        });
      });
    };
    this.addGasTank = (args, headers, signal) => {
      return this.fetch(this.url('AddGasTank'), createHTTPRequest(args, headers, signal)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            status: _data.status,
            gasTank: _data.gasTank
          };
        });
      }, error => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ''}`
        });
      });
    };
    this.updateGasTank = (args, headers, signal) => {
      return this.fetch(this.url('UpdateGasTank'), createHTTPRequest(args, headers, signal)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            status: _data.status,
            gasTank: _data.gasTank
          };
        });
      }, error => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ''}`
        });
      });
    };
    this.getGasSponsor = (args, headers, signal) => {
      return this.fetch(this.url('GetGasSponsor'), createHTTPRequest(args, headers, signal)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            gasSponsor: _data.gasSponsor
          };
        });
      }, error => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ''}`
        });
      });
    };
    this.addressGasSponsors = (args, headers, signal) => {
      return this.fetch(this.url('AddressGasSponsors'), createHTTPRequest(args, headers, signal)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            page: _data.page,
            gasSponsors: _data.gasSponsors
          };
        });
      }, error => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ''}`
        });
      });
    };
    this.listGasSponsors = (args, headers, signal) => {
      return this.fetch(this.url('ListGasSponsors'), createHTTPRequest(args, headers, signal)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            page: _data.page,
            gasSponsors: _data.gasSponsors
          };
        });
      }, error => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ''}`
        });
      });
    };
    this.addGasSponsor = (args, headers, signal) => {
      return this.fetch(this.url('AddGasSponsor'), createHTTPRequest(args, headers, signal)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            status: _data.status,
            gasSponsor: _data.gasSponsor
          };
        });
      }, error => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ''}`
        });
      });
    };
    this.updateGasSponsor = (args, headers, signal) => {
      return this.fetch(this.url('UpdateGasSponsor'), createHTTPRequest(args, headers, signal)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            status: _data.status,
            gasSponsor: _data.gasSponsor
          };
        });
      }, error => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ''}`
        });
      });
    };
    this.removeGasSponsor = (args, headers, signal) => {
      return this.fetch(this.url('RemoveGasSponsor'), createHTTPRequest(args, headers, signal)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            status: _data.status
          };
        });
      }, error => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ''}`
        });
      });
    };
    this.reportGasSponsorUsage = (args, headers, signal) => {
      return this.fetch(this.url('ReportGasSponsorUsage'), createHTTPRequest(args, headers, signal)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            gasSponsorUsage: _data.gasSponsorUsage
          };
        });
      }, error => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ''}`
        });
      });
    };
    this.nextGasTankBalanceAdjustmentNonce = (args, headers, signal) => {
      return this.fetch(this.url('NextGasTankBalanceAdjustmentNonce'), createHTTPRequest(args, headers, signal)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            nonce: _data.nonce
          };
        });
      }, error => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ''}`
        });
      });
    };
    this.adjustGasTankBalance = (args, headers, signal) => {
      return this.fetch(this.url('AdjustGasTankBalance'), createHTTPRequest(args, headers, signal)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            status: _data.status,
            adjustment: _data.adjustment
          };
        });
      }, error => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ''}`
        });
      });
    };
    this.getGasTankBalanceAdjustment = (args, headers, signal) => {
      return this.fetch(this.url('GetGasTankBalanceAdjustment'), createHTTPRequest(args, headers, signal)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            adjustment: _data.adjustment
          };
        });
      }, error => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ''}`
        });
      });
    };
    this.listGasTankBalanceAdjustments = (args, headers, signal) => {
      return this.fetch(this.url('ListGasTankBalanceAdjustments'), createHTTPRequest(args, headers, signal)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            page: _data.page,
            adjustments: _data.adjustments
          };
        });
      }, error => {
        throw WebrpcRequestFailedError.new({
          cause: `fetch(): ${error.message || ''}`
        });
      });
    };
    this.hostname = hostname;
    this.fetch = (input, init) => fetch(input, init);
  }
  url(name) {
    return this.hostname + this.path + name;
  }
}
const createHTTPRequest = (body = {}, headers = {}, signal = null) => {
  return {
    method: 'POST',
    headers: _extends({}, headers, {
      'Content-Type': 'application/json'
    }),
    body: JSON.stringify(body || {}),
    signal
  };
};
const buildResponse = res => {
  return res.text().then(text => {
    let data;
    try {
      data = JSON.parse(text);
    } catch (error) {
      let message = '';
      if (error instanceof Error) {
        message = error.message;
      }
      throw WebrpcBadResponseError.new({
        status: res.status,
        cause: `JSON.parse(): ${message}: response text: ${text}`
      });
    }
    if (!res.ok) {
      const code = typeof data.code === 'number' ? data.code : 0;
      throw (webrpcErrorByCode[code] || WebrpcError).new(data);
    }
    return data;
  });
};

//
// Errors
//

class WebrpcError extends Error {
  constructor(name, code, message, status, cause) {
    super(message);
    this.name = void 0;
    this.code = void 0;
    this.message = void 0;
    this.status = void 0;
    this.cause = void 0;
    /** @deprecated Use message instead of msg. Deprecated in webrpc v0.11.0. */
    this.msg = void 0;
    this.name = name || 'WebrpcError';
    this.code = typeof code === 'number' ? code : 0;
    this.message = message || `endpoint error ${this.code}`;
    this.msg = this.message;
    this.status = typeof status === 'number' ? status : 0;
    this.cause = cause;
    Object.setPrototypeOf(this, WebrpcError.prototype);
  }
  static new(payload) {
    return new this(payload.error, payload.code, payload.message || payload.msg, payload.status, payload.cause);
  }
}

// Webrpc errors

class WebrpcEndpointError extends WebrpcError {
  constructor(name = 'WebrpcEndpoint', code = 0, message = 'endpoint error', status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, WebrpcEndpointError.prototype);
  }
}
class WebrpcRequestFailedError extends WebrpcError {
  constructor(name = 'WebrpcRequestFailed', code = -1, message = 'request failed', status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, WebrpcRequestFailedError.prototype);
  }
}
class WebrpcBadRouteError extends WebrpcError {
  constructor(name = 'WebrpcBadRoute', code = -2, message = 'bad route', status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, WebrpcBadRouteError.prototype);
  }
}
class WebrpcBadMethodError extends WebrpcError {
  constructor(name = 'WebrpcBadMethod', code = -3, message = 'bad method', status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, WebrpcBadMethodError.prototype);
  }
}
class WebrpcBadRequestError extends WebrpcError {
  constructor(name = 'WebrpcBadRequest', code = -4, message = 'bad request', status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, WebrpcBadRequestError.prototype);
  }
}
class WebrpcBadResponseError extends WebrpcError {
  constructor(name = 'WebrpcBadResponse', code = -5, message = 'bad response', status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, WebrpcBadResponseError.prototype);
  }
}
class WebrpcServerPanicError extends WebrpcError {
  constructor(name = 'WebrpcServerPanic', code = -6, message = 'server panic', status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, WebrpcServerPanicError.prototype);
  }
}
class WebrpcInternalErrorError extends WebrpcError {
  constructor(name = 'WebrpcInternalError', code = -7, message = 'internal error', status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, WebrpcInternalErrorError.prototype);
  }
}
class WebrpcClientDisconnectedError extends WebrpcError {
  constructor(name = 'WebrpcClientDisconnected', code = -8, message = 'client disconnected', status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, WebrpcClientDisconnectedError.prototype);
  }
}
class WebrpcStreamLostError extends WebrpcError {
  constructor(name = 'WebrpcStreamLost', code = -9, message = 'stream lost', status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, WebrpcStreamLostError.prototype);
  }
}
class WebrpcStreamFinishedError extends WebrpcError {
  constructor(name = 'WebrpcStreamFinished', code = -10, message = 'stream finished', status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, WebrpcStreamFinishedError.prototype);
  }
}

// Schema errors

class UnauthorizedError extends WebrpcError {
  constructor(name = 'Unauthorized', code = 1000, message = 'Unauthorized access', status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, UnauthorizedError.prototype);
  }
}
class PermissionDeniedError extends WebrpcError {
  constructor(name = 'PermissionDenied', code = 1001, message = 'Permission denied', status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, PermissionDeniedError.prototype);
  }
}
class MethodNotFoundError extends WebrpcError {
  constructor(name = 'MethodNotFound', code = 1003, message = 'Method not found', status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, MethodNotFoundError.prototype);
  }
}
class AbortedError extends WebrpcError {
  constructor(name = 'Aborted', code = 1005, message = 'Request aborted', status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, AbortedError.prototype);
  }
}
class InvalidArgumentError extends WebrpcError {
  constructor(name = 'InvalidArgument', code = 2001, message = 'Invalid argument', status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, InvalidArgumentError.prototype);
  }
}
class UnavailableError extends WebrpcError {
  constructor(name = 'Unavailable', code = 2002, message = 'Unavailable resource', status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, UnavailableError.prototype);
  }
}
class QueryFailedError extends WebrpcError {
  constructor(name = 'QueryFailed', code = 2003, message = 'Query failed', status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, QueryFailedError.prototype);
  }
}
class NotFoundError extends WebrpcError {
  constructor(name = 'NotFound', code = 3000, message = 'Resource not found', status = 0, cause) {
    super(name, code, message, status, cause);
    Object.setPrototypeOf(this, NotFoundError.prototype);
  }
}
let errors = /*#__PURE__*/function (errors) {
  errors["WebrpcEndpoint"] = "WebrpcEndpoint";
  errors["WebrpcRequestFailed"] = "WebrpcRequestFailed";
  errors["WebrpcBadRoute"] = "WebrpcBadRoute";
  errors["WebrpcBadMethod"] = "WebrpcBadMethod";
  errors["WebrpcBadRequest"] = "WebrpcBadRequest";
  errors["WebrpcBadResponse"] = "WebrpcBadResponse";
  errors["WebrpcServerPanic"] = "WebrpcServerPanic";
  errors["WebrpcInternalError"] = "WebrpcInternalError";
  errors["WebrpcClientDisconnected"] = "WebrpcClientDisconnected";
  errors["WebrpcStreamLost"] = "WebrpcStreamLost";
  errors["WebrpcStreamFinished"] = "WebrpcStreamFinished";
  errors["Unauthorized"] = "Unauthorized";
  errors["PermissionDenied"] = "PermissionDenied";
  errors["MethodNotFound"] = "MethodNotFound";
  errors["Aborted"] = "Aborted";
  errors["InvalidArgument"] = "InvalidArgument";
  errors["Unavailable"] = "Unavailable";
  errors["QueryFailed"] = "QueryFailed";
  errors["NotFound"] = "NotFound";
  return errors;
}({});
const webrpcErrorByCode = {
  [0]: WebrpcEndpointError,
  [-1]: WebrpcRequestFailedError,
  [-2]: WebrpcBadRouteError,
  [-3]: WebrpcBadMethodError,
  [-4]: WebrpcBadRequestError,
  [-5]: WebrpcBadResponseError,
  [-6]: WebrpcServerPanicError,
  [-7]: WebrpcInternalErrorError,
  [-8]: WebrpcClientDisconnectedError,
  [-9]: WebrpcStreamLostError,
  [-10]: WebrpcStreamFinishedError,
  [1000]: UnauthorizedError,
  [1001]: PermissionDeniedError,
  [1003]: MethodNotFoundError,
  [1005]: AbortedError,
  [2001]: InvalidArgumentError,
  [2002]: UnavailableError,
  [2003]: QueryFailedError,
  [3000]: NotFoundError
};

var relayer_gen = /*#__PURE__*/Object.freeze({
  __proto__: null,
  WebRPCVersion: WebRPCVersion,
  WebRPCSchemaVersion: WebRPCSchemaVersion,
  WebRPCSchemaHash: WebRPCSchemaHash,
  ETHTxnStatus: ETHTxnStatus,
  TransferType: TransferType,
  FeeTokenType: FeeTokenType,
  SortOrder: SortOrder,
  Relayer: Relayer,
  WebrpcError: WebrpcError,
  WebrpcEndpointError: WebrpcEndpointError,
  WebrpcRequestFailedError: WebrpcRequestFailedError,
  WebrpcBadRouteError: WebrpcBadRouteError,
  WebrpcBadMethodError: WebrpcBadMethodError,
  WebrpcBadRequestError: WebrpcBadRequestError,
  WebrpcBadResponseError: WebrpcBadResponseError,
  WebrpcServerPanicError: WebrpcServerPanicError,
  WebrpcInternalErrorError: WebrpcInternalErrorError,
  WebrpcClientDisconnectedError: WebrpcClientDisconnectedError,
  WebrpcStreamLostError: WebrpcStreamLostError,
  WebrpcStreamFinishedError: WebrpcStreamFinishedError,
  UnauthorizedError: UnauthorizedError,
  PermissionDeniedError: PermissionDeniedError,
  MethodNotFoundError: MethodNotFoundError,
  AbortedError: AbortedError,
  InvalidArgumentError: InvalidArgumentError,
  UnavailableError: UnavailableError,
  QueryFailedError: QueryFailedError,
  NotFoundError: NotFoundError,
  errors: errors
});

const FINAL_STATUSES = [ETHTxnStatus.DROPPED, ETHTxnStatus.SUCCEEDED, ETHTxnStatus.PARTIALLY_FAILED, ETHTxnStatus.FAILED];
const FAILED_STATUSES = [ETHTxnStatus.DROPPED, ETHTxnStatus.PARTIALLY_FAILED, ETHTxnStatus.FAILED];
function isRpcRelayerOptions(obj) {
  return obj.url !== undefined && typeof obj.url === 'string' && obj.provider !== undefined && obj.provider instanceof ethers.AbstractProvider;
}
const fetch = globalThis.fetch;

// TODO: rename to SequenceRelayer
class RpcRelayer {
  constructor(options) {
    this.options = options;
    this.service = void 0;
    this.provider = void 0;
    this._fetch = (input, init) => {
      // automatically include jwt and access key auth header to requests
      // if its been set on the api client
      const headers = {};
      const {
        jwtAuth,
        projectAccessKey
      } = this.options;
      if (jwtAuth && jwtAuth.length > 0) {
        headers['Authorization'] = `BEARER ${jwtAuth}`;
      }
      if (projectAccessKey && projectAccessKey.length > 0) {
        headers['X-Access-Key'] = projectAccessKey;
      }

      // before the request is made
      init.headers = _extends({}, init.headers, headers);
      return fetch(input, init);
    };
    this.service = new Relayer(options.url, this._fetch);
    if (options.provider instanceof ethers.AbstractProvider) {
      this.provider = options.provider;
    } else {
      const {
        jwtAuth,
        projectAccessKey
      } = this.options;
      const fetchRequest = getFetchRequest(options.provider.url, projectAccessKey, jwtAuth);
      this.provider = new ethers.JsonRpcProvider(fetchRequest, undefined, {
        staticNetwork: true
      });
    }
  }
  async waitReceipt(metaTxnId, delay = 1000, maxFails = 5, isCancelled) {
    if (typeof metaTxnId !== 'string') {
      metaTxnId = commons.transaction.intendedTransactionID(metaTxnId);
    }
    logger.info(`[rpc-relayer/waitReceipt] waiting for ${metaTxnId}`);
    let fails = 0;
    while (isCancelled === undefined || !isCancelled()) {
      try {
        const {
          receipt
        } = await this.service.getMetaTxnReceipt({
          metaTxID: metaTxnId
        });
        if (receipt && receipt.txnReceipt && receipt.txnReceipt !== 'null' && FINAL_STATUSES.includes(receipt.status)) {
          return {
            receipt
          };
        }
      } catch (e) {
        fails++;
        if (fails === maxFails) {
          throw e;
        }
      }
      if (isCancelled === undefined || !isCancelled()) {
        await new Promise(resolve => setTimeout(resolve, delay));
      }
    }
    throw new Error(`Cancelled waiting for transaction receipt ${metaTxnId}`);
  }
  async simulate(wallet, ...transactions) {
    const coder = ethers.AbiCoder.defaultAbiCoder();
    const encoded = coder.encode([commons.transaction.MetaTransactionsType], [commons.transaction.sequenceTxAbiEncode(transactions)]);
    return (await this.service.simulate({
      wallet,
      transactions: encoded
    })).results;
  }
  async getFeeOptions(address, ...transactions) {
    // NOTE/TODO: for a given `service` the feeTokens will not change between execution, so we should memoize this value
    // for a short-period of time, perhaps for 1 day or in memory. Perhaps one day we can make this happen automatically
    // with http cache response for this endpoint and service-worker.. lots of approaches
    const feeTokens = await this.service.feeTokens();
    if (feeTokens.isFeeRequired) {
      const symbols = feeTokens.tokens.map(token => token.symbol).join(', ');
      logger.info(`[rpc-relayer/getFeeOptions] relayer fees are required, accepted tokens are ${symbols}`);
      const nonce = await this.getNonce(address);
      if (!this.provider) {
        logger.warn(`[rpc-relayer/getFeeOptions] provider not set, needed for stub signature`);
        throw new Error('provider is not set');
      }
      const {
        options,
        quote
      } = await this.service.feeOptions({
        wallet: address,
        to: address,
        data: commons.transaction.encodeBundleExecData({
          entrypoint: address,
          transactions,
          nonce
        })
      });
      logger.info(`[rpc-relayer/getFeeOptions] got refund options ${JSON.stringify(options, bigintReplacer)}`);
      return {
        options,
        quote: {
          _tag: 'FeeQuote',
          _quote: quote
        }
      };
    } else {
      logger.info(`[rpc-relayer/getFeeOptions] relayer fees are not required`);
      return {
        options: []
      };
    }
  }
  async getFeeOptionsRaw(entrypoint, data, options) {
    const {
      options: feeOptions,
      quote
    } = await this.service.feeOptions({
      wallet: entrypoint,
      to: entrypoint,
      data: ethers.hexlify(data),
      simulate: options == null ? void 0 : options.simulate
    });
    return {
      options: feeOptions,
      quote: {
        _tag: 'FeeQuote',
        _quote: quote
      }
    };
  }
  async gasRefundOptions(address, ...transactions) {
    const {
      options
    } = await this.getFeeOptions(address, ...transactions);
    return options;
  }
  async getNonce(address, space) {
    logger.info(`[rpc-relayer/getNonce] get nonce for wallet ${address} space: ${space}`);
    const encodedNonce = space !== undefined ? toHexString(BigInt(space)) : undefined;
    const resp = await this.service.getMetaTxnNonce({
      walletContractAddress: address,
      space: encodedNonce
    });
    const nonce = BigInt(resp.nonce);
    const [decodedSpace, decodedNonce] = commons.transaction.decodeNonce(nonce);
    logger.info(`[rpc-relayer/getNonce] got next nonce for wallet ${address} ${decodedNonce} space: ${decodedSpace}`);
    return nonce;
  }
  async relay(signedTxs, quote, waitForReceipt = true) {
    var _this = this;
    logger.info(`[rpc-relayer/relay] relaying signed meta-transactions ${JSON.stringify(signedTxs, bigintReplacer)} with quote ${JSON.stringify(quote, bigintReplacer)}`);
    let typecheckedQuote;
    if (quote !== undefined) {
      if (typeof quote._quote === 'string') {
        typecheckedQuote = quote._quote;
      } else {
        logger.warn('[rpc-relayer/relay] ignoring invalid fee quote');
      }
    }
    if (!this.provider) {
      logger.warn(`[rpc-relayer/relay] provider not set, failed relay`);
      throw new Error('provider is not set');
    }
    const data = commons.transaction.encodeBundleExecData(signedTxs);
    const metaTxn = await this.service.sendMetaTxn({
      call: {
        walletAddress: signedTxs.intent.wallet,
        contract: signedTxs.entrypoint,
        input: data
      },
      quote: typecheckedQuote
    });
    logger.info(`[rpc-relayer/relay] got relay result ${JSON.stringify(metaTxn, bigintReplacer)}`);
    if (waitForReceipt) {
      return this.wait(signedTxs.intent.id);
    } else {
      const response = {
        hash: signedTxs.intent.id,
        confirmations: 0,
        from: signedTxs.intent.wallet,
        wait: _confirmations => Promise.reject(new Error('impossible'))
      };
      const wait = async function wait(confirmations) {
        var _waitResponse$receipt;
        if (!_this.provider) {
          throw new Error('cannot wait for receipt, relayer has no provider set');
        }
        const waitResponse = await _this.wait(signedTxs.intent.id);
        const transactionHash = (_waitResponse$receipt = waitResponse.receipt) == null ? void 0 : _waitResponse$receipt.transactionHash;
        if (!transactionHash) {
          throw new Error('cannot wait for receipt, unknown native transaction hash');
        }
        Object.assign(response, waitResponse);
        return _this.provider.waitForTransaction(transactionHash, confirmations);
      };
      response.wait = wait;

      // NOTE: we just ignore these errors which come from the private fields
      // of ethers-v6 .. but, we should probably rework this instead..
      // @ts-ignore
      return response;
    }
  }
  async wait(metaTxnId, timeout, delay = 1000, maxFails = 5) {
    var _this2 = this;
    let timedOut = false;
    const {
      receipt
    } = await (timeout !== undefined ? Promise.race([this.waitReceipt(metaTxnId, delay, maxFails, () => timedOut), new Promise((_, reject) => setTimeout(() => {
      timedOut = true;
      reject(`Timeout waiting for transaction receipt ${metaTxnId}`);
    }, timeout))]) : this.waitReceipt(metaTxnId, delay, maxFails));
    if (!receipt.txnReceipt || FAILED_STATUSES.includes(receipt.status)) {
      throw new MetaTransactionResponseException(receipt);
    }
    const txReceipt = JSON.parse(receipt.txnReceipt);

    // NOTE: we just ignore these errors which come from the private fields
    // of ethers-v6 .. but, we should probably rework this instead..
    // @ts-ignore
    return {
      blockHash: txReceipt.blockHash,
      blockNumber: Number(txReceipt.blockNumber),
      confirmations: 1,
      from: typeof metaTxnId === 'string' ? undefined : metaTxnId.intent.wallet,
      hash: txReceipt.transactionHash,
      raw: receipt.txnReceipt,
      receipt: txReceipt,
      // extended type which is Sequence-specific. Contains the decoded metaTxReceipt
      wait: async function (confirmations) {
        return _this2.provider.waitForTransaction(txReceipt.transactionHash, confirmations);
      }
    };
  }
}
class MetaTransactionResponseException {
  constructor(receipt) {
    this.receipt = receipt;
  }
}

// A fee quote is simply an opaque value that can be obtained via Relayer.getFeeOptions(), and
// returned back to the same relayer via Relayer.relay(). Fee quotes should be treated as an
// implementation detail of the relayer that produces them.
//
// This interface exists for type-safety purposes to protect against passing non-FeeQuotes to
// Relayer.relay(), or any other functions that call it indirectly (e.g. Account.sendTransaction).

function isRelayer(cand) {
  return typeof cand === 'object' && typeof cand.simulate === 'function' && typeof cand.getFeeOptions === 'function' && typeof cand.gasRefundOptions === 'function' && typeof cand.getNonce === 'function' && typeof cand.relay === 'function' && typeof cand.wait === 'function';
}

export { LocalRelayer, ProviderRelayer, ProviderRelayerDefaults, RpcRelayer, relayer_gen as RpcRelayerProto, isLocalRelayerOptions, isProviderRelayerOptions, isRelayer, isRpcRelayerOptions, relayer_gen as proto };
