import { ethers } from 'ethers';
import { FeeOption, FeeQuote, Relayer, SimulateResult } from "../index.js";
import * as proto from "./relayer.gen.js";
import { commons } from '@0xsequence/core';
export { proto };
export interface RpcRelayerOptions {
    provider: ethers.AbstractProvider | {
        url: string;
    };
    url: string;
    projectAccessKey?: string;
    jwtAuth?: string;
}
export declare function isRpcRelayerOptions(obj: any): obj is RpcRelayerOptions;
export declare class RpcRelayer implements Relayer {
    options: RpcRelayerOptions;
    private readonly service;
    readonly provider: ethers.Provider;
    constructor(options: RpcRelayerOptions);
    _fetch: (input: RequestInfo, init?: RequestInit) => Promise<Response>;
    waitReceipt(metaTxnId: string | commons.transaction.SignedTransactionBundle, delay?: number, maxFails?: number, isCancelled?: () => boolean): Promise<proto.GetMetaTxnReceiptReturn>;
    simulate(wallet: string, ...transactions: commons.transaction.Transaction[]): Promise<SimulateResult[]>;
    getFeeOptions(address: string, ...transactions: commons.transaction.Transaction[]): Promise<{
        options: FeeOption[];
        quote?: FeeQuote;
    }>;
    getFeeOptionsRaw(entrypoint: string, data: ethers.BytesLike, options?: {
        simulate?: boolean;
    }): Promise<{
        options: FeeOption[];
        quote?: FeeQuote;
    }>;
    gasRefundOptions(address: string, ...transactions: commons.transaction.Transaction[]): Promise<FeeOption[]>;
    getNonce(address: string, space?: ethers.BigNumberish): Promise<ethers.BigNumberish>;
    relay(signedTxs: commons.transaction.IntendedTransactionBundle, quote?: FeeQuote, waitForReceipt?: boolean): Promise<commons.transaction.TransactionResponse<RelayerTxReceipt>>;
    wait(metaTxnId: string | commons.transaction.SignedTransactionBundle, timeout?: number, delay?: number, maxFails?: number): Promise<commons.transaction.TransactionResponse<RelayerTxReceipt>>;
}
export type RelayerTxReceipt = {
    blockHash: string;
    blockNumber: string;
    contractAddress: string;
    cumulativeGasUsed: string;
    gasUsed: string;
    logs: {
        address: string;
        blockHash: string;
        blockNumber: string;
        data: string;
        logIndex: string;
        removed: boolean;
        topics: string[];
        transactionHash: string;
        transactionIndex: string;
    }[];
    logsBloom: string;
    root: string;
    status: string;
    transactionHash: string;
    transactionIndex: string;
};
