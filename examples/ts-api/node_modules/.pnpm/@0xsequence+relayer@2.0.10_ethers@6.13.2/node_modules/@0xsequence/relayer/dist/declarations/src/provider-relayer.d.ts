import { ethers } from 'ethers';
import { FeeOption, FeeQuote, Relayer, SimulateResult } from "./index.js";
import { Optionals } from '@0xsequence/utils';
import { commons } from '@0xsequence/core';
export interface ProviderRelayerOptions {
    provider: ethers.Provider;
    waitPollRate?: number;
    deltaBlocksLog?: number;
    fromBlockLog?: number;
}
export declare const ProviderRelayerDefaults: Required<Optionals<ProviderRelayerOptions>>;
export declare function isProviderRelayerOptions(obj: any): obj is ProviderRelayerOptions;
export declare abstract class ProviderRelayer implements Relayer {
    provider: ethers.Provider;
    waitPollRate: number;
    deltaBlocksLog: number;
    fromBlockLog: number;
    constructor(options: ProviderRelayerOptions);
    abstract getFeeOptions(address: string, ...transactions: commons.transaction.Transaction[]): Promise<{
        options: FeeOption[];
        quote?: FeeQuote;
    }>;
    abstract getFeeOptionsRaw(entrypoint: string, data: ethers.BytesLike, options?: {
        simulate?: boolean;
    }): Promise<{
        options: FeeOption[];
        quote?: FeeQuote;
    }>;
    abstract gasRefundOptions(address: string, ...transactions: commons.transaction.Transaction[]): Promise<FeeOption[]>;
    abstract relay(signedTxs: commons.transaction.IntendedTransactionBundle, quote?: FeeQuote, waitForReceipt?: boolean): Promise<commons.transaction.TransactionResponse>;
    simulate(wallet: string, ...transactions: commons.transaction.Transaction[]): Promise<SimulateResult[]>;
    getNonce(address: string, space?: ethers.BigNumberish, blockTag?: ethers.BlockTag): Promise<ethers.BigNumberish>;
    wait(metaTxnId: string | commons.transaction.SignedTransactionBundle, timeoutDuration?: number, delay?: number, maxFails?: number): Promise<ethers.TransactionResponse & {
        receipt: ethers.TransactionReceipt;
    }>;
}
