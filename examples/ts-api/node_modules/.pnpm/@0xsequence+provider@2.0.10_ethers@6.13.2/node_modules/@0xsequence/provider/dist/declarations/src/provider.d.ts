import { ethers } from 'ethers';
import { SequenceClient } from "./client.js";
import { EIP1193Provider, ChainIdLike, NetworkConfig } from '@0xsequence/network';
import { ConnectDetails, ConnectOptions, OpenWalletIntent, OptionalChainIdLike, WalletSession } from "./types.js";
import { commons } from '@0xsequence/core';
import { WalletUtils } from "./utils/index.js";
import { SequenceSigner, SingleNetworkSequenceSigner } from "./signer.js";
export interface ISequenceProvider {
    readonly _isSequenceProvider: true;
    connect(options?: ConnectOptions): Promise<ConnectDetails>;
    disconnect(): void;
    isConnected(): boolean;
    getSession(): WalletSession | undefined;
    listAccounts(): string[];
    getAddress(): string;
    getNetworks(): Promise<NetworkConfig[]>;
    getChainId(): number;
    setDefaultChainId(chainId: ChainIdLike): void;
    isOpened(): boolean;
    openWallet(path?: string, intent?: OpenWalletIntent): Promise<boolean>;
    closeWallet(): void;
    getProvider(): SequenceProvider;
    getProvider(chainId: ChainIdLike): SingleNetworkSequenceProvider;
    getProvider(chainId?: ChainIdLike): SequenceProvider | SingleNetworkSequenceProvider;
    getSigner(): SequenceSigner;
    getSigner(chainId: ChainIdLike): SingleNetworkSequenceSigner;
    getSigner(chainId?: ChainIdLike): SequenceSigner | SingleNetworkSequenceSigner;
    getWalletContext(): Promise<commons.context.VersionedContext>;
    getWalletConfig(chainId?: ChainIdLike): Promise<commons.config.Config>;
    utils: WalletUtils;
}
declare const EIP1193EventTypes: readonly ["connect", "disconnect", "chainChanged", "accountsChanged"];
type EIP1193EventType = (typeof EIP1193EventTypes)[number];
export declare class SequenceProvider extends ethers.AbstractProvider implements ISequenceProvider, EIP1193Provider {
    readonly client: SequenceClient;
    private readonly providerFor;
    readonly networks: NetworkConfig[];
    readonly options?: ethers.AbstractProviderOptions | undefined;
    private readonly singleNetworkProviders;
    readonly _isSequenceProvider = true;
    readonly utils: WalletUtils;
    readonly signer: SequenceSigner;
    readonly eip1193EventListeners: Map<"connect" | "disconnect" | "accountsChanged" | "chainChanged", Set<ethers.Listener>>;
    constructor(client: SequenceClient, providerFor: (networkId: number) => ethers.JsonRpcProvider, networks?: NetworkConfig[], options?: ethers.AbstractProviderOptions | undefined);
    on(event: ethers.ProviderEvent | EIP1193EventType, listener: ethers.Listener): Promise<this>;
    off(event: ethers.ProviderEvent | EIP1193EventType, listener?: ethers.Listener | undefined): Promise<this>;
    getSigner(): SequenceSigner;
    getSigner(chainId: ChainIdLike): SingleNetworkSequenceSigner;
    getSigner(chainId?: ChainIdLike): SequenceSigner | SingleNetworkSequenceSigner;
    connect(options: ConnectOptions): Promise<ConnectDetails>;
    disconnect(): Promise<void>;
    isConnected(): boolean;
    getSession(): WalletSession | undefined;
    listAccounts(): string[];
    getAddress(): string;
    getNetworks(): Promise<NetworkConfig[]>;
    getChainId(): number;
    setDefaultChainId(chainId: ChainIdLike): void;
    isOpened(): boolean;
    closeWallet(): void;
    getWalletContext(): Promise<commons.context.VersionedContext>;
    getWalletConfig(chainId?: ChainIdLike): Promise<commons.config.Config>;
    authorize(options: ConnectOptions): Promise<ConnectDetails>;
    openWallet(path?: string, intent?: OpenWalletIntent): Promise<boolean>;
    toChainId(chainId: ChainIdLike): number;
    toChainId(chainId?: ChainIdLike): number | undefined;
    /**
     *  Resolves the chainId to use for the given request. If no chainId is provided,
     *  it uses the chainId defined by the client (default chainId). This can be
     *  overriden to build a single-network SequenceProvider.
     */
    protected useChainId(chainId?: ChainIdLike): Promise<number>;
    /**
     *  This generates a provider that ONLY works for the given chainId.
     *  the generated provider can't switch networks, and can't handle requests
     *  for other networks.
     */
    getProvider(): SequenceProvider;
    getProvider(chainId: ChainIdLike): SingleNetworkSequenceProvider;
    getProvider(chainId?: ChainIdLike): SequenceProvider | SingleNetworkSequenceProvider;
    /**
     *  This returns a subprovider, this is a regular non-sequence provider that
     *  can be used to fulfill read only requests on a given network.
     */
    _getSubprovider(chainId?: ChainIdLike): Promise<ethers.JsonRpcProvider>;
    _perform(req: ethers.PerformActionRequest): Promise<any>;
    perform(method: string, params: any): Promise<any>;
    send(method: string, params: any): Promise<any>;
    request(request: {
        method: string;
        params?: any[] | undefined;
    }): Promise<any>;
    _detectNetwork(): Promise<ethers.Network>;
    detectNetwork(): Promise<ethers.Network>;
    waitForTransaction(transactionHash: string, confirmations?: number, timeout?: number, optionals?: OptionalChainIdLike): Promise<ethers.TransactionReceipt | null>;
    getBlockNumber(optionals?: OptionalChainIdLike): Promise<number>;
    getFeeData(optionals?: OptionalChainIdLike): Promise<ethers.FeeData>;
    getBalance(addressOrName: string | Promise<string>, blockTag?: ethers.BlockTag, optionals?: OptionalChainIdLike): Promise<bigint>;
    getTransactionCount(addressOrName: string | Promise<string>, blockTag?: ethers.BlockTag, optionals?: OptionalChainIdLike): Promise<number>;
    getCode(addressOrName: string | Promise<string>, blockTag?: ethers.BlockTag, optionals?: OptionalChainIdLike): Promise<string>;
    getStorage(addressOrName: string | Promise<string>, position: ethers.BigNumberish, blockTag?: ethers.BlockTag, optionals?: OptionalChainIdLike): Promise<string>;
    call(transaction: ethers.TransactionRequest, optionals?: OptionalChainIdLike): Promise<string>;
    estimateGas(transaction: ethers.TransactionRequest, optionals?: OptionalChainIdLike): Promise<bigint>;
    getBlock(blockHashOrBlockTag: ethers.BlockTag | string, prefetchTxs?: boolean, optionals?: OptionalChainIdLike): Promise<ethers.Block | null>;
    getTransaction(transactionHash: string, optionals?: OptionalChainIdLike): Promise<ethers.TransactionResponse | null>;
    getLogs(filter: ethers.Filter, optionals?: OptionalChainIdLike): Promise<ethers.Log[]>;
    supportsENS(): Promise<boolean>;
    getResolver(name: string): Promise<ethers.EnsResolver | null>;
    resolveName(name: string): Promise<string | null>;
    lookupAddress(address: string): Promise<string | null>;
    getAvatar(nameOrAddress: string): Promise<string | null>;
    static is: (provider: any) => provider is SequenceProvider;
}
/**
 *  This is the same provider, but it only allows a single network at a time.
 *  the network defined by the constructor is the only one that can be used.
 *
 *  Attempting to call any method with a different network will throw an error.
 *  Attempting to change the network of this provider will throw an error.
 *
 *  NOTICE: These networks won't support ENS unless they are the mainnet.
 */
export declare class SingleNetworkSequenceProvider extends SequenceProvider {
    readonly chainId: ChainIdLike;
    readonly _isSingleNetworkSequenceProvider = true;
    constructor(client: SequenceClient, providerFor: (networkId: number) => ethers.JsonRpcProvider, chainId: ChainIdLike, options?: ethers.AbstractProviderOptions);
    private _useChainId;
    protected useChainId(chainId?: ChainIdLike): Promise<number>;
    getChainId(): number;
    getNetwork(): Promise<ethers.Network>;
    /**
     *  Override getProvider and getSigner so they always use `useChainId`
     *  this way they can't return providers and signers that can switch networks,
     *  or that don't match the chainId of this signer.
     */
    getProvider(chainId?: ChainIdLike): SingleNetworkSequenceProvider;
    getSigner(chainId?: ChainIdLike): SingleNetworkSequenceSigner;
    setDefaultChainId(_chainId: ChainIdLike): void;
    static is(cand: any): cand is SingleNetworkSequenceProvider;
}
export {};
