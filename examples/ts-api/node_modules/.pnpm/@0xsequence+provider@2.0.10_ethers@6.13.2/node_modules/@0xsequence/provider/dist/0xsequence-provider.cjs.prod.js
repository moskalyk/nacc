'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var abi = require('@0xsequence/abi');
var core = require('@0xsequence/core');
var ethers = require('ethers');
var eventemitter2 = require('eventemitter2');
var utils = require('@0xsequence/utils');
var network = require('@0xsequence/network');
var auth = require('@0xsequence/auth');
var tracker = require('@databeat/tracker');

const PROHIBITED_FUNCTIONS = new Map(['addHook(bytes4,address)', 'clearExtraImageHashes(bytes32[])', 'removeHook(bytes4)', 'setExtraImageHash(bytes32,uint256)', 'updateIPFSRoot(bytes32)', 'updateImageHash(bytes32)', 'updateImageHashAndIPFS(bytes32,bytes32)', 'updateImplementation(address)'].map(signature => [ethers.ethers.id(signature).slice(0, 10), signature]));
function validateTransactionRequest(wallet, transaction) {
  const transactions = core.commons.transaction.fromTransactionish(wallet, transaction);
  const unwound = core.commons.transaction.unwind(wallet, transactions);
  unwound.forEach(transaction => validateTransaction(wallet, transaction));
}
function validateTransaction(wallet, transaction) {
  if (transaction.to.toLowerCase() === wallet.toLowerCase()) {
    if (transaction.data) {
      const data = ethers.ethers.getBytes(transaction.data);
      if (data.length >= 4 && !isCreateContractCall(data)) {
        throw new Error('self calls are forbidden');
      }
    }
  }
  if (transaction.delegateCall) {
    throw new Error('delegate calls are forbidden');
  }
  if (transaction.data) {
    const data = ethers.ethers.hexlify(transaction.data);
    const selector = data.slice(0, 10);
    const signature = PROHIBITED_FUNCTIONS.get(selector);
    if (signature) {
      const name = signature.slice(0, signature.indexOf('('));
      throw new Error(`${name} calls are forbidden`);
    }
  }
}
function isCreateContractCall(data) {
  const walletInterface = new ethers.ethers.Interface(abi.walletContracts.mainModule.abi);
  try {
    walletInterface.decodeFunctionData('createContract', data);
    return true;
  } catch (_unused) {
    return false;
  }
}

function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}

function isProviderTransport(transport) {
  return transport && typeof transport === 'object' && typeof transport.register === 'function' && typeof transport.unregister === 'function' && typeof transport.openWallet === 'function' && typeof transport.closeWallet === 'function' && typeof transport.isOpened === 'function' && typeof transport.isConnected === 'function' && typeof transport.on === 'function';
}

// Older versions of sequence.js will require a JsonRpcResponse result type, but newer versions use raw EIP1193 results

// ProviderMessageCallback is used to respond to ProviderMessage requests. The error
// argument is for exceptions during the execution, and response is the response payload
// which may contain the result or an error payload from the wallet.

// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging

// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging
class WindowSessionParams extends URLSearchParams {
  static new(init) {
    return new URLSearchParams(init);
  }
}
let EventType = /*#__PURE__*/function (EventType) {
  EventType["OPEN"] = "open";
  EventType["CLOSE"] = "close";
  EventType["MESSAGE"] = "message";
  EventType["CONNECT"] = "connect";
  EventType["DISCONNECT"] = "disconnect";
  EventType["ACCOUNTS_CHANGED"] = "accountsChanged";
  EventType["CHAIN_CHANGED"] = "chainChanged";
  EventType["NETWORKS"] = "networks";
  EventType["WALLET_CONTEXT"] = "walletContext";
  EventType["INIT"] = "init";
  EventType["DEBUG"] = "_debug";
  return EventType;
}({});
let OpenState = /*#__PURE__*/function (OpenState) {
  OpenState[OpenState["CLOSED"] = 0] = "CLOSED";
  OpenState[OpenState["OPENING"] = 1] = "OPENING";
  OpenState[OpenState["OPENED"] = 2] = "OPENED";
  return OpenState;
}({});
let InitState = /*#__PURE__*/function (InitState) {
  InitState[InitState["NIL"] = 0] = "NIL";
  InitState[InitState["SENT_NONCE"] = 1] = "SENT_NONCE";
  InitState[InitState["OK"] = 2] = "OK";
  return InitState;
}({});

/** Options to further customize the wallet experience. */

/** light and dark are the main themes, to use other themes in wallet settings,
 * you can use the camel case version of the name in the wallet settings.
 * For example: "Blue Dark" on wallet UI can be passed as "blueDark" */

// | 'large'

class ProviderError extends Error {
  constructor(message) {
    super(message);
    this.name = 'ProviderError';
  }
}
const ErrSignedInRequired = new ProviderError('Wallet is not signed in. Connect a wallet and try again.');

// TODO: lets build some nice error handling tools, prob in /utils ...

const PROVIDER_OPEN_TIMEOUT = 30000; // in ms

let _messageIdx = 0;
const nextMessageIdx = () => ++_messageIdx;
class BaseProviderTransport {
  constructor() {
    var _this = this;
    this.pendingMessageRequests = [];
    this.responseCallbacks = new Map();
    this.state = void 0;
    this.confirmationOnly = false;
    this.events = new eventemitter2.EventEmitter2();
    this.openPayload = void 0;
    this.connectPayload = void 0;
    this.accountsChangedPayload = void 0;
    this.networksPayload = void 0;
    this.walletContextPayload = void 0;
    this._sessionId = void 0;
    this._init = void 0;
    this._registered = void 0;
    // sendMessageRequest sends a ProviderMessageRequest over the wire to the wallet
    this.sendMessageRequest = async function (message) {
      return new Promise((resolve, reject) => {
        if ((!message.idx || message.idx <= 0) && message.type !== 'init') {
          reject(new Error('message idx not set'));
        }
        const responseCallback = (error, response) => {
          if (error) {
            reject(error);
          } else if (response) {
            resolve(response);
          } else {
            throw new Error('no valid response to return');
          }
        };
        const idx = message.idx;
        if (!_this.responseCallbacks.get(idx)) {
          _this.responseCallbacks.set(idx, responseCallback);
        } else {
          reject(new Error('duplicate message idx, should never happen'));
        }
        if (!_this.isOpened()) {
          utils.logger.debug('pushing to pending requests', message);
          _this.pendingMessageRequests.push(message);
        } else {
          _this.sendMessage(message);
        }
      });
    };
    this.waitUntilOpened = async function (openTimeout = PROVIDER_OPEN_TIMEOUT) {
      let opened = false;
      return Promise.race([new Promise((_, reject) => {
        const timeout = setTimeout(() => {
          clearTimeout(timeout);
          // only emit close if the timeout wins the race
          if (!opened) {
            _this.state = OpenState.CLOSED;
            _this.events.emit('close', {
              code: 1005,
              message: 'opening wallet timed out'
            });
          }
          reject(new Error('opening wallet timed out'));
        }, openTimeout);
      }), new Promise(resolve => {
        if (_this.isOpened()) {
          var _this$openPayload;
          opened = true;
          resolve((_this$openPayload = _this.openPayload) == null ? void 0 : _this$openPayload.session);
          return;
        }
        _this.events.once('open', openInfo => {
          _this.openPayload = openInfo;
          opened = true;
          resolve(openInfo.session);
        });
      })]);
    };
    this.waitUntilConnected = async function () {
      await _this.waitUntilOpened();
      const connect = new Promise(resolve => {
        if (_this.connectPayload) {
          resolve(_this.connectPayload);
          return;
        }
        _this.events.once('connect', connectDetails => {
          _this.connectPayload = connectDetails;
          resolve(connectDetails);
        });
      });
      const closeWallet = new Promise((_, reject) => {
        _this.events.once('close', error => {
          if (error) {
            reject(new Error(`wallet closed due to ${JSON.stringify(error)}`));
          } else {
            reject(new Error(`user closed the wallet`));
          }
        });
      });
      return Promise.race([connect, closeWallet]);
    };
    this.state = OpenState.CLOSED;
    this._registered = false;
    this._init = InitState.NIL;
  }
  get registered() {
    return this._registered;
  }
  register() {
    throw new Error('abstract method');
  }
  unregister() {
    throw new Error('abstract method');
  }
  openWallet(path, intent, networkId) {
    throw new Error('abstract method');
  }
  closeWallet() {
    throw new Error('abstract method');
  }
  isOpened() {
    return this.registered && this.state === OpenState.OPENED;
  }
  isConnected() {
    var _this$openPayload2;
    // if we're registered, and we have the account details, then we are connected
    const session = (_this$openPayload2 = this.openPayload) == null ? void 0 : _this$openPayload2.session;
    return this.registered && session !== undefined && !!session.accountAddress && session.accountAddress.length === 42 && !!session.networks && session.networks.length > 0;
  }
  async request(request) {
    if (this.state === OpenState.CLOSED) {
      // flag the wallet to auto-close once user submits input. ie.
      // prompting to sign a message or transaction
      this.confirmationOnly = true;
    }

    // open/focus the wallet.
    // automatically open the wallet when a provider request makes it here.
    //
    // NOTE: if we're not signed in, then the provider will fail, users must first connect+sign in.
    //
    // TODO: how does this behave with a session has expired?
    this.openWallet(undefined, {
      type: 'jsonRpcRequest',
      method: request.method
    }, request.chainId);
    if (!this.isOpened()) {
      await this.waitUntilOpened(); // will throw on timeout
    }
    const response = await this.sendMessageRequest({
      idx: nextMessageIdx(),
      type: EventType.MESSAGE,
      data: request,
      chainId: request.chainId,
      clientVersion: core.VERSION
    });
    return response.data;
  }

  // handleMessage will handle message received from the remote wallet
  handleMessage(message) {
    var _this2 = this;
    // init incoming for initial handshake with transport.
    // always respond to INIT messages, e.g. on popup window reload
    if (message.type === EventType.INIT) {
      utils.logger.debug('MessageProvider, received INIT message', message);
      const {
        nonce
      } = message.data;
      if (!nonce || nonce.length == 0) {
        utils.logger.error('invalid init nonce');
        return;
      }
      this._init = InitState.OK;
      this.sendMessage({
        idx: -1,
        type: EventType.INIT,
        data: {
          sessionId: this._sessionId,
          nonce: nonce
        },
        clientVersion: core.VERSION
      });
    }
    if (this._init !== InitState.OK) {
      // if provider is not init'd, then we drop any received messages. the only
      // message we will process is of event type 'init', as our acknowledgement
      return;
    }

    // message is either a notification, or its a ProviderMessageResponse
    utils.logger.debug('RECEIVED MESSAGE FROM WALLET', message.idx, message);
    const requestIdx = message.idx;
    const responseCallback = this.responseCallbacks.get(requestIdx);
    if (requestIdx) {
      this.responseCallbacks.delete(requestIdx);
    }

    // OPEN response
    //
    // Flip opened flag, and flush the pending queue
    if (message.type === EventType.OPEN && !this.isOpened()) {
      var _message$data, _message$data2;
      if (this._sessionId && this._sessionId !== ((_message$data = message.data) == null ? void 0 : _message$data.sessionId)) {
        utils.logger.debug('open event received from wallet, but does not match sessionId', this._sessionId);
        return;
      }

      // check if open error occured due to invalid defaultNetworkId
      if ((_message$data2 = message.data) != null && _message$data2.error) {
        var _message$data3;
        const err = new Error(`opening wallet failed: received ${(_message$data3 = message.data) == null ? void 0 : _message$data3.error}`);
        utils.logger.error(err);
        this.close();
        throw err;
      }

      // success!
      this.state = OpenState.OPENED;
      this.openPayload = message.data;
      this.events.emit('open', this.openPayload);

      // flush pending requests when connected
      if (this.pendingMessageRequests.length !== 0) {
        const pendingMessageRequests = this.pendingMessageRequests.splice(0, this.pendingMessageRequests.length);
        pendingMessageRequests.forEach(async function (pendingMessageRequest) {
          _this2.sendMessage(pendingMessageRequest);
        });
      }
      return;
    }

    // MESSAGE resposne
    if (message.type === EventType.MESSAGE) {
      // Require user confirmation, bring up wallet to prompt for input then close
      // TODO: perhaps apply technique like in multicall to queue messages within
      // a period of time, then close the window if responseCallbacks is empty, this is better.
      if (this.confirmationOnly) {
        setTimeout(() => {
          if (this.responseCallbacks.size === 0) {
            this.closeWallet();
          }
        }, 500); // TODO: be smarter about timer as we're processing the response callbacks..
      }
      if (!responseCallback) {
        // NOTE: this would occur if 'idx' isn't set, which should never happen
        // or when we register two handler, or duplicate messages with the same idx are sent,
        // all of which should be prevented prior to getting to this point
        throw new Error('impossible state');
      }

      // Callback to original caller
      if (responseCallback) {
        this.events.emit('message', message);
        responseCallback(message.data.error, message);
        return;
      }
    }

    // ACCOUNTS_CHANGED -- when a user logs in or out
    if (message.type === EventType.ACCOUNTS_CHANGED) {
      this.accountsChangedPayload = {
        accounts: []
      };
      if (message.data && message.data.length > 0) {
        this.accountsChangedPayload = {
          accounts: [ethers.ethers.getAddress(message.data[0])],
          origin: message.origin
        };
        this.events.emit('accountsChanged', this.accountsChangedPayload.accounts, this.accountsChangedPayload.origin);
      } else {
        this.events.emit('accountsChanged', [], message.origin);
      }
      return;
    }

    // CHAIN_CHANGED -- when a user changes their default chain
    if (message.type === EventType.CHAIN_CHANGED) {
      this.events.emit('chainChanged', message.data, message.origin);
      return;
    }

    // NOTIFY NETWORKS -- when a user connects or logs in
    if (message.type === EventType.NETWORKS) {
      this.networksPayload = message.data;
      this.events.emit('networks', this.networksPayload);
      return;
    }

    // NOTIFY WALLET_CONTEXT -- when a user connects or logs in
    if (message.type === EventType.WALLET_CONTEXT) {
      this.walletContextPayload = message.data;
      this.events.emit('walletContext', this.walletContextPayload);
      return;
    }

    // NOTIFY CLOSE -- when wallet instructs to close
    if (message.type === EventType.CLOSE) {
      if (this.state !== OpenState.CLOSED) {
        this.close(message.data);
      }
    }

    // NOTIFY CONNECT -- when wallet instructs we've connected
    if (message.type === EventType.CONNECT) {
      this.connectPayload = message.data;
      this.events.emit('connect', this.connectPayload);
    }

    // NOTIFY DISCONNECT -- when wallet instructs to disconnect
    if (message.type === EventType.DISCONNECT) {
      if (this.isConnected()) {
        this.events.emit('disconnect', message.data, message.origin);
        this.close();
      }
    }
  }
  sendMessage(message) {
    throw new Error('abstract method');
  }
  on(event, fn) {
    this.events.on(event, fn);
  }
  once(event, fn) {
    this.events.once(event, fn);
  }
  emit(event, ...args) {
    return this.events.emit(event, ...args);
  }
  close(error) {
    if (this.state === OpenState.CLOSED) return;
    this.state = OpenState.CLOSED;
    this.confirmationOnly = false;
    this._sessionId = undefined;
    utils.logger.info('closing wallet and flushing!');

    // flush pending requests and return error to all callbacks
    this.pendingMessageRequests.length = 0;
    this.responseCallbacks.forEach(responseCallback => {
      responseCallback(_extends({}, new Error('wallet closed'), {
        code: 4001
      }));
    });
    this.responseCallbacks.clear();
    this.connectPayload = undefined;
    this.openPayload = undefined;
    this.accountsChangedPayload = undefined;
    this.networksPayload = undefined;
    this.walletContextPayload = undefined;
    this.events.emit('close', error);
  }
}

function messageIsExemptFromEIP191Prefix(message) {
  return EIP_191_PREFIX_EXCEPTIONS.some(e => e.predicate(message));
}
const EIP_191_PREFIX_EXCEPTIONS = [
// NOTE: Decentraland does not support 191 correctly.
{
  name: 'Decentraland Exception',
  predicate: isDecentralandLoginMessage
},
// NOTE: 0x v3 does not support 191 correctly.
// See https://gov.0x.org/t/zeip-proposal-fix-v3-eip-191-non-compliance-when-validating-eip-1271-signatures/3396 for more info.
{
  name: '0x v3 Exception',
  predicate: isZeroExV3Order
}];
const DCL_REGEX = /^Decentraland Login\nEphemeral address: 0x[a-fA-F0-9]{40}\nExpiration: (\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)((-(\d{2}):(\d{2})|Z)?)$/;
function isDecentralandLoginMessage(bytes) {
  try {
    const stringified = ethers.ethers.toUtf8String(bytes);
    return DCL_REGEX.test(stringified);
  } catch (_unused) {
    return false;
  }
}

// try to interpret bytes as abi-encoded 0x v3 OrderWithHash -
// see https://github.com/0xProject/0x-protocol-specification/blob/master/v3/v3-specification.md
function isZeroExV3Order(bytes) {
  const abi = new ethers.ethers.Interface(ZeroXV3EIP1271OrderWithHashAbi);
  try {
    abi.decodeFunctionData('OrderWithHash', bytes);
    return true;
  } catch (err) {
    // failed to decode ABI, so it's not a v3 order.
    return false;
  }
}
const ZeroXV3EIP1271OrderWithHashAbi = [{
  inputs: [{
    components: [{
      internalType: 'address',
      name: 'makerAddress',
      type: 'address'
    }, {
      internalType: 'address',
      name: 'takerAddress',
      type: 'address'
    }, {
      internalType: 'address',
      name: 'feeRecipientAddress',
      type: 'address'
    }, {
      internalType: 'address',
      name: 'senderAddress',
      type: 'address'
    }, {
      internalType: 'uint256',
      name: 'makerAssetAmount',
      type: 'uint256'
    }, {
      internalType: 'uint256',
      name: 'takerAssetAmount',
      type: 'uint256'
    }, {
      internalType: 'uint256',
      name: 'makerFee',
      type: 'uint256'
    }, {
      internalType: 'uint256',
      name: 'takerFee',
      type: 'uint256'
    }, {
      internalType: 'uint256',
      name: 'expirationTimeSeconds',
      type: 'uint256'
    }, {
      internalType: 'uint256',
      name: 'salt',
      type: 'uint256'
    }, {
      internalType: 'bytes',
      name: 'makerAssetData',
      type: 'bytes'
    }, {
      internalType: 'bytes',
      name: 'takerAssetData',
      type: 'bytes'
    }, {
      internalType: 'bytes',
      name: 'makerFeeAssetData',
      type: 'bytes'
    }, {
      internalType: 'bytes',
      name: 'takerFeeAssetData',
      type: 'bytes'
    }],
    internalType: 'struct IEIP1271Data.Order',
    name: 'order',
    type: 'tuple'
  }, {
    internalType: 'bytes32',
    name: 'orderHash',
    type: 'bytes32'
  }],
  name: 'OrderWithHash',
  outputs: [],
  stateMutability: 'pure',
  type: 'function'
}];

const eip191prefix = ethers.ethers.toUtf8Bytes('\x19Ethereum Signed Message:\n');
const messageToBytes = message => {
  if (ethers.ethers.isBytesLike(message)) {
    return ethers.ethers.getBytes(message);
  }
  return ethers.ethers.toUtf8Bytes(message);
};
const prefixEIP191Message = message => {
  const messageBytes = messageToBytes(message);
  if (messageIsExemptFromEIP191Prefix(messageBytes)) {
    return messageBytes;
  } else {
    return ethers.ethers.getBytes(ethers.ethers.concat([eip191prefix, ethers.ethers.toUtf8Bytes(String(messageBytes.length)), messageBytes]));
  }
};
const trimEIP191Prefix = prefixedMessage => {
  // If the message is not prefixed, we return the message as is.
  if (JSON.stringify(prefixedMessage.slice(0, eip191prefix.length)) !== JSON.stringify(eip191prefix)) {
    return prefixedMessage;
  }

  // We have two parts to remove.
  // First is the EIP-191 prefix.
  const ethereumSignedMessagePartSlicedArray = prefixedMessage.slice(eip191prefix.length);

  // Second is the digits added which represent length of the message without the prefix
  // and we need to find the prefix that will match this.
  // Here first we take the max prefix char length, and check if as a number it is bigger
  // than the length of the message (since prefix is added to represent length of original message),
  // if it is we remove 1 from char length, if not we keep the max prefix char length.
  // As an example for the case where , if the message is 123456789, the expected prefix char is 9, with starting value 9123456789
  // the char length of the total message with the prefix is 10, so the max prefix char length we start is 2 from [1,0], and as a number 10, it is longer
  // than the length of the message after removing prefix (10 - 2 = 8), so we slice 1 char less, which is 9, and we get the correct prefix.
  const maxPrefixCharLength = String(ethereumSignedMessagePartSlicedArray.length).length;
  let prefixCharLenght;
  let prefixAsNumber;
  try {
    prefixAsNumber = Number(ethers.ethers.toUtf8String(ethereumSignedMessagePartSlicedArray.slice(0, maxPrefixCharLength)));
  } catch (_unused) {
    prefixAsNumber = Number(ethers.ethers.hexlify(ethereumSignedMessagePartSlicedArray.slice(0, maxPrefixCharLength)));
  }
  if (prefixAsNumber > ethereumSignedMessagePartSlicedArray.length || !Number.isInteger(prefixAsNumber)) {
    prefixCharLenght = maxPrefixCharLength - 1;
  } else {
    prefixCharLenght = maxPrefixCharLength;
  }
  const prefixRevertedMessage = ethereumSignedMessagePartSlicedArray.slice(prefixCharLenght);
  return prefixRevertedMessage;
};
const isValidSignature = async (address, digest, sig, provider) => {
  const reader = new core.commons.reader.OnChainReader(provider);
  return reader.isValidSignature(address, digest, sig);
};

// Verify message signature
const isValidMessageSignature = async (address, message, signature, provider) => {
  const prefixed = prefixEIP191Message(message);
  const digest = utils.encodeMessageDigest(prefixed);
  return isValidSignature(address, digest, signature, provider);
};

// Verify typedData signature
const isValidTypedDataSignature = (address, typedData, signature, provider) => {
  return isValidSignature(address, utils.encodeTypedDataDigest(typedData), signature, provider);
};
const isBrowserExtension = () => window.location.protocol === 'chrome-extension:' || window.location.protocol === 'moz-extension:';
const isUnityPlugin = () => !!navigator.userAgent.match(/UnitySequence/i);

// /**
//  * Returns the status of a signer's wallet on given chain by checking wallet deployment and config status
//  *
//  * @param {Status} of the wallet
//  */
const isWalletUpToDate = status => {
  return status.onChain.deployed && status.fullyMigrated;
};
class MemoryItemStore {
  constructor() {
    this.callbacks = [];
    this.store = {};
  }
  getItem(key) {
    return this.store[key] || null;
  }
  setItem(key, value) {
    this.store[key] = value;
    this.callbacks.filter(c => c.key === key).forEach(c => c.cb(value));
  }
  removeItem(key) {
    delete this.store[key];
  }
  onItemChange(key, cb) {
    this.callbacks.push({
      key,
      cb
    });
    return () => {
      this.callbacks = this.callbacks.filter(c => c.cb !== cb);
    };
  }
}
class LocalStorage {
  static isAvailable() {
    return typeof window === 'object' && typeof window.localStorage === 'object';
  }
  constructor() {
    this.callbacks = [];
    if (!LocalStorage.isAvailable()) {
      throw new Error('LocalStorage is not available');
    }
    window.addEventListener('storage', e => {
      const {
        key
      } = e;
      const cb = this.callbacks.filter(c => c.key === key);
      cb.forEach(c => c.cb(this.getItem(key)));
    });
  }
  getItem(key) {
    return window.localStorage.getItem(key);
  }
  setItem(key, value) {
    window.localStorage.setItem(key, value);

    // Trigger callbacks
    // NOTICE: the event is not triggered on the same window
    this.callbacks.filter(c => c.key === key).forEach(c => c.cb(value));
  }
  removeItem(key) {
    window.localStorage.removeItem(key);

    // Trigger callbacks
    // NOTICE: the event is not triggered on the same window
    this.callbacks.filter(c => c.key === key).forEach(c => c.cb(null));
  }
  onItemChange(key, cb) {
    this.callbacks.push({
      key,
      cb
    });
    return () => {
      this.callbacks = this.callbacks.filter(c => c.cb !== cb);
    };
  }
}
function useBestStore() {
  if (LocalStorage.isAvailable()) {
    return new LocalStorage();
  }
  return new MemoryItemStore();
}
async function resolveArrayProperties(object) {
  if (Array.isArray(object)) {
    // T must include array type
    return Promise.all(object.map(o => ethers.ethers.resolveProperties(o)));
  }
  return ethers.ethers.resolveProperties(object);
}

const TRANSPORT_SESSION_LS_KEY = '@sequence.transportSession';
class BaseWalletTransport {
  constructor(walletRequestHandler) {
    var _this = this;
    this.walletRequestHandler = void 0;
    this._sessionId = void 0;
    this._registered = void 0;
    this._init = void 0;
    this._initNonce = void 0;
    this._initCallback = void 0;
    // appOrigin identifies the dapp's origin which opened the app. A transport
    // will auto-detect and set this value if it can. This is determined
    // as the parent app/window which opened the wallet.
    this.appOrigin = void 0;
    this.handleMessage = async function (message) {
      const request = message;

      // ensure initial handshake is complete before accepting
      // other kinds of messages.
      if (_this._init !== InitState.OK) {
        if (request.type === EventType.INIT) {
          if (_this.isValidInitAck(message)) {
            // successful init
            if (_this._initCallback) _this._initCallback();
          } else {
            // failed init
            if (_this._initCallback) _this._initCallback('invalid init');
            return;
          }
        }
        return;
      }

      // ensure signer is ready to handle requests
      // if (this.walletRequestHandler.getSigner() === undefined) {
      //   await this.walletRequestHandler.signerReady()
      // }

      // handle request
      switch (request.type) {
        case EventType.OPEN:
          {
            if (_this._init !== InitState.OK) return;
            const session = {
              sessionId: request.data.sessionId,
              intent: request.data.intent,
              networkId: request.data.networkId
            };
            await _this.open(session);
            return;
          }
        case EventType.CLOSE:
          {
            if (_this._init !== InitState.OK) return;
            // noop. just here to capture the message so event emitters may be notified
            return;
          }
        case EventType.MESSAGE:
          {
            const response = await _this.walletRequestHandler.sendMessageRequest(request);
            _this.sendMessage(response);
            if (response.data.error) ;
            return;
          }
        default:
          {
            utils.logger.error(`unexpected payload type ${request.type}`);
          }
      }
    };
    // sendMessageRequest sends a ProviderMessageRequest to the wallet post-message transport
    this.sendMessageRequest = async function (message) {
      return _this.walletRequestHandler.sendMessageRequest(message);
    };
    this.open = async function ({
      sessionId,
      intent,
      networkId
    }) {
      if (sessionId) {
        _this._sessionId = utils.sanitizeNumberString(sessionId);
        // persist transport session in localstorage for restoring after redirect/reload
        _this.saveTransportSession({
          sessionId,
          intent,
          networkId
        });
      }
      _this.walletRequestHandler.setOpenIntent(intent);

      // init handshake for certain transports, before we can open the communication.
      //
      // for example, with the window-transport, we have to exchange messages to determine the
      // origin host of the dapp.
      await _this.init();

      // determine chainId from networkId (string or number)
      let chainId = undefined;
      try {
        if (networkId) {
          const network$1 = network.findSupportedNetwork(networkId);
          if (network$1) {
            chainId = network$1.chainId;
          } else {
            throw new Error(`unknown network ${networkId}`);
          }
        } else {
          // if not provided, use defaultChainId
          chainId = _this.walletRequestHandler.defaultChainId();
        }
      } catch (err) {
        console.error(err);
      }

      // Prepare connect options from intent
      if (intent && intent.type === 'connect' && intent.options) {
        const connectOptions = intent.options;
        const authorizeOptions = connectOptions; // overlapping types

        // Sanity/integrity check the intent payload, and set authorization origin
        // if its been determined as part of the init handshake from earlier.
        if (_this.appOrigin && authorizeOptions != null && authorizeOptions.origin) {
          if (!isBrowserExtension()) {
            if (authorizeOptions.origin !== _this.appOrigin) {
              throw new Error('origin is invalid');
            }
          }
        } else if (!_this.appOrigin && authorizeOptions != null && authorizeOptions.origin) {
          // ie. when we can't determine the origin in our transport, but dapp provides it to us.
          // we just sanitize the origin host.
          connectOptions.origin = utils.sanitizeHost(authorizeOptions.origin);
        } else if (_this.appOrigin) {
          // ie. when we auto-determine the origin such as in window-transport
          connectOptions.origin = _this.appOrigin;
        }
        if (connectOptions.app) {
          connectOptions.app = utils.sanitizeAlphanumeric(connectOptions.app);
        }
        if (connectOptions.networkId) {
          networkId = connectOptions.networkId;
        } else if (networkId) {
          connectOptions.networkId = networkId;
        }

        // Set connect options on the walletRequestHandler as our primary
        // wallet controller, and fall back to networkId if necessary
        _this.walletRequestHandler.setConnectOptions(connectOptions);
      } else {
        _this.walletRequestHandler.setConnectOptions(undefined);
      }

      // ensure signer is ready
      await _this.walletRequestHandler.getAccount();

      // Notify open and proceed to prompt for connection if intended
      if (!(await _this.walletRequestHandler.isSignedIn())) {
        // open wallet without a specific connected chainId, as the user is not signed in
        _this.notifyOpen({
          sessionId: _this._sessionId
        });
        return true;
      } else {
        // prompt user with a connect request. the options will be used as previously set above.
        // upon success, the walletRequestHandler will notify the dapp with the ConnectDetails.
        // upon cancellation by user, the walletRequestHandler will throw an error

        if (intent && intent.type === 'connect') {
          // Failed to set default network on open
          // Fail silently here so we can continue with connect flow and ask
          // user to connect on a different network if necessary
          if (!chainId || chainId <= 0) {
            console.log('Failed to set default network on open');
          }

          // notify wallet is opened, without session details
          _this.notifyOpen({
            sessionId: _this._sessionId
          });
          try {
            const connectDetails = await _this.walletRequestHandler.promptConnect(intent.options);
            if (connectDetails.connected) {
              _this.walletRequestHandler.notifyConnect(connectDetails);
            }
          } catch (err) {
            utils.logger.warn('promptConnect not connected:', err);
          } finally {
            // auto-close by default, unless intent is to keep open
            if (!intent.options || intent.options.keepWalletOpened !== true) {
              _this.notifyClose();
            }
          }
        } else {
          // Using default network

          // Failed to set default network on open -- quit + close
          if (!chainId || chainId <= 0) {
            _this.notifyOpen({
              sessionId: _this._sessionId,
              error: `failed to open wallet on network ${networkId}`
            });
            return false;
          }

          // user is already connected, notify session details.
          // TODO: in future, keep list if 'connected' dapps / sessions in the session
          // controller, and only sync with allowed apps
          _this.notifyOpen({
            sessionId: _this._sessionId,
            chainId: `${chainId}`,
            session: await _this.walletRequestHandler.walletSession(chainId)
          });
        }
      }
      return true;
    };
    this.saveTransportSession = session => {
      useBestStore().setItem(TRANSPORT_SESSION_LS_KEY, JSON.stringify(session));
    };
    this.getCachedTransportSession = async function () {
      const session = useBestStore().getItem(TRANSPORT_SESSION_LS_KEY);
      try {
        return session ? JSON.parse(session) : null;
      } catch (err) {
        console.error(`unable to parse transport session: ${session}`);
        return null;
      }
    };
    this.walletRequestHandler = walletRequestHandler;
    this._init = InitState.NIL;
    this.walletRequestHandler.on('connect', connectDetails => {
      if (!this.registered) return;
      // means user has logged in and wallet is connected to the app
      this.notifyConnect(connectDetails);
    });
    this.walletRequestHandler.on('disconnect', (error, origin) => {
      if (!this.registered) return;
      // means user has logged out the app / disconnected wallet from the app
      this.notifyDisconnect(error, origin);
    });
    this.walletRequestHandler.on('accountsChanged', (accounts, origin) => {
      if (!this.registered) return;
      this.notifyAccountsChanged(accounts, origin);
    });
    this.walletRequestHandler.on('networks', networks => {
      if (!this.registered) return;
      this.notifyNetworks(networks);
      if (!networks || networks.length === 0) {
        this.notifyChainChanged('0x0');
      } else {
        this.notifyChainChanged(ethers.ethers.toQuantity(networks.find(network => network.isDefaultChain).chainId));
      }
    });
    this.walletRequestHandler.on('chainChanged', (chainIdHex, origin) => {
      this.notifyChainChanged(chainIdHex, origin);
    });
    this.walletRequestHandler.on('walletContext', walletContext => {
      if (!this.registered || !walletContext) return;
      this.notifyWalletContext(walletContext);
    });
    this.walletRequestHandler.on('close', error => {
      if (!this.registered) return;
      this.notifyClose(error);
    });
  }
  get registered() {
    return this._registered;
  }
  register() {
    throw new Error('abstract method');
  }
  unregister() {
    throw new Error('abstract method');
  }
  request(request) {
    throw new Error('abstract method');
  }
  sendMessage(message) {
    throw new Error('abstract method');
  }
  notifyOpen(openInfo) {
    const {
      chainId,
      sessionId,
      session,
      error
    } = openInfo;
    this.sendMessage({
      idx: -1,
      type: EventType.OPEN,
      data: {
        chainId,
        sessionId,
        session,
        error
      },
      clientVersion: core.VERSION
    });
  }
  notifyClose(error) {
    this.sendMessage({
      idx: -1,
      type: EventType.CLOSE,
      data: error ? {
        error
      } : null,
      clientVersion: core.VERSION
    });
  }
  notifyConnect(connectDetails) {
    this.sendMessage({
      idx: -1,
      type: EventType.CONNECT,
      data: connectDetails,
      clientVersion: core.VERSION
    });
  }
  notifyDisconnect(error, origin) {
    this.sendMessage({
      idx: -1,
      type: EventType.DISCONNECT,
      data: error ? {
        error
      } : null,
      origin,
      clientVersion: core.VERSION
    });
  }
  notifyAccountsChanged(accounts, origin) {
    this.sendMessage({
      idx: -1,
      type: EventType.ACCOUNTS_CHANGED,
      data: accounts,
      origin,
      clientVersion: core.VERSION
    });
  }
  notifyChainChanged(chainIdHex, origin) {
    this.sendMessage({
      idx: -1,
      type: EventType.CHAIN_CHANGED,
      data: chainIdHex,
      origin,
      clientVersion: core.VERSION
    });
  }
  notifyNetworks(networks) {
    this.sendMessage({
      idx: -1,
      type: EventType.NETWORKS,
      data: networks,
      clientVersion: core.VERSION
    });
  }
  notifyWalletContext(walletContext) {
    this.sendMessage({
      idx: -1,
      type: EventType.WALLET_CONTEXT,
      data: walletContext,
      clientVersion: core.VERSION
    });
  }
  isValidInitAck(message) {
    if (this._init === InitState.OK) {
      // we're already in init state, we shouldn't handle this message
      utils.logger.warn("isValidInitAck, already in init'd state, so inquiry is invalid.");
      return false;
    }
    if (message.type !== EventType.INIT) {
      utils.logger.warn('isValidInitAck, invalid message type, expecting init');
      return false;
    }
    const {
      sessionId,
      nonce
    } = message.data;
    if (!sessionId || sessionId.length === 0 || !nonce || nonce.length === 0) {
      utils.logger.error('invalid init ack');
      return false;
    }
    if (sessionId !== this._sessionId || nonce !== this._initNonce) {
      utils.logger.error('invalid init ack match');
      return false;
    }

    // all checks pass, its true
    return true;
  }
  init() {
    return new Promise((resolve, reject) => {
      // avoid re-init`ing, or if there is a transport which doesn't require
      // it, then it may set this._init to OK in its constructor.
      if (this._init === InitState.OK) {
        resolve();
        return;
      }
      if (this._init !== InitState.NIL || this._initCallback) {
        reject('transport init is in progress');
        return;
      }

      // start init timeout, if we don't receive confirmation
      // from provider within this amount of time, then we timeout
      const initTimeout = setTimeout(() => {
        utils.logger.warn('transport init timed out');
        if (this._initCallback) {
          this._initCallback('transport init timed out');
        }
      }, PROVIDER_OPEN_TIMEOUT / 2);

      // setup callback as we receive the init message async in the handleMessage function
      this._initCallback = error => {
        this._initCallback = undefined; // reset
        clearTimeout(initTimeout);
        if (error) {
          reject(error);
        } else {
          this._init = InitState.OK;
          resolve();
        }
      };

      // send init request with random nonce to the provider, where we expect
      // for the provider to echo it back to us as complete handshake
      this._initNonce = `${performance.now()}`;
      this.sendMessage({
        idx: -1,
        type: EventType.INIT,
        data: {
          nonce: this._initNonce
        },
        clientVersion: core.VERSION
      });
      this._init = InitState.SENT_NONCE;

      // NOTE: the promise will resolve in the _initCallback method
      // which will be called from either handleMessage or the initTimeout
    });
  }
}

class ProxyMessageChannel {
  constructor() {
    this.app = void 0;
    this.wallet = void 0;
    const port1 = new ProxyMessageChannelPort();
    const port2 = new ProxyMessageChannelPort();
    port1.conn = port2;
    port2.conn = port1;
    this.app = port1;
    this.wallet = port2;
  }
}
class ProxyMessageChannelPort {
  constructor() {
    this.conn = void 0;
    this.events = new eventemitter2.EventEmitter2();
    // handle messages which hit this port
    this.handleMessage = message => {
      throw new Error('ProxyMessageChannelPort is not registered');
    };
    // send messages to the connected port
    this.sendMessage = message => {
      this.conn.handleMessage(message);

      // trigger events
      if (message.type === 'open') {
        this.events.emit('open', message);
      }
      if (message.type === 'close') {
        this.events.emit('close', message);
      }
      if (message.type === 'connect') {
        this.events.emit('connect', message);
      }
      if (message.type === 'disconnect') {
        this.events.emit('disconnect', message);
      }
    };
  }
  on(event, fn) {
    this.events.on(event, fn);
  }
  once(event, fn) {
    this.events.once(event, fn);
  }
}

class ProxyMessageProvider extends BaseProviderTransport {
  constructor(port) {
    super();
    this.port = void 0;
    this.register = () => {
      this.port.handleMessage = message => {
        this.handleMessage(message);
      };
      this.on('open', (...args) => {
        this.port.events.emit('open', ...args);
      });
      this.on('close', (...args) => {
        this.port.events.emit('close', ...args);
      });
      this.on('connect', (...args) => {
        this.port.events.emit('connect', ...args);
      });
      this.on('disconnect', (...args) => {
        this.port.events.emit('disconnect', ...args);
      });
      this._registered = true;
    };
    this.unregister = () => {
      this._registered = false;
      this.closeWallet();
      this.events.removeAllListeners();
      // @ts-ignore
      this.port.handleMessage = undefined;
    };
    this.openWallet = (path, intent, networkId) => {
      if (this.state === OpenState.CLOSED) {
        this.state = OpenState.OPENING;
        const sessionId = `${performance.now()}`;
        this._sessionId = sessionId;
        this.sendMessage({
          idx: -1,
          type: EventType.OPEN,
          data: {
            path,
            intent,
            networkId,
            sessionId
          },
          clientVersion: core.VERSION
        });
      }
    };
    this.state = OpenState.CLOSED;
    this.port = port;
    if (!port) {
      throw new Error('port argument cannot be empty');
    }

    // disable init handshake for proxy-transport, we set it to OK, to
    // consider it in completed state.
    this._init = InitState.OK;
  }
  closeWallet() {
    this.sendMessage({
      idx: -1,
      type: EventType.CLOSE,
      data: null,
      clientVersion: core.VERSION
    });
    this.close();
  }
  sendMessage(message) {
    if (!message.idx) {
      throw new Error('message idx is empty');
    }
    this.port.sendMessage(message);
  }
}

class ProxyMessageHandler extends BaseWalletTransport {
  constructor(walletRequestHandler, port) {
    super(walletRequestHandler);
    this.port = void 0;
    this.port = port;
    this._init = InitState.OK;
  }
  register() {
    this.port.handleMessage = message => {
      this.handleMessage(message);
    };
    this._registered = true;
  }

  // note: we can't decide whether to restore the session within register(), because session info is
  // received asyncronously via EventType.OPEN after register() is executed.
  // And in the case of a redirect/reload, EventType.OPEN is not sent at all,
  // because the wallet is already open.
  //
  // call this method from wallet redirect hander when a session restore is needed
  async restoreSession() {
    const cachedSession = await this.getCachedTransportSession();
    if (cachedSession) {
      this.open(cachedSession);
    }
  }
  unregister() {
    // @ts-ignore
    this.port.handleMessage = undefined;
    this._registered = false;
  }
  sendMessage(message) {
    this.port.sendMessage(message);
  }
}

/**
 * This will redirect console logs from Sequence.js & the wallet to the Unreal console, for debugging purposes.
 */
function overrideLogs(side) {
  var _window$ue;
  if ((_window$ue = window.ue) != null && _window$ue.sequencewallettransport && !window.logsOverriddenForUnreal) {
    var _window$ue2;
    const t = (_window$ue2 = window.ue) == null ? void 0 : _window$ue2.sequencewallettransport;
    console.log = (...args) => {
      t.logfromjs(`${side}: ${stringify(args)}`);
    };
    console.warn = (...args) => {
      t.warnfromjs(`${side}: ${stringify(args)}`);
    };
    console.error = (...args) => {
      t.errorfromjs(`${side}: ${stringify(args)}`);
    };
    window.logsOverriddenForUnreal = true;
  }
}
function stringify(things) {
  return things.map(a => typeof a === 'object' ? a instanceof Error ? a.message : JSON.stringify(a) : String(a)).join(' ');
}

let registeredUnrealMessageProvider;

// all lowercase is an annoying limitation of Unreal CEF BindUObject

/**
 * Initialized on dApp side
 */
class UnrealMessageProvider extends BaseProviderTransport {
  constructor(walletAppURL) {
    super();
    this.walletURL = void 0;
    this.register = () => {
      var _window$ue;
      overrideLogs('dapp');
      if (registeredUnrealMessageProvider) {
        // overriding the registered message provider
        registeredUnrealMessageProvider.unregister();
        registeredUnrealMessageProvider = this;
      }

      // listen for incoming messages from wallet
      if ((_window$ue = window.ue) != null && _window$ue.sequencewallettransport) {
        window.ue.sequencewallettransport.onmessagefromwallet = this.onUnrealCallback;
      }
      registeredUnrealMessageProvider = this;
      this._registered = true;
      console.log('registering transport!');
    };
    this.unregister = () => {
      var _window$ue2;
      this._registered = false;
      this.closeWallet();

      // disable message listener
      if (registeredUnrealMessageProvider === this) {
        registeredUnrealMessageProvider = undefined;
      }
      if (((_window$ue2 = window.ue) == null || (_window$ue2 = _window$ue2.sequencewallettransport) == null ? void 0 : _window$ue2.onmessagefromwallet) === this.onUnrealCallback) {
        delete window.ue.sequencewallettransport.onmessagefromwallet;
      }

      // clear event listeners
      this.events.removeAllListeners();
    };
    this.openWallet = (path, intent, networkId) => {
      if (this.isOpened()) {
        // TODO focus wallet
        console.log('wallet already open!');
        return;
      }
      console.log('opening wallet!');
      // Instantiate new walletURL for this call
      const walletURL = new URL(this.walletURL.href);
      const windowSessionParams = new WindowSessionParams();
      if (path) {
        walletURL.pathname = path.toLowerCase();
      }

      // Set session, intent and network id on walletURL
      this._init = InitState.NIL;
      this._sessionId = `${performance.now()}`;
      windowSessionParams.set('sid', this._sessionId);
      if (intent) {
        // encode intent as base64 url-encoded param
        windowSessionParams.set('intent', utils.base64EncodeObject(intent));
      }
      if (networkId) {
        windowSessionParams.set('net', `${networkId}`);
      }
      // serialize params
      walletURL.search = windowSessionParams.toString();
      console.log('opening wallet to', walletURL.href);
      window.open(walletURL.href);
    };
    // onmessage, receives ProviderMessageResponse from the wallet unreal transport
    this.onUnrealCallback = message => {
      if (!message) {
        throw new Error('ProviderMessage object is empty');
      }

      // handle message with base message provider
      this.handleMessage(message);
    };
    this.walletURL = new URL(walletAppURL);
  }
  closeWallet() {
    this.close();
  }
  // all lowercase is an annoying limitation of Unreal CEF BindUObject
  sendMessage(message) {
    var _window$ue3;
    const postedMessage = typeof message !== 'string' ? JSON.stringify(message, utils.bigintReplacer) : message;
    console.log('Sending message to wallet:', postedMessage);
    (_window$ue3 = window.ue) == null || (_window$ue3 = _window$ue3.sequencewallettransport) == null || _window$ue3.sendmessagetowallet(postedMessage);
  }
}

// all lowercase is an annoying limitation of Unreal CEF BindUObject

/**
 * Initialized on Wallet side
 */
class UnrealMessageHandler extends BaseWalletTransport {
  constructor(walletRequestHandler) {
    super(walletRequestHandler);
    // onmessage is called when (the wallet) receives request messages from the dapp
    // over the unreal json-messaging transport
    this.onMessageFromUnreal = request => {
      // Wallet always expects json-rpc request messages from a dapp

      utils.logger.debug('RECEIVED MESSAGE', request);

      // Handle message via the base transport
      this.handleMessage(request);
    };
    this.getUnrealTransportSession = windowParams => {
      const params = new WindowSessionParams(windowParams);
      return {
        sessionId: params.get('sid'),
        networkId: params.get('net'),
        intent: utils.base64DecodeObject(params.get('intent'))
      };
    };
    this._init = InitState.NIL;
  }
  async register(windowHref) {
    var _window$ue;
    if (((_window$ue = window.ue) == null ? void 0 : _window$ue.sequencewallettransport) === undefined) {
      return;
    }
    overrideLogs('wallet');

    // record open details (sessionId + default network) from the window url
    const {
      search: rawParams
    } = new URL(windowHref || window.location.href);
    let session = this.getUnrealTransportSession(rawParams);

    // provider should always include sid when opening a new window
    const isNewWindowSession = !!session.sessionId;

    // attempt to restore previous session in the case of a redirect or window reload
    if (!isNewWindowSession) {
      session = await this.getCachedTransportSession();
    }
    if (!session) {
      utils.logger.error('unreal session is undefined');
      return;
    }

    // listen for window-transport requests
    window.ue.sequencewallettransport.onmessagefromsequencejs = this.onMessageFromUnreal;
    this._registered = true;

    // send open event to the app which opened us
    this.open(session).then(opened => {
      if (!opened) {
        var _session;
        const err = `failed to open to network ${(_session = session) == null ? void 0 : _session.networkId}`;
        utils.logger.error(err);
        this.notifyClose({
          message: err
        });
        window.close();
      }
    }).catch(e => {
      var _session2;
      const err = `failed to open to network ${(_session2 = session) == null ? void 0 : _session2.networkId}, due to: ${e}`;
      utils.logger.error(err);
      this.notifyClose({
        message: err
      });
      window.close();
    });
  }
  unregister() {
    var _window$ue2;
    if (((_window$ue2 = window.ue) == null || (_window$ue2 = _window$ue2.sequencewallettransport) == null ? void 0 : _window$ue2.onmessagefromsequencejs) === this.onMessageFromUnreal) {
      delete window.ue.sequencewallettransport.onmessagefromsequencejs;
    }
    this._registered = false;
  }
  // sendMessage sends message to the dapp window
  sendMessage(message) {
    var _window$ue3;
    if (message.type !== EventType.INIT && this._init !== InitState.OK) {
      utils.logger.error('impossible state, should not be calling postMessage until inited');
      return;
    }
    // prepare payload
    const payload = JSON.stringify(message, utils.bigintReplacer);

    // post-message to app.
    (_window$ue3 = window.ue) == null || (_window$ue3 = _window$ue3.sequencewallettransport) == null || _window$ue3.sendmessagetosequencejs(payload);
  }
}

const CHANNEL_ID = 'sequence-extension-message-handler';
class ExtensionMessageHandler extends BaseWalletTransport {
  constructor(walletRequestHandler, runtime) {
    super(walletRequestHandler);
    this.runtime = runtime;
    this.port = void 0;
    this._init = InitState.OK;
  }
  register() {
    this._registered = true;
    this.port = this.runtime.connect({
      name: CHANNEL_ID
    });
  }
  sendMessage(message) {
    utils.logger.info('[ExtensionMessageHandler send]', message);
    this.port.postMessage(message);
  }
}

class ExtensionMessageProvider extends BaseProviderTransport {
  constructor(runtime) {
    super();
    this.register = () => {
      this._registered = true;
    };
    runtime.onConnect.addListener(port => {
      if (port.name === CHANNEL_ID) {
        this._init = InitState.OK;
        port.onMessage.addListener(message => {
          this.handleMessage(message);
        });
      }
    });
  }
  sendMessage(message) {
    //noop
  }
  unregister() {
    //noop
  }
  openWallet(path, intent, networkId) {
    //noop
  }
  closeWallet() {
    //noop
  }
}

// to be used on injected window.ethereum EIP1193 proxy
class BaseInjectedTransport extends eventemitter2.EventEmitter2 {
  constructor(stream) {
    var _this;
    super();
    _this = this;
    this.stream = stream;
    this.responseCallbacks = new Map();
    this._messageIdx = 0;
    this.nextMessageIdx = () => ++this._messageIdx;
    this.handleMessage = message => {
      if (!message.type || !message.data) {
        return;
      }
      utils.logger.info('[received message]', message);
      const requestIdx = message.idx;
      const responseCallback = this.responseCallbacks.get(requestIdx);
      if (requestIdx) {
        this.responseCallbacks.delete(requestIdx);
      }
      switch (message.type) {
        case EventType.MESSAGE:
          if (responseCallback) {
            this.emit(EventType.MESSAGE, message);
            responseCallback(message.data.error, message);
          } else {
            // NOTE: this would occur if 'idx' isn't set, which should never happen
            // or when we register two handler, or duplicate messages with the same idx are sent,
            // all of which should be prevented prior to getting to this point
            throw new Error('impossible state');
          }
          break;
        case EventType.DISCONNECT:
        case EventType.ACCOUNTS_CHANGED:
        case EventType.CHAIN_CHANGED:
          this.emit(message.type, message.data);
          break;
        default:
          console.error('unknown message type', message);
          break;
      }
    };
    this.sendMessageRequest = async function (message) {
      return new Promise((resolve, reject) => {
        if (!message.idx || message.idx <= 0) {
          reject(new Error('message idx not set'));
        }
        const responseCallback = (error, response) => {
          if (error) {
            reject(error);
          } else if (response) {
            resolve(response);
          } else {
            throw new Error('no valid response to return');
          }
        };
        const {
          idx
        } = message;
        if (!_this.responseCallbacks.get(idx)) {
          _this.responseCallbacks.set(idx, responseCallback);
        } else {
          reject(new Error('duplicate message idx, should never happen'));
        }
        _this.sendMessage(message);
      });
    };
    this.stream.on('data', this.handleMessage);
  }
  sendMessage(message) {
    if (!this.stream.writable) {
      console.error('window post message stream is not writable');
    }
    this.stream.write(message);
  }
}

// ..
let registeredWindowMessageProvider;
class WindowMessageProvider extends BaseProviderTransport {
  constructor(walletAppURL) {
    super();
    this.walletURL = void 0;
    this.walletWindow = void 0;
    this.register = () => {
      if (registeredWindowMessageProvider) {
        // overriding the registered message provider
        registeredWindowMessageProvider.unregister();
        registeredWindowMessageProvider = this;
      }

      // listen for incoming messages from wallet
      window.addEventListener('message', this.onWindowEvent);
      registeredWindowMessageProvider = this;

      // open heartbeat
      this.on('open', () => {
        // Heartbeat to track if window closed
        const popup = this.walletWindow;
        const interval = setInterval(() => {
          if (popup && popup.closed) {
            clearInterval(interval);
            this.close();
          }
        }, 500);
      });

      // close clean up
      this.on('close', () => {
        if (this.walletWindow) {
          this.walletWindow.close();
          this.walletWindow = null;
        }
      });
      this._registered = true;
    };
    this.unregister = () => {
      this._registered = false;
      this.closeWallet();

      // disable message listener
      if (registeredWindowMessageProvider === this) {
        registeredWindowMessageProvider = undefined;
      }
      window.removeEventListener('message', this.onWindowEvent);

      // clear event listeners
      this.events.removeAllListeners();
    };
    this.openWallet = (path, intent, networkId) => {
      if (this.walletWindow && this.isOpened()) {
        // TODO: update the location of window to path
        this.walletWindow.focus();
        return;
      }

      // Instantiate new walletURL for this call
      const walletURL = new URL(this.walletURL.href);
      const windowSessionParams = new WindowSessionParams();
      if (path && path !== '') {
        walletURL.pathname = path.toLowerCase();
      }

      // Set session, intent and network id on walletURL
      this._init = InitState.NIL;
      this._sessionId = `${performance.now()}`;
      windowSessionParams.set('sid', this._sessionId);
      if (intent) {
        // for the window-transport, we eagerly/optimistically set the origin host
        // when connecting to the wallet, however, this will be verified and enforced
        // on the wallet-side, so if a dapp provides the wrong origin, it will be dropped.
        if (intent.type === 'connect') {
          if (!intent.options) intent.options = {
            app: window.location.origin
          };

          // skip setting origin host if we're in an browser extension execution context
          // allow origin that is passed in
          if (!isBrowserExtension() && !isUnityPlugin() && intent.options) {
            intent.options.origin = window.location.origin;
          }
        }
        // encode intent as base64 url-encoded param
        windowSessionParams.set('intent', utils.base64EncodeObject(intent));
      }
      if (networkId) {
        windowSessionParams.set('net', `${networkId}`);
      }

      // Open popup window on center of the app window
      let windowSize;
      let windowPos;
      if (isBrowserExtension()) {
        windowSize = [450, 750];
        windowPos = [Math.abs(window.screen.width / 2 - windowSize[0] / 2), Math.abs(window.screen.height / 2 - windowSize[1] / 2)];
      } else {
        windowSize = [450, 750];
        windowPos = [Math.abs(window.screenX + window.innerWidth / 2 - windowSize[0] / 2), Math.abs(window.screenY + window.innerHeight / 2 - windowSize[1] / 2)];
      }
      const windowFeatures = `toolbar=0,location=0,menubar=0,scrollbars=yes,status=yes` + `,width=${windowSize[0]},height=${windowSize[1]}` + `,left=${windowPos[0]},top=${windowPos[1]}`;

      // serialize params
      walletURL.search = windowSessionParams.toString();
      this.walletWindow = window.open(walletURL.href, 'sequence.app', windowFeatures);

      // TODO: move this somewhere else
      // TODO: perhaps we trigger a .on('openTimeout') event..? maybe.. could help.

      // Popup blocking detection and notice
      // let warned = false
      // const warnPopupBlocked = () => {
      //   if (warned) return
      //   warned = true
      //   // alert('popup is blocked! hey yo') // NOTE: for debug purposes only
      //   throw new Error('popup is blocked')
      // }

      // const popupCheck = setTimeout(() => {
      //   if (!popup || popup.closed || typeof popup.closed === 'undefined') {
      //     // popup is definitely blocked if we reach here.
      //     warnPopupBlocked()
      //   }
      // }, 1000)

      // const popupBlocked = popup === null || popup === undefined
      // if (popupBlocked) {
      //   warnPopupBlocked()
      //   return
      // }
    };
    // onmessage, receives ProviderMessageResponse from the wallet post-message transport
    this.onWindowEvent = event => {
      // Security check, ensure message is coming from wallet origin url
      if (event.origin !== this.walletURL.origin) {
        // Safetly can skip events not from the wallet
        return;
      }
      let message;
      try {
        message = JSON.parse(event.data, utils.bigintReviver);
      } catch (err) {
        // event is not a ProviderMessage JSON object, skip
        return;
      }
      if (!message) {
        throw new Error('ProviderMessage object is empty');
      }

      // handle message with base message provider
      this.handleMessage(message);
    };
    this.walletURL = new URL(walletAppURL);
  }
  closeWallet() {
    var _this$walletWindow;
    this.close();
    (_this$walletWindow = this.walletWindow) == null || _this$walletWindow.close();
  }
  sendMessage(message) {
    if (!this.walletWindow) {
      utils.logger.warn('WindowMessageProvider: sendMessage failed as walletWindow is unavailable');
      return;
    }
    const postedMessage = typeof message !== 'string' ? JSON.stringify(message, utils.bigintReplacer) : message;
    this.walletWindow.postMessage(postedMessage, this.walletURL.origin);
  }
}

class WindowMessageHandler extends BaseWalletTransport {
  constructor(walletRequestHandler) {
    var _this;
    super(walletRequestHandler);
    _this = this;
    this.parentWindow = void 0;
    this._isPopup = false;
    // onmessage is called when (the wallet) receives request messages from the dapp
    // over the window post-messaging transport
    this.onWindowEvent = async function (event) {
      if (!event.origin || event.origin === '') {
        // skip same-origin or when event.origin is empty/undefined
        return;
      }
      if (_this.appOrigin && event.origin !== _this.appOrigin) {
        // skip message as not from expected app origin
        return;
      }

      // Wallet always expects json-rpc request messages from a dapp
      let request;
      try {
        request = JSON.parse(event.data, utils.bigintReviver);
      } catch (err) {
        // event is not a ProviderMessage JSON object, skip
        return;
      }
      utils.logger.debug('RECEIVED MESSAGE', request);

      // Record event origin for valid init ack
      if (_this._init !== InitState.OK && _this.isValidInitAck(request)) {
        _this.appOrigin = event.origin;
      }
      if (_this._init === InitState.OK && (!_this.appOrigin || _this.appOrigin.length < 8)) {
        // impossible state
        utils.logger.error('impossible state, init.OK and appOrigin required');
        return;
      }

      // Handle message via the base transport
      _this.handleMessage(request);
    };
    this.getWindowTransportSession = windowParams => {
      const params = new WindowSessionParams(windowParams);
      return {
        sessionId: params.get('sid'),
        networkId: params.get('net'),
        intent: utils.base64DecodeObject(params.get('intent'))
      };
    };
    this._init = InitState.NIL;
  }
  async register(windowHref) {
    const isPopup = parent.window.opener !== null;
    this._isPopup = isPopup;
    if (isPopup !== true) {
      return;
    }

    // record open details (sessionId + default network) from the window url
    const {
      search: rawParams
    } = new URL(windowHref || window.location.href);
    let session = this.getWindowTransportSession(rawParams);

    // provider should always include sid when opening a new window
    const isNewWindowSession = !!session.sessionId;

    // attempt to restore previous session in the case of a redirect or window reload
    if (!isNewWindowSession) {
      session = await this.getCachedTransportSession();
    }
    if (!session) {
      utils.logger.error('window session is undefined');
      return;
    }

    // record parent window instance for communication
    this.parentWindow = parent.window.opener;

    // listen for window-transport requests
    window.addEventListener('message', this.onWindowEvent, false);
    this._registered = true;

    // send open event to the app which opened us
    this.open(session).then(opened => {
      if (!opened) {
        var _session;
        const err = `failed to open to network ${(_session = session) == null ? void 0 : _session.networkId}`;
        utils.logger.error(err);
        this.notifyClose({
          message: err
        });
        window.close();
      }
    }).catch(e => {
      var _session2;
      const err = `failed to open to network ${(_session2 = session) == null ? void 0 : _session2.networkId}, due to: ${e}`;
      utils.logger.error(err);
      this.notifyClose({
        message: err
      });
      window.close();
    });
  }
  unregister() {
    window.removeEventListener('message', this.onWindowEvent);
    this._registered = false;
  }
  // postMessage sends message to the dapp window
  sendMessage(message) {
    // prepare payload
    const payload = JSON.stringify(message, utils.bigintReplacer);

    // post-message to app.
    // only for init requests, we send to '*' origin
    if (message.type === EventType.INIT) {
      this.postMessage(payload, true);
    } else {
      this.postMessage(payload);
    }
  }
  get isPopup() {
    return this._isPopup;
  }
  postMessage(message, init = false) {
    if (init !== true && this._init !== InitState.OK) {
      utils.logger.error('impossible state, should not be calling postMessage until inited');
      return;
    }
    if (init) {
      // init message transmission to global target -- for 'init' payloads only
      this.parentWindow.postMessage(message, '*');
    } else {
      // open message transmission
      if (this.appOrigin && this.appOrigin.length > 4) {
        // just above '.com'
        this.parentWindow.postMessage(message, this.appOrigin);
      } else {
        utils.logger.error('unable to postMessage as parentOrigin is invalid');
      }
    }
  }
}

function isMuxTransportTemplate(obj) {
  return obj && typeof obj === 'object' && (obj.windowTransport && typeof obj.windowTransport === 'object' || obj.proxyTransport && typeof obj.proxyTransport === 'object' || obj.extensionTransport && typeof obj.extensionTransport === 'object' || obj.unrealTransport && typeof obj.unrealTransport === 'object') && (
  // One of the transports must be enabled
  obj.windowTransport && obj.windowTransport.enabled || obj.proxyTransport && obj.proxyTransport.enabled || obj.extensionTransport && obj.extensionTransport.enabled || obj.unrealTransport && obj.unrealTransport.enabled);
}
class MuxMessageProvider {
  constructor(...messageProviders) {
    var _this = this;
    this.messageProviders = void 0;
    this.provider = void 0;
    this.register = () => {
      if (this.messageProviders.length === 1) {
        this.provider = this.messageProviders[0];
        this.provider.register();
        return;
      }

      // REVIEW/NOTE: ........ this method does not work for the chrome-extension. The issue becomes
      // when the browser quits or restarts, the "open" event is never triggered. Perhaps the code here is fine,
      // or maybe its not. What should happen is when a dapp makes a request, it will call openWallet
      // below, in which case one of the events will register. So perhaps this is fine.
      this.messageProviders.forEach(m => {
        m.register();
        m.once('open', () => {
          // the first one to open is the winner, and others will be unregistered
          if (!this.provider) {
            this.provider = m;

            // unregister other providers
            this.messageProviders.forEach(m => {
              if (this.provider !== m) {
                m.unregister();
              }
            });
          }
        });
      });
    };
    this.unregister = () => {
      this.messageProviders.forEach(m => m.unregister());
      this.provider = undefined;
    };
    this.openWallet = (path, intent, networkId) => {
      if (this.provider) {
        this.provider.openWallet(path, intent, networkId);
        return;
      }
      this.messageProviders.forEach(m => m.openWallet(path, intent, networkId));
    };
    this.sendMessageRequest = async function (message) {
      if (_this.provider) {
        return _this.provider.sendMessageRequest(message);
      }
      throw new Error('impossible state, wallet must be opened first');
    };
    this.waitUntilOpened = async function () {
      if (_this.provider) {
        return _this.provider.waitUntilOpened();
      }
      return Promise.race(_this.messageProviders.map(p => p.waitUntilOpened()));
    };
    this.waitUntilConnected = async function () {
      if (_this.provider) {
        return _this.provider.waitUntilConnected();
      }
      throw new Error('impossible state, wallet must be opened first');
    };
    this.messageProviders = messageProviders;
    this.provider = undefined;
  }
  static new(template) {
    var _template$windowTrans, _template$proxyTransp, _template$extensionTr, _template$unrealTrans;
    const muxMessageProvider = new MuxMessageProvider();
    if ((_template$windowTrans = template.windowTransport) != null && _template$windowTrans.enabled && typeof window === 'object' && template.walletAppURL) {
      const windowMessageProvider = new WindowMessageProvider(template.walletAppURL);
      muxMessageProvider.add(windowMessageProvider);
    }
    if ((_template$proxyTransp = template.proxyTransport) != null && _template$proxyTransp.enabled) {
      const proxyMessageProvider = new ProxyMessageProvider(template.proxyTransport.appPort);
      muxMessageProvider.add(proxyMessageProvider);
    }
    if ((_template$extensionTr = template.extensionTransport) != null && _template$extensionTr.enabled) {
      const extensionMessageProvider = new ExtensionMessageProvider(template.extensionTransport.runtime);
      muxMessageProvider.add(extensionMessageProvider);

      // NOTE/REVIEW: see note in mux-message-provider
      //
      // We don't add the extensionMessageProvider here because we don't send requests to it anyways, we seem to
      // send all requests to the WindowMessageProvider anyways. By allowing it, if browser restarts, it will break
      // the entire extension because messageProvider.provider will be undefined. So this is a hack to fix it.
    }
    if ((_template$unrealTrans = template.unrealTransport) != null && _template$unrealTrans.enabled && template.windowTransport && template.walletAppURL) {
      const unrealMessageProvider = new UnrealMessageProvider(template.walletAppURL);
      muxMessageProvider.add(unrealMessageProvider);
    }
    muxMessageProvider.register();
    return muxMessageProvider;
  }
  add(...messageProviders) {
    this.messageProviders.push(...messageProviders);
  }
  closeWallet() {
    if (this.provider) {
      this.provider.closeWallet();
    }
  }
  isOpened() {
    if (this.provider) {
      return this.provider.isOpened();
    }
    return false;
  }
  isConnected() {
    if (this.provider) {
      return this.provider.isConnected();
    }
    return false;
  }
  on(event, fn) {
    if (this.provider) {
      this.provider.on(event, fn);
      return;
    }
    this.messageProviders.forEach(m => {
      m.on(event, fn);
    });
  }
  once(event, fn) {
    if (this.provider) {
      this.provider.once(event, fn);
      return;
    }
    this.messageProviders.forEach(m => {
      m.once(event, fn);
    });
  }
  emit(event, ...args) {
    if (this.provider) {
      return this.provider.emit(event, ...args);
    }
    for (let i = 0; i < this.messageProviders.length; i++) {
      this.messageProviders[i].emit(event, ...args);
    }
    return true;
  }
  request(request) {
    if (!this.provider) {
      throw new Error('impossible state, wallet must be opened first');
    }
    return this.provider.request(request);
  }
  sendMessage(message) {
    if (!message.idx || message.idx <= 0) {
      throw new Error('message idx is empty');
    }
    if (this.provider) {
      this.provider.sendMessage(message);
    } else {
      throw new Error('impossible state, wallet must be opened first');
    }
  }
  handleMessage(message) {
    if (this.provider) {
      this.provider.handleMessage(message);
      return;
    }
    throw new Error('impossible state, wallet must be opened first');
  }
}

function toExtended(transactions) {
  if (transactions.length === 0) {
    throw new Error('No transaction provided');
  }
  const [first, ...rest] = transactions;
  return _extends({}, first, {
    auxiliary: rest
  });
}
function fromExtended(transaction) {
  return [transaction, ...(transaction.auxiliary || [])];
}

const SIGNER_READY_TIMEOUT = 10000;
class WalletRequestHandler {
  constructor(account, prompter, networks) {
    var _this = this;
    // signer interface of the wallet. A null value means there is no signer (ie. user not signed in). An undefined
    // value means the signer state is unknown, usually meaning the wallet app is booting up and initializing. Of course
    // a Signer value is the actually interface to a signed-in account
    this.account = void 0;
    this.signerReadyCallbacks = [];
    this.prompter = void 0;
    this.networks = void 0;
    this._openIntent = void 0;
    this._connectOptions = void 0;
    this.events = new eventemitter2.EventEmitter2();
    this.onConnectOptionsChange = undefined;
    this.promptConnect = async function (options) {
      if (!options && !_this._connectOptions) {
        // this is an unexpected state and should not happen
        throw new Error('prompter connect options are empty');
      }
      if (!_this.prompter) {
        // if prompter is null, we'll auto connect
        return _this.connect(options);
      }
      const promptConnectDetails = await _this.prompter.promptConnect(options || _this._connectOptions).catch(_ => {
        return {
          connected: false
        };
      });
      const connectDetails = promptConnectDetails;
      if (connectDetails.connected && !connectDetails.session) {
        connectDetails.session = await _this.walletSession(options == null ? void 0 : options.networkId);
      }
      return promptConnectDetails;
    };
    this.isSignedIn = async function () {
      await _this.signerReady();
      return !!_this.account;
    };
    this.getAccount = async function () {
      await _this.signerReady();
      if (_this.account === undefined) {
        throw new Error('signerReady failed resolve');
      }
      return _this.account;
    };
    this.account = account;
    this.prompter = prompter;
    this.networks = networks;
  }
  defaultChainId() {
    var _this$prompter$getDef, _this$prompter;
    return (_this$prompter$getDef = (_this$prompter = this.prompter) == null ? void 0 : _this$prompter.getDefaultChainId()) != null ? _this$prompter$getDef : this.networks[0].chainId;
  }
  async signIn(account, options = {}) {
    this.setAccount(account);
    const {
      connect,
      defaultNetworkId
    } = options;

    // Optionally, connect the dapp and wallet. In case connectOptions are provided, we will perform
    // necessary auth request, and then notify the dapp of the 'connect' details.
    //
    // NOTE: if a user is signing into a dapp from a fresh state, and and auth request is made
    // we don't trigger the promptConnect flow, as we consider the user just authenticated
    // for this dapp, so its safe to authorize in the promptSignInConnect() which will directly
    // connect after signing in.
    //
    // NOTE: signIn can optionally connect and notify dapp at this time for new signIn flows
    if (connect) {
      const connectOptions = this._connectOptions;
      let connectDetails;
      if (this.prompter !== null) {
        var _this$prompter2;
        connectDetails = await ((_this$prompter2 = this.prompter) == null ? void 0 : _this$prompter2.promptSignInConnect(connectOptions));
      } else {
        connectDetails = await this.connect(connectOptions);
      }
      this.notifyConnect(connectDetails);
      if (!connectOptions || connectOptions.keepWalletOpened !== true) {
        this.notifyClose();
      }
    }
    if (defaultNetworkId && this.defaultChainId() !== defaultNetworkId) {
      var _this$prompter3;
      await ((_this$prompter3 = this.prompter) == null ? void 0 : _this$prompter3.promptChangeNetwork(defaultNetworkId));
    }
  }
  signOut() {
    if (this.account) {
      this.notifyDisconnect();
    }

    // signed out state
    this.setAccount(null);
  }
  signerReset() {
    // resetting signer puts the wallet in an uninitialized state, which requires the app to
    // re-initiatize and set the signer either as "null" (ie. no signer) or "Signer" (ie. signed in).
    this.account = undefined;
  }
  signerReady(timeout = SIGNER_READY_TIMEOUT) {
    return new Promise((resolve, reject) => {
      if (this.account !== undefined) {
        resolve();
      } else {
        setTimeout(() => {
          if (this.account === undefined) {
            this.signerReadyCallbacks = [];
            reject(`signerReady timed out`);
          }
        }, timeout);
        this.signerReadyCallbacks.push(resolve);
      }
    });
  }
  async connect(options) {
    var _ref, _options$networkId;
    if (!this.account) {
      return {
        connected: false,
        chainId: '0x0',
        error: 'unable to connect without signed in account'
      };
    }
    const networkId = (_ref = (_options$networkId = options == null ? void 0 : options.networkId) != null ? _options$networkId : this.defaultChainId()) != null ? _ref : network.ChainId.MAINNET;
    const chainId = network.findSupportedNetwork(networkId).chainId;
    const connectDetails = {
      connected: true,
      chainId: ethers.ethers.toQuantity(chainId)
    };
    if (options && options.authorize) {
      // Perform ethauth eip712 request and construct the ConnectDetails response
      // including the auth proof
      const authOptions = {
        app: options.app,
        origin: options.origin,
        expiry: options.expiry,
        nonce: options.authorizeNonce
      };
      // if (typeof(options.authorize) === 'object') {
      //   authOptions = { ...authOptions, ...options.authorize }
      // }

      try {
        // TODO: Either implement account as a signer, or change signAuthorization to accept an account
        connectDetails.proof = await auth.signAuthorization(this.account, chainId, authOptions);
      } catch (err) {
        utils.logger.warn(`connect, signAuthorization failed for options: ${JSON.stringify(options)}, due to: ${err.message}`);
        return {
          connected: false,
          chainId: '0x0',
          error: `signAuthorization failed: ${err.message}`
        };
      }
    }

    // Build session response for connect details
    connectDetails.session = this.walletSession(chainId);
    return connectDetails;
  }
  // sendMessageRequest will unwrap the ProviderMessageRequest and send it to the JsonRpcHandler
  // (aka, the signer in this instance) and then responds with a wrapped response of
  // ProviderMessageResponse to be sent over the transport
  async sendMessageRequest(message) {
    var _message$clientVersio;
    // Older versions of the client require the response to be jsonrpc wrapped
    const majorVersion = Number(((_message$clientVersio = message.clientVersion) == null ? void 0 : _message$clientVersio.split('.')[0]) || '0');
    const isJsonRpcResponse = majorVersion < 2;
    const jsonRpcResponse = {
      id: message.data.id,
      jsonrpc: '2.0',
      result: null,
      error: undefined
    };
    try {
      const result = await this.request({
        method: message.data.method,
        params: message.data.params,
        chainId: message.chainId
      });
      return _extends({}, message, {
        data: isJsonRpcResponse ? _extends({}, jsonRpcResponse, {
          result
        }) : result
      });
    } catch (error) {
      return _extends({}, message, {
        data: isJsonRpcResponse ? _extends({}, jsonRpcResponse, {
          error
        }) : {
          error
        }
      });
    }
  }
  async request(request) {
    await this.getAccount();
    try {
      var _this$account, _request$chainId;
      // only allow public json rpc method to the provider when user is not logged in, aka signer is not set
      if ((!this.account || this.account === null) && !permittedJsonRpcMethods.includes(request.method)) {
        // throw new Error(`not logged in. ${request.method} is unavailable`)
        throw ErrSignedInRequired;
      }

      // wallet account
      const account = this.account;
      if (!account) {
        throw new Error('WalletRequestHandler: wallet account is not configured');
      }

      // fetch the provider for the specific chain, or undefined will select defaultChain
      const provider = (_this$account = this.account) == null ? void 0 : _this$account.providerFor((_request$chainId = request.chainId) != null ? _request$chainId : this.defaultChainId());
      if (!provider) {
        throw new Error(`WalletRequestHandler: wallet provider is not configured for chainId ${request.chainId}`);
      }
      const jsonRpcProvider = provider instanceof ethers.ethers.JsonRpcProvider ? provider : undefined;
      switch (request.method) {
        case 'net_version':
          {
            if (!jsonRpcProvider) {
              throw new Error(`Account provider doesn't support send method`);
            }
            return await jsonRpcProvider.send('net_version', []);
          }
        case 'eth_chainId':
          {
            if (!jsonRpcProvider) {
              throw new Error(`Account provider doesn't support send method`);
            }
            return await jsonRpcProvider.send('eth_chainId', []);
          }
        case 'eth_accounts':
          {
            return [account.address];
          }
        case 'eth_getBalance':
          {
            const [accountAddress, blockTag] = request.params;
            const walletBalance = await provider.getBalance(accountAddress, blockTag);
            return utils.toHexString(walletBalance);
          }
        case 'sequence_sign':
        case 'personal_sign':
        case 'eth_sign':
          {
            // note: message from json-rpc input is in hex format
            let message;

            // there is a difference in the order of the params:
            // sequence_sign, personal_sign: [data, address]
            // eth_sign: [address, data]
            switch (request.method) {
              case 'sequence_sign':
              case 'personal_sign':
                {
                  const [data, _address] = request.params;
                  message = data;
                  break;
                }
              case 'eth_sign':
                {
                  const [_address, data] = request.params;
                  message = data;
                  break;
                }
            }
            let sig = '';

            // Message must be prefixed with "\x19Ethereum Signed Message:\n"
            // as defined by EIP-191
            const prefixedMessage = prefixEIP191Message(message);

            // TODO:
            // if (process.env.TEST_MODE === 'true' && this.prompter === null) {
            const sequenceVerified = request.method === 'sequence_sign';
            if (this.prompter === null) {
              var _request$chainId2;
              // prompter is null, so we'll sign from here
              sig = await account.signMessage(prefixedMessage, (_request$chainId2 = request.chainId) != null ? _request$chainId2 : this.defaultChainId(), sequenceVerified ? 'eip6492' : 'ignore');
            } else {
              sig = await this.prompter.promptSignMessage({
                chainId: request.chainId,
                message: ethers.ethers.getBytes(prefixedMessage),
                eip6492: sequenceVerified
              }, this.connectOptions);
            }
            if (sig && sig.length > 0) {
              return sig;
            } else {
              // The user has declined the request when value is null
              throw new Error('declined by user');
            }
          }
        case 'sequence_signTypedData_v4':
        case 'eth_signTypedData':
        case 'eth_signTypedData_v4':
          {
            // note: signingAddress from json-rpc input is in hex format, and typedDataObject
            // should be an object, but in some instances may be double string encoded
            const [signingAddress, typedDataObject] = request.params;
            let typedData = undefined;
            if (typeof typedDataObject === 'string') {
              try {
                typedData = JSON.parse(typedDataObject);
              } catch (e) {
                console.warn('walletRequestHandler: error parsing typedData', e);
              }
            } else {
              typedData = typedDataObject;
            }
            if (!typedData || !typedData.domain || !typedData.types || !typedData.message) {
              throw new Error('invalid typedData object');
            }
            let sig = '';
            const sequenceVerified = request.method === 'sequence_signTypedData_v4';
            if (this.prompter === null) {
              var _request$chainId3;
              // prompter is null, so we'll sign from here
              sig = await account.signTypedData(typedData.domain, typedData.types, typedData.message, (_request$chainId3 = request.chainId) != null ? _request$chainId3 : this.defaultChainId(), sequenceVerified ? 'eip6492' : 'ignore');
            } else {
              sig = await this.prompter.promptSignMessage({
                chainId: request.chainId,
                typedData: typedData,
                eip6492: sequenceVerified
              }, this.connectOptions);
            }
            if (sig && sig.length > 0) {
              return sig;
            } else {
              // The user has declined the request when value is null
              throw new Error('declined by user');
            }
          }
        case 'eth_sendTransaction':
          {
            // https://eth.wiki/json-rpc/API#eth_sendtransaction
            const transactionParams = fromExtended(request.params[0]).map(tx => {
              // eth_sendTransaction uses 'gas'
              // ethers and sequence use 'gasLimit'
              if ('gas' in tx && tx.gasLimit === undefined) {
                tx.gasLimit = tx.gas;
                delete tx.gas;
              }
              return tx;
            });
            validateTransactionRequest(account.address, transactionParams);
            let txnHash = '';
            if (this.prompter === null) {
              var _request$chainId4, _txnResponse$hash;
              // prompter is null, so we'll send from here
              const txnResponse = await account.sendTransaction(transactionParams, (_request$chainId4 = request.chainId) != null ? _request$chainId4 : this.defaultChainId());
              txnHash = (_txnResponse$hash = txnResponse == null ? void 0 : txnResponse.hash) != null ? _txnResponse$hash : '';
            } else {
              // prompt user to provide the response
              txnHash = await this.prompter.promptSendTransaction(transactionParams, request.chainId, this.connectOptions);
            }
            if (txnHash) {
              return txnHash;
            } else {
              // The user has declined the request when value is null
              throw new Error('declined by user');
            }
          }
        case 'eth_signTransaction':
          {
            // https://eth.wiki/json-rpc/API#eth_signTransaction
            const [transaction] = request.params;
            const sender = ethers.ethers.getAddress(transaction.from);
            if (sender !== account.address) {
              throw new Error('sender address does not match wallet');
            }
            validateTransactionRequest(account.address, transaction);
            if (this.prompter === null) {
              var _request$chainId5;
              // The eth_signTransaction method expects a `string` return value we instead return a `SignedTransactions` object,
              // this can only be broadcasted using an RPC provider with support for signed Sequence transactions, like this one.
              //
              // TODO: verify serializing / transporting the SignedTransaction object works as expected, most likely however
              // we will want to resolveProperties the big number values to hex strings
              return await account.signTransactions(transaction, (_request$chainId5 = request.chainId) != null ? _request$chainId5 : this.defaultChainId());
            } else {
              return await this.prompter.promptSignTransaction(transaction, request.chainId, this.connectOptions);
            }
          }
        case 'eth_sendRawTransaction':
          {
            // NOTE: we're not using a prompter here as the transaction is already signed
            // and would have prompted the user upon signing.

            // https://eth.wiki/json-rpc/API#eth_sendRawTransaction
            if (core.commons.transaction.isSignedTransactionBundle(request.params[0])) {
              const txChainId = Number(request.params[0].chainId);
              const tx = await account.relayer(txChainId).relay(request.params[0]);
              return tx.hash;
            } else {
              const tx = await provider.broadcastTransaction(request.params[0]);
              return tx.hash;
            }
          }
        case 'eth_getTransactionCount':
          {
            const address = ethers.ethers.getAddress(request.params[0]);
            const tag = request.params[1];

            // TODO: Maybe we should fetch this data from the relayer or from the reader
            // but for now we keep it simple and just use the provider

            const count = await provider.getTransactionCount(address, tag);
            return utils.toHexString(BigInt(count));
          }
        case 'eth_blockNumber':
          {
            return await provider.getBlockNumber();
          }
        case 'eth_getBlockByNumber':
          {
            return await provider.getBlock(request.params[0] /* , jsonRpcRequest.params[1] */);
          }
        case 'eth_getBlockByHash':
          {
            return await provider.getBlock(request.params[0] /* , jsonRpcRequest.params[1] */);
          }
        case 'eth_getTransactionByHash':
          {
            return await provider.getTransaction(request.params[0]);
          }
        case 'eth_call':
          {
            const [transactionObject, blockTag] = request.params;
            return await provider.call(_extends({}, transactionObject, {
              blockTag
            }));
          }
        case 'eth_getCode':
          {
            const [contractAddress, blockTag] = request.params;
            return await provider.getCode(contractAddress, blockTag);
          }
        case 'eth_estimateGas':
          {
            const [transactionObject] = request.params;
            return await provider.estimateGas(transactionObject);
          }
        case 'eth_gasPrice':
          {
            const feeData = await provider.getFeeData();
            return feeData.gasPrice === null ? null : utils.toHexString(feeData.gasPrice);
          }
        case 'wallet_switchEthereumChain':
          {
            const [switchParams] = request.params;
            if (!switchParams.chainId || switchParams.chainId.length === 0) {
              throw new Error('invalid chainId');
            }
            const chainId = BigInt(switchParams.chainId);
            this.setDefaultChainId(Number(chainId));
            return null; // success
          }

        // smart wallet method
        case 'sequence_getWalletContext':
          {
            return account.contexts;
          }

        // smart wallet method
        case 'sequence_getWalletConfig':
          {
            const [chainId] = request.params;
            if (chainId) {
              return [(await account.status(chainId)).onChain.config];
            } else {
              return await Promise.all(account.networks.map(async function (network) {
                const status = await account.status(network.chainId);
                return status.onChain.config;
              }));
            }
          }

        // smart wallet method
        case 'sequence_getWalletState':
          {
            const [chainId] = request.params;
            // TODO: Add getWalletState to the Signer interface
            if (chainId) {
              return [getLegacyWalletState(chainId, await account.status(chainId))];
            } else {
              return await Promise.all(account.networks.map(async function (network) {
                const status = await account.status(network.chainId);
                return getLegacyWalletState(network.chainId, status);
              }));
            }
          }

        // smart wallet method
        case 'sequence_getNetworks':
          {
            // NOTE: must ensure that the response result below returns clean serialized data, which is to omit
            // the provider and relayer objects and only return the urls so can be reinstantiated on dapp side.
            // This is handled by this.getNetworks() but noted here for future readers.
            return await this.getNetworks(true);
          }
        case 'sequence_isSequence':
          {
            return true;
          }

        // smart wallet method
        case 'sequence_updateConfig':
          {
            throw new Error('sequence_updateConfig method is not allowed from a dapp');
            // NOTE: method is disabled as we don't need a dapp to request to update a config.
            // However, if we ever want this, we can enable it but must also use the prompter
            // for confirmation.
            //
            // const [newConfig] = request.params
            // return await signer.updateConfig(newConfig)
          }

        // smart wallet method
        case 'sequence_publishConfig':
          {
            throw new Error('sequence_publishConfig method is not allowed from a dapp');
          }

        // relayer method
        case 'sequence_gasRefundOptions':
          {
            // TODO
            break;
          }

        // relayer method
        case 'sequence_getNonce':
          {
            // TODO
            break;
          }

        // relayer method
        case 'sequence_relay':
          {
            // TODO
            break;
          }

        // set default network of wallet
        case 'sequence_setDefaultNetwork':
          {
            const [defaultChainId] = request.params;
            if (!defaultChainId) {
              throw new Error('invalid request, method argument defaultChainId cannot be empty');
            }
            this.setDefaultChainId(defaultChainId);
            return await this.getNetworks(true);
          }
        default:
          {
            if (!jsonRpcProvider) {
              throw new Error(`Account provider doesn't support send method`);
            }

            // NOTE: provider here will be chain-bound if chainId is provided
            return await jsonRpcProvider.send(request.method, request.params);
          }
      }
    } catch (err) {
      utils.logger.error(err);
      throw {
        message: typeof err == 'string' ? err : (err == null ? void 0 : err.message) || 'unkown error',
        code: 4001
      };
    }
  }
  on(event, fn) {
    this.events.on(event, fn);
  }
  once(event, fn) {
    this.events.once(event, fn);
  }
  async getAddress() {
    var _this$account$address, _this$account2;
    return (_this$account$address = (_this$account2 = this.account) == null ? void 0 : _this$account2.address) != null ? _this$account$address : '';
  }
  get openIntent() {
    return this._openIntent;
  }
  setOpenIntent(intent) {
    this._openIntent = intent;
  }
  get connectOptions() {
    return this._connectOptions;
  }
  setConnectOptions(options) {
    var _this$onConnectOption;
    this._connectOptions = options;
    (_this$onConnectOption = this.onConnectOptionsChange) == null || _this$onConnectOption.call(this, options);
  }
  async setDefaultChainId(chainId) {
    var _this$prompter4;
    await ((_this$prompter4 = this.prompter) == null ? void 0 : _this$prompter4.promptChangeNetwork(chainId));
    return this.defaultChainId();
  }
  async getNetworks(jsonRpcResponse) {
    if (!this.account) {
      utils.logger.warn('signer not set: getNetworks is returning an empty list');
      return [];
    }
    if (jsonRpcResponse) {
      // omit provider and relayer objects as they are not serializable
      return this.account.networks.map(n => {
        const network = _extends({}, n);
        network.provider = undefined;
        network.relayer = undefined;
        return network;
      });
    } else {
      return this.account.networks;
    }
  }
  walletSession(networkId) {
    if (!this.account) {
      return undefined;
    }
    const session = {
      walletContext: this.account.contexts,
      accountAddress: this.account.address,
      // The dapp shouldn't access the relayer directly, and the provider (as an object) is not serializable.
      networks: this.account.networks.map(n => _extends({}, n, {
        provider: undefined,
        relayer: undefined
      }))
    };
    if (networkId) {
      const network$1 = network.findNetworkConfig(session.networks, networkId);
      if (network$1) {
        var _session$networks;
        // Delete the isDefaultChain property from the session network
        (_session$networks = session.networks) == null || _session$networks.forEach(n => delete n.isDefaultChain);

        // Add the isDefaultChain property to the network with the given networkId
        network$1.isDefaultChain = true;
      }
    }
    return session;
  }
  notifyConnect(connectDetails, origin) {
    var _connectDetails$sessi;
    console.log('emit connect', connectDetails);
    this.events.emit('connect', connectDetails);
    if ((_connectDetails$sessi = connectDetails.session) != null && _connectDetails$sessi.accountAddress) {
      var _connectDetails$sessi2;
      this.events.emit('accountsChanged', [(_connectDetails$sessi2 = connectDetails.session) == null ? void 0 : _connectDetails$sessi2.accountAddress], origin);
    }
  }
  notifyDisconnect(origin) {
    this.events.emit('accountsChanged', [], origin);
    this.events.emit('disconnect', undefined, origin);
  }
  notifyChainChanged(chainId, origin) {
    this.events.emit('chainChanged', ethers.ethers.toQuantity(chainId), origin);
  }
  async notifyNetworks(networks) {
    const n = networks || (await this.getNetworks(true));
    this.events.emit('networks', n);
    if (n.length > 0) {
      const defaultNetwork = n.find(network => network.chainId === this.defaultChainId());
      if (defaultNetwork) {
        this.events.emit('chainChanged', ethers.ethers.toQuantity(defaultNetwork.chainId));
      }
    } else {
      this.events.emit('chainChanged', '0x0');
    }
  }
  async notifyWalletContext() {
    if (!this.account) {
      utils.logger.warn('signer not set: skipping to notify wallet context');
      return;
    }
    const walletContext = this.account.contexts;
    this.events.emit('walletContext', walletContext);
  }
  notifyClose(error) {
    this.events.emit('close', error);
  }
  setAccount(account) {
    this.account = account;
    if (account !== undefined) {
      for (let i = 0; i < this.signerReadyCallbacks.length; i++) {
        this.signerReadyCallbacks[i]();
      }
      this.signerReadyCallbacks = [];
    }
  }
  async handleConfirmWalletDeployPrompt(prompter, account, sequenceVerified, chainId) {
    // check if wallet is deployed and up to date, if not, prompt user to deploy
    // if no chainId is provided, we'll assume the wallet is auth chain wallet and is up to date
    if (!chainId) {
      return true;
    }
    const skipsDeploy = status => {
      return status.canOnchainValidate || status.original.version === 2 && sequenceVerified;
    };
    const status = await account.status(chainId);
    if (skipsDeploy(status)) {
      return true;
    }
    const promptResult = await prompter.promptConfirmWalletDeploy(chainId, this.connectOptions);

    // if client returned true, check again to make sure wallet is deployed and up to date
    if (promptResult) {
      const status2 = await account.status(chainId);
      if (skipsDeploy(status2)) {
        return true;
      } else {
        utils.logger.error('WalletRequestHandler: result for promptConfirmWalletDeploy is not correct');
        return false;
      }
    }
    return false;
  }
}
function getLegacyWalletState(chainId, status) {
  return {
    context: status.original.context,
    config: status.onChain.config,
    address: core.commons.context.addressOf(status.original.context, status.original.imageHash),
    chainId,
    deployed: status.onChain.deployed,
    imageHash: status.imageHash,
    lastImageHash: status.onChain.imageHash,
    published: true,
    status
  };
}
const permittedJsonRpcMethods = ['net_version', 'eth_chainId', 'eth_getBalance', 'eth_getTransactionCount', 'eth_blockNumber', 'eth_getBlockByNumber', 'eth_getBlockByHash', 'eth_getTransactionByHash', 'eth_getCode', 'eth_estimateGas', 'eth_gasPrice', 'sequence_getWalletContext', 'sequence_getNetworks', 'sequence_setDefaultNetwork'];

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}

class SequenceSigner {
  get utils() {
    return this.provider.utils;
  }
  constructor(client, provider) {
    this.client = client;
    this.provider = provider;
    this.singleNetworkSigners = {};
    this._isSequenceSigner = true;
  }
  async getAddress() {
    return this.client.getAddress();
  }

  // This method shouldn't be used directly
  // it exists to maintain compatibility with ethers.Signer
  connect(provider) {
    if (!SequenceProvider.is(provider)) {
      throw new Error('SequenceSigner can only be connected to a SequenceProvider');
    }
    return new SequenceSigner(this.client, provider);
  }
  getSigner(chainId) {
    // The signer for the default network is this signer
    if (!chainId) {
      return this;
    }
    const useChainId = this.provider.toChainId(chainId);
    if (!this.singleNetworkSigners[useChainId]) {
      this.singleNetworkSigners[useChainId] = new SingleNetworkSequenceSigner(this.client, this.provider, useChainId);
    }
    return this.singleNetworkSigners[useChainId];
  }

  /**
   *  Resolves the chainId to use for the given request. If no chainId is provided,
   *  it uses the chainId defined by the client (default chainId). This can be
   *  overriden to build a single-network SequenceProvider.
   */
  useChainId(chainId) {
    return this.provider.toChainId(chainId) || this.client.getChainId();
  }
  async signMessage(message, options) {
    const {
      eip6492 = true
    } = options || {};
    const chainId = this.useChainId(options == null ? void 0 : options.chainId);
    return this.client.signMessage(message, {
      eip6492,
      chainId
    });
  }
  async signTypedData(domain, types, message, options) {
    const {
      eip6492 = true
    } = options || {};
    const chainId = this.useChainId(options == null ? void 0 : options.chainId);
    return this.client.signTypedData({
      domain,
      types,
      message
    }, {
      eip6492,
      chainId
    });
  }
  getProvider(chainId) {
    return this.provider.getProvider(chainId);
  }
  async sendTransaction(transaction, options) {
    const chainId = this.useChainId(options == null ? void 0 : options.chainId);
    const resolved = await resolveArrayProperties(transaction);
    const txHash = await this.client.sendTransaction(resolved, {
      chainId
    });
    const provider = this.getProvider(chainId);
    try {
      const result = await new Promise(resolve => {
        const check = async function check() {
          const tx = await provider.getTransaction(txHash);
          if (tx !== null) {
            return resolve(tx);
          }
          await provider.once('block', check);
        };
        check();
      });
      return result;
    } catch (err) {
      err.transactionHash = txHash;
      throw err;
    }
  }
  async getWalletConfig(chainId) {
    const useChainId = this.useChainId(chainId);
    return this.client.getOnchainWalletConfig({
      chainId: useChainId
    });
  }
  getNetworks() {
    return this.client.getNetworks();
  }
  async getBalance(blockTag, optionals) {
    const provider = this.getProvider(optionals == null ? void 0 : optionals.chainId);
    return provider.getBalance(this.getAddress(), blockTag);
  }
  async estimateGas(transaction, optionals) {
    return this.getProvider(optionals == null ? void 0 : optionals.chainId).estimateGas(transaction);
  }
  async call(transaction, optionals) {
    return this.getProvider(optionals == null ? void 0 : optionals.chainId).call(transaction);
  }
  getChainId() {
    return Promise.resolve(this.client.getChainId());
  }
  async getFeeData(optionals) {
    return this.getProvider(optionals == null ? void 0 : optionals.chainId).getFeeData();
  }
  async resolveName(name) {
    const res = await this.provider.resolveName(name);

    // For some reason ethers.Signer expects this to return `string`
    // but ethers.Provider expects this to return `string | null`.
    // The signer doesn't have any other source of information, so we'll
    // fail if the provider doesn't return a result.
    if (res === null) {
      throw new Error(`ENS name not found: ${name}`);
    }
    return res;
  }
  _checkProvider(_operation) {
    // We always have a provider, so this is a noop
  }
  getNonce(_blockTag) {
    throw new Error('SequenceSigner does not support getNonce');
  }
  populateCall(_transaction) {
    throw new Error('SequenceSigner does not support populateCall');
  }
  populateTransaction(_transaction) {
    throw new Error('SequenceSigner does not support populateTransaction');
  }
  checkTransaction(_transaction) {
    throw new Error('SequenceSigner does not support checkTransaction');
  }
  getTransactionCount(_blockTag) {
    // We could try returning the sequence nonce here
    // but we aren't sure how ethers will use this nonce
    throw new Error('SequenceSigner does not support getTransactionCount');
  }
  signTransaction(_transaction) {
    // We could implement signTransaction/sendTransaction here
    // but first we need a way of serializing these signed transactions
    // and it could lead to more trouble, because the dapp could try to send this transaction
    // using a different provider, which would fail.
    throw new Error('SequenceWallet does not support signTransaction, use sendTransaction instead.');
  }
  static is(cand) {
    return cand && typeof cand === 'object' && cand._isSequenceSigner === true;
  }
}

/**
 *  This is the same provider, but it only allows a single network at a time.
 *  the network defined by the constructor is the only one that can be used.
 *
 *  Attempting to call any method with a different network will throw an error.
 *  Attempting to change the network of this provider will throw an error.
 *
 *  NOTICE: These networks won't support ENS unless they are the mainnet.
 */
class SingleNetworkSequenceSigner extends SequenceSigner {
  constructor(client, provider, chainId) {
    super(client, provider.getProvider(chainId));
    this.chainId = chainId;
    this._isSingleNetworkSequenceSigner = true;
  }
  _useChainId(chainId) {
    const provided = this.provider.toChainId(chainId);
    if (provided && provided !== this.chainId) {
      throw new Error(`This signer only supports the network ${this.chainId}, but ${provided} was requested.`);
    }
    return provided || this.provider.toChainId(this.chainId);
  }
  useChainId(chainId) {
    return this._useChainId(chainId);
  }
  getChainId() {
    return Promise.resolve(this.provider.toChainId(this.chainId));
  }

  /**
   *  Override getProvider and getSigner so they always use `useChainId`
   *  this way they can't return providers and signers that can switch networks,
   *  or that don't match the chainId of this signer.
   */
  getProvider(chainId) {
    return super.getProvider(this._useChainId(chainId));
  }
  getSigner(chainId) {
    if (this._useChainId(chainId) !== this.chainId) {
      throw new Error(`Unreachable code`);
    }
    return this;
  }
  static is(cand) {
    return cand && typeof cand === 'object' && cand._isSingleNetworkSequenceSigner === true;
  }
}

/**
 *  This class is redundant with the SequenceSigner class, but it is here for now to
 *  maintain compatibility with the old wallet API. Eventually we should move these
 *  methods to the SequenceSigner class and deprecate this class.
 */
class WalletUtils {
  constructor(signer) {
    this.signer = signer;
    if (SingleNetworkSequenceSigner.is(signer)) {
      throw new Error('WalletUtils does not support SingleNetworkSequenceSigner');
    }
  }

  // Sign message on a specified chain, or DefaultChain by default
  signMessage(message, chainId, eip6492) {
    return this.signer.signMessage(message, {
      chainId,
      eip6492
    });
  }

  // Sign EIP-712 TypedData on a specified chain, or DefaultChain by default
  signTypedData(domain, types, message, chainId, eip6492) {
    return this.signer.signTypedData(domain, types, message, {
      chainId,
      eip6492
    });
  }

  // Verify signature of a digest, one of a message, typedData or other
  async isValidSignature(address, digest, signature, chainId) {
    return isValidSignature(address, digest, signature, this.signer.getProvider(chainId));
  }

  // Verify message signature
  async isValidMessageSignature(address, message, signature, chainId) {
    const provider = this.signer.getProvider(chainId);
    const prefixed = prefixEIP191Message(message);
    const digest = utils.encodeMessageDigest(prefixed);
    return isValidSignature(address, digest, signature, provider);
  }

  // Verify typedData signature
  isValidTypedDataSignature(address, typedData, signature, chainId) {
    return this.isValidSignature(address, utils.encodeTypedDataDigest(typedData), signature, chainId);
  }

  // sendTransaction()
  // sendTransactions()

  // sendETH()
  // sendToken()
  // sendCoin() -- sugar for sendToken()
  // sendCollectible() -- sugar for sendToken()
  // callContract()

  // transactionHistory()
  // getReceipt()
  // getLogs()
  // // ..

  // validateSignature()
  // recoverWalletConfig()
  // recoverAddress()
}

const _excluded = ["method"];
const EIP1193EventTypes = ['connect', 'disconnect', 'chainChanged', 'accountsChanged'];
class SequenceProvider extends ethers.ethers.AbstractProvider {
  constructor(client, providerFor, networks = network.allNetworks, options) {
    // We support a lot of networks
    // but we start with the default one
    super(client.getChainId(), options);

    // Emit events as defined by EIP-1193
    this.client = client;
    this.providerFor = providerFor;
    this.networks = networks;
    this.options = options;
    this.singleNetworkProviders = {};
    this._isSequenceProvider = true;
    this.utils = void 0;
    this.signer = void 0;
    this.eip1193EventListeners = new Map();
    client.onConnect(details => {
      var _this$eip1193EventLis;
      //this.emit('connect', details)
      (_this$eip1193EventLis = this.eip1193EventListeners.get('connect')) == null || _this$eip1193EventLis.forEach(listener => listener(details));
    });
    client.onDisconnect(error => {
      var _this$eip1193EventLis2;
      //this.emit('disconnect', error)
      (_this$eip1193EventLis2 = this.eip1193EventListeners.get('disconnect')) == null || _this$eip1193EventLis2.forEach(listener => listener(error));
    });
    client.onDefaultChainIdChanged(chainId => {
      var _this$eip1193EventLis3;
      //this.emit('chainChanged', chainId)
      (_this$eip1193EventLis3 = this.eip1193EventListeners.get('chainChanged')) == null || _this$eip1193EventLis3.forEach(listener => listener(chainId));
    });
    client.onAccountsChanged(accounts => {
      var _this$eip1193EventLis4;
      //this.emit('accountsChanged', accounts)
      (_this$eip1193EventLis4 = this.eip1193EventListeners.get('accountsChanged')) == null || _this$eip1193EventLis4.forEach(listener => listener(accounts));
    });

    // NOTICE: We don't emit 'open' and 'close' events
    // because these are handled by the library, and they
    // are not part of EIP-1193

    // devs can still access them using
    //   client.onOpen()
    //   client.onClose()

    // Create a Sequence signer too
    this.signer = new SequenceSigner(this.client, this);

    // Create a utils instance
    this.utils = new WalletUtils(this.signer);
  }
  async on(event, listener) {
    if (EIP1193EventTypes.includes(event)) {
      const listeners = this.eip1193EventListeners.get(event) || new Set();
      listeners.add(listener);
      this.eip1193EventListeners.set(event, listeners);
      return this;
    }
    return super.on(event, listener);
  }
  async off(event, listener) {
    if (EIP1193EventTypes.includes(event)) {
      const listeners = this.eip1193EventListeners.get(event);
      if (listeners) {
        if (listener) {
          listeners.delete(listener);
        } else {
          listeners.clear();
        }
      }
      return this;
    }
    return super.off(event, listener);
  }
  getSigner(chainId) {
    return this.signer.getSigner(chainId);
  }
  connect(options) {
    return this.client.connect(options);
  }
  disconnect() {
    return this.client.disconnect();
  }
  isConnected() {
    return this.client.isConnected();
  }
  getSession() {
    return this.client.getSession();
  }
  listAccounts() {
    return [this.client.getAddress()];
  }

  // @deprecated use getSigner() instead
  getAddress() {
    return this.client.getAddress();
  }
  getNetworks() {
    return this.client.getNetworks();
  }
  getChainId() {
    return this.client.getChainId();
  }
  setDefaultChainId(chainId) {
    return this.client.setDefaultChainId(this.toChainId(chainId));
  }
  isOpened() {
    return this.client.isOpened();
  }
  closeWallet() {
    return this.client.closeWallet();
  }
  getWalletContext() {
    return this.client.getWalletContext();
  }

  // @deprecated use getSigner() instead
  async getWalletConfig(chainId) {
    const useChainId = await this.useChainId(chainId);
    return this.client.getOnchainWalletConfig({
      chainId: useChainId
    });
  }
  authorize(options) {
    // Just an alias for connect with authorize: true
    return this.client.connect(_extends({}, options, {
      authorize: true
    }));
  }
  async openWallet(path, intent) {
    await this.client.openWallet(path, intent);
    return true;
  }
  toChainId(chainId) {
    if (chainId === undefined) {
      return undefined;
    }
    const resolved = network.findNetworkConfig(this.networks, chainId);
    if (!resolved) {
      throw new Error(`Unsupported network ${chainId}`);
    }
    return resolved.chainId;
  }

  /**
   *  Resolves the chainId to use for the given request. If no chainId is provided,
   *  it uses the chainId defined by the client (default chainId). This can be
   *  overriden to build a single-network SequenceProvider.
   */
  async useChainId(chainId) {
    return this.toChainId(chainId) || this.client.getChainId();
  }

  /**
   *  This generates a provider that ONLY works for the given chainId.
   *  the generated provider can't switch networks, and can't handle requests
   *  for other networks.
   */

  getProvider(chainId) {
    // The provider without a chainId is... this one
    if (!chainId) {
      return this;
    }
    const useChainId = this.toChainId(chainId);
    if (!this.singleNetworkProviders[useChainId]) {
      this.singleNetworkProviders[useChainId] = new SingleNetworkSequenceProvider(this.client, this.providerFor, useChainId, this.options);
    }
    return this.singleNetworkProviders[useChainId];
  }

  /**
   *  This returns a subprovider, this is a regular non-sequence provider that
   *  can be used to fulfill read only requests on a given network.
   */
  async _getSubprovider(chainId) {
    const useChainId = await this.useChainId(chainId);

    // Whoever implements providerFrom should memoize the generated provider
    // otherwise every instance of SequenceProvider will create a new subprovider
    const provider = this.providerFor(useChainId);
    if (!provider) {
      throw new Error(`Unsupported network ${useChainId}`);
    }
    return provider;
  }
  async _perform(req) {
    var _provider$getRpcReque;
    const {
        method
      } = req,
      args = _objectWithoutPropertiesLoose(req, _excluded);
    const provider = await this._getSubprovider();
    const prepared = (_provider$getRpcReque = provider.getRpcRequest(req)) != null ? _provider$getRpcReque : {
      method,
      args: Object.values(args)
    };
    if (!prepared) {
      throw new Error(`Unsupported method ${req.method}`);
    }
    return provider.send(prepared.method, prepared.args);
  }
  async perform(method, params) {
    // First we check if the method should be handled by the client
    if (method === 'eth_chainId') {
      return ethers.ethers.toQuantity(await this.useChainId());
    }
    if (method === 'eth_accounts') {
      return [this.client.getAddress()];
    }
    if (method === 'wallet_switchEthereumChain') {
      const args = params[0];
      const chainId = normalizeChainId(args);
      return this.setDefaultChainId(chainId);
    }

    // Usually these methods aren't used by calling the provider
    // but to maximize compatibility we support them too.
    // The correct way of accessing these methods is by using .getSigner()
    if (method === 'eth_sendTransaction' || method === 'eth_sign' || method === 'eth_signTypedData' || method === 'eth_signTypedData_v4' || method === 'personal_sign' ||
    // These methods will use EIP-6492
    // but this is handled directly by the wallet
    method === 'sequence_sign' || method === 'sequence_signTypedData_v4') {
      // We pass the chainId to the client, if we don't pass one
      // the client will use its own default chainId
      return this.client.request({
        method,
        params,
        chainId: this.getChainId()
      });
    }
    return this._perform(_extends({
      method
    }, params));
  }
  send(method, params) {
    return this.perform(method, params);
  }
  request(request) {
    return this.perform(request.method, request.params);
  }
  async _detectNetwork() {
    const chainId = this.client.getChainId();
    const found = network.findNetworkConfig(this.networks, chainId);
    if (!found) {
      throw new Error(`Unknown network ${chainId}`);
    }
    const network$1 = new ethers.ethers.Network(found.name, found.chainId);
    return network$1;
  }
  async detectNetwork() {
    return this._detectNetwork();
  }

  // Override most of the methods, so we add support for an optional chainId
  // argument, which is used to select the provider to use.
  //
  // NOTICE: We could use generics to avoid repeating the same code
  // but this would make the code harder to read, and it's not worth it
  // since we only have a few methods to override.

  async waitForTransaction(transactionHash, confirmations, timeout, optionals) {
    const provider = await this._getSubprovider(optionals == null ? void 0 : optionals.chainId);
    return provider.waitForTransaction(transactionHash, confirmations, timeout);
  }
  async getBlockNumber(optionals) {
    const provider = await this._getSubprovider(optionals == null ? void 0 : optionals.chainId);
    return provider.getBlockNumber();
  }
  async getFeeData(optionals) {
    const provider = await this._getSubprovider(optionals == null ? void 0 : optionals.chainId);
    return provider.getFeeData();
  }
  async getBalance(addressOrName, blockTag, optionals) {
    const provider = await this._getSubprovider(optionals == null ? void 0 : optionals.chainId);
    return provider.getBalance(addressOrName, blockTag);
  }
  async getTransactionCount(addressOrName, blockTag, optionals) {
    const provider = await this._getSubprovider(optionals == null ? void 0 : optionals.chainId);
    return provider.getTransactionCount(addressOrName, blockTag);
  }
  async getCode(addressOrName, blockTag, optionals) {
    const provider = await this._getSubprovider(optionals == null ? void 0 : optionals.chainId);
    return provider.getCode(addressOrName, blockTag);
  }
  async getStorage(addressOrName, position, blockTag, optionals) {
    const provider = await this._getSubprovider(optionals == null ? void 0 : optionals.chainId);
    return provider.getStorage(addressOrName, position, blockTag);
  }
  async call(transaction, optionals) {
    const provider = await this._getSubprovider(optionals == null ? void 0 : optionals.chainId);
    return provider.call(transaction);
  }
  async estimateGas(transaction, optionals) {
    const provider = await this._getSubprovider(optionals == null ? void 0 : optionals.chainId);
    return provider.estimateGas(transaction);
  }
  async getBlock(blockHashOrBlockTag, prefetchTxs, optionals) {
    const provider = await this._getSubprovider(optionals == null ? void 0 : optionals.chainId);
    return provider.getBlock(blockHashOrBlockTag, prefetchTxs);
  }
  async getTransaction(transactionHash, optionals) {
    const provider = await this._getSubprovider(optionals == null ? void 0 : optionals.chainId);
    return provider.getTransaction(transactionHash);
  }
  async getLogs(filter, optionals) {
    const provider = await this._getSubprovider(optionals == null ? void 0 : optionals.chainId);
    return provider.getLogs(filter);
  }

  // ENS methods

  async supportsENS() {
    const networks = await this.getNetworks();
    return networks.some(n => n.chainId === 1);
  }
  async getResolver(name) {
    if (!(await this.supportsENS())) {
      return null;
    }

    // Resolver is always on the chainId 1
    const provider = await this._getSubprovider(1);
    return provider.getResolver(name);
  }
  async resolveName(name) {
    if (ethers.ethers.isAddress(name)) {
      return name;
    }
    if (!(await this.supportsENS())) {
      return null;
    }

    // Resolver is always on the chainId 1
    const provider = await this._getSubprovider(1);
    return provider.resolveName(name);
  }
  async lookupAddress(address) {
    if (!(await this.supportsENS())) {
      return null;
    }

    // Resolver is always on the chainId 1
    const provider = await this._getSubprovider(1);
    return provider.lookupAddress(address);
  }
  async getAvatar(nameOrAddress) {
    if (!(await this.supportsENS())) {
      return null;
    }
    const provider = await this._getSubprovider(1);
    return provider.getAvatar(nameOrAddress);
  }
}
SequenceProvider.is = provider => {
  return provider && typeof provider === 'object' && provider._isSequenceProvider === true;
};
function normalizeChainId(chainId) {
  if (typeof chainId === 'object') return normalizeChainId(chainId.chainId);
  return Number(chainId);
}

/**
 *  This is the same provider, but it only allows a single network at a time.
 *  the network defined by the constructor is the only one that can be used.
 *
 *  Attempting to call any method with a different network will throw an error.
 *  Attempting to change the network of this provider will throw an error.
 *
 *  NOTICE: These networks won't support ENS unless they are the mainnet.
 */
class SingleNetworkSequenceProvider extends SequenceProvider {
  constructor(client, providerFor, chainId, options) {
    super(client, providerFor, undefined, options);
    this.chainId = chainId;
    this._isSingleNetworkSequenceProvider = true;
  }
  _useChainId(chainId) {
    const provided = this.toChainId(chainId);
    if (provided && provided !== this.chainId) {
      throw new Error(`This provider only supports the network ${this.chainId}, but ${provided} was requested.`);
    }
    return provided || super.toChainId(this.chainId);
  }
  useChainId(chainId) {
    return Promise.resolve(this._useChainId(chainId));
  }
  getChainId() {
    return super.toChainId(this.chainId);
  }
  async getNetwork() {
    const networks = await this.client.getNetworks();
    const found = network.findNetworkConfig(networks, this.chainId);
    if (!found) {
      throw new Error(`Unsupported network ${this.chainId}`);
    }
    return new ethers.ethers.Network(found.name, found.chainId);
  }

  /**
   *  Override getProvider and getSigner so they always use `useChainId`
   *  this way they can't return providers and signers that can switch networks,
   *  or that don't match the chainId of this signer.
   */
  getProvider(chainId) {
    if (this._useChainId(chainId) !== this.chainId) {
      throw new Error(`Unreachable code`);
    }
    return this;
  }
  getSigner(chainId) {
    return super.getSigner(this._useChainId(chainId));
  }
  setDefaultChainId(_chainId) {
    throw new Error(`This provider only supports the network ${this.chainId}; use the parent provider to switch networks.`);
  }
  static is(cand) {
    return cand && typeof cand === 'object' && cand._isSingleNetworkSequenceProvider === true;
  }
}

// Analytics sub-class to add some custom helper methods
class Analytics extends tracker.Databeat {}

// Setup analytics tracker
const setupAnalytics = (projectAccessKey, server) => {
  if (!server) {
    server = 'https://nodes.sequence.app';
  }

  // disable tracking if projectAccessKey is not set
  const noop = !projectAccessKey;

  // auth
  const auth = {};
  if (projectAccessKey) {
    auth.headers = {
      'X-Access-Key': projectAccessKey
    };
  }
  return new Analytics(server, auth, {
    noop: noop,
    defaultEnabled: true,
    privacy: {
      userIdHash: true,
      userAgentSalt: false
    },
    initProps: () => {
      if (!tracker.isBrowser()) {
        return {};
      } else {
        return {
          origin: window.location.origin
        };
      }
    }
  });
};

/**
 *  This session class is meant to persist the state of the wallet connection
 *  whitin the dapp. This enables the client to retain the wallet address (and some more)
 *  even if the user refreshes the page. Otherwise we would have to open the popup again.
 */
class SequenceClientSession {
  constructor(store) {
    this.store = store;
  }
  connectedSession() {
    const session = this.getSession();
    if (session && session.accountAddress && session.walletContext && session.networks) {
      return {
        accountAddress: session.accountAddress,
        walletContext: session.walletContext,
        networks: session.networks
      };
    }
    throw new Error('Sequence session not connected');
  }
  hasSession() {
    var _this$getSession;
    return ((_this$getSession = this.getSession()) == null ? void 0 : _this$getSession.accountAddress) !== undefined;
  }
  setSession(session) {
    return this.store.setItem(SequenceClientSession.SESSION_LOCALSTORE_KEY, JSON.stringify(session));
  }
  getSession() {
    const session = this.store.getItem(SequenceClientSession.SESSION_LOCALSTORE_KEY);
    if (session) {
      return JSON.parse(session);
    }
    return undefined;
  }
  async clearSession() {
    return this.store.removeItem(SequenceClientSession.SESSION_LOCALSTORE_KEY);
  }
}

/**
 *  The wallet webapp doesn't really care what's the "default chain" for the user.
 *  so we don't even bother to send this information to the wallet. Instead, we
 *  track it locally using storage, that way the data stays always in sync.
 */
SequenceClientSession.SESSION_LOCALSTORE_KEY = '@sequence.session';
class DefaultChainIdTracker {
  constructor(store, startingChainId = 1) {
    this.store = store;
    this.startingChainId = startingChainId;
    this.callbacks = [];
    store.onItemChange(DefaultChainIdTracker.SESSION_CHAIN_ID_KEY, value => {
      if (value) {
        const chainId = parseInt(value);
        this.callbacks.forEach(cb => cb(chainId));
      }
    });
  }
  onDefaultChainIdChanged(callback) {
    this.callbacks.push(callback);
    return () => {
      this.callbacks = this.callbacks.filter(cb => cb !== callback);
    };
  }
  setDefaultChainId(chainId) {
    if (chainId !== this.getDefaultChainId()) {
      this.store.setItem(DefaultChainIdTracker.SESSION_CHAIN_ID_KEY, chainId.toString());
    }
  }
  getDefaultChainId() {
    const read = this.store.getItem(DefaultChainIdTracker.SESSION_CHAIN_ID_KEY);
    if (!read || read.length === 0) {
      return this.startingChainId;
    }
    return parseInt(read);
  }
}
DefaultChainIdTracker.SESSION_CHAIN_ID_KEY = '@sequence.session.defaultChainId';
/**
 *  This is a wallet client for sequence wallet-webapp. It connects using *some* transport
 *  and it allows to perform all sequence specific (or write) operations related to the wallet.
 *s
 *  It doesn't implement a full ethereum Provider, it doesn't include read-only methods.
 */

// TODO: rename Client to transport.. or something.. like SequenceTransport ..
class SequenceClient {
  constructor(transport, store, options) {
    var _options$defaultEIP, _this$session$getSess;
    this.session = void 0;
    this.defaultChainId = void 0;
    this.callbacks = {};
    this.transport = void 0;
    this.defaultEIP6492 = void 0;
    this.projectAccessKey = void 0;
    this.analytics = void 0;
    if (isMuxTransportTemplate(transport)) {
      this.transport = MuxMessageProvider.new(transport);
    } else if (isProviderTransport(transport)) {
      this.transport = transport;
    } else {
      throw new Error('Invalid transport');
    }
    const defaultChainId = options == null ? void 0 : options.defaultChainId;
    this.defaultEIP6492 = (_options$defaultEIP = options == null ? void 0 : options.defaultEIP6492) != null ? _options$defaultEIP : false;
    this.session = new SequenceClientSession(store);
    this.defaultChainId = new DefaultChainIdTracker(store, defaultChainId);
    this.transport.on('accountsChanged', accounts => {
      var _this$callbacks$accou;
      if (accounts.length > 1) {
        console.warn('SequenceClient: wallet-webapp returned more than one account');
      }
      (_this$callbacks$accou = this.callbacks.accountsChanged) == null || _this$callbacks$accou.forEach(cb => cb(accounts));
    });
    this.transport.on('connect', response => {
      var _this$callbacks$conne;
      const chainIdHex = ethers.ethers.toQuantity(this.getChainId());
      (_this$callbacks$conne = this.callbacks.connect) == null || _this$callbacks$conne.forEach(cb => cb(_extends({}, response, {
        // Ignore the full connect response
        // use the chainId defined locally
        chainId: chainIdHex
      })));
    });
    this.transport.on('disconnect', (error, origin) => {
      var _this$callbacks$disco;
      (_this$callbacks$disco = this.callbacks.disconnect) == null || _this$callbacks$disco.forEach(cb => cb(error, origin));
    });
    this.transport.on('networks', networks => {
      var _this$callbacks$netwo;
      (_this$callbacks$netwo = this.callbacks.networks) == null || _this$callbacks$netwo.forEach(cb => cb(networks));
    });
    this.transport.on('walletContext', context => {
      var _this$callbacks$walle;
      (_this$callbacks$walle = this.callbacks.walletContext) == null || _this$callbacks$walle.forEach(cb => cb(context));
    });
    this.transport.on('open', info => {
      var _this$callbacks$open;
      (_this$callbacks$open = this.callbacks.open) == null || _this$callbacks$open.forEach(cb => cb(info));
    });
    this.transport.on('close', () => {
      var _this$callbacks$close;
      (_this$callbacks$close = this.callbacks.close) == null || _this$callbacks$close.forEach(cb => cb());
    });
    this.transport.on('chainChanged', (chainIdHex, origin) => {
      var _this$callbacks$chain;
      (_this$callbacks$chain = this.callbacks.chainChanged) == null || _this$callbacks$chain.forEach(cb => cb(chainIdHex, origin));
    });

    // We don't listen for the transport chainChanged event
    // instead we handle it locally, so we listen for changes in the store
    this.defaultChainId.onDefaultChainIdChanged(chainId => {
      var _this$callbacks$chain2;
      const chainIdHex = ethers.ethers.toQuantity(chainId);
      (_this$callbacks$chain2 = this.callbacks.chainChanged) == null || _this$callbacks$chain2.forEach(cb => cb(chainIdHex));
    });
    if (options != null && options.projectAccessKey) {
      this.projectAccessKey = options.projectAccessKey;
    }
    if (this.projectAccessKey && options != null && options.analytics) {
      this.analytics = setupAnalytics(this.projectAccessKey);
    }
    if ((_this$session$getSess = this.session.getSession()) != null && _this$session$getSess.accountAddress) {
      var _this$analytics, _this$session$getSess2;
      (_this$analytics = this.analytics) == null || _this$analytics.identify((_this$session$getSess2 = this.session.getSession()) == null || (_this$session$getSess2 = _this$session$getSess2.accountAddress) == null ? void 0 : _this$session$getSess2.toLowerCase());
    }
  }

  // Callbacks

  registerCallback(eventName, callback) {
    if (!this.callbacks[eventName]) {
      this.callbacks[eventName] = [];
    }
    this.callbacks[eventName].push(callback);
    return () => {
      this.callbacks[eventName] = this.callbacks[eventName].filter(c => c !== callback);
    };
  }

  // Individual callbacks lead to more idiomatic code

  onOpen(callback) {
    return this.registerCallback('open', callback);
  }
  onClose(callback) {
    return this.registerCallback('close', callback);
  }
  onConnect(callback) {
    return this.registerCallback('connect', callback);
  }
  onDisconnect(callback) {
    return this.registerCallback('disconnect', callback);
  }
  onNetworks(callback) {
    return this.registerCallback('networks', callback);
  }
  onAccountsChanged(callback) {
    return this.registerCallback('accountsChanged', callback);
  }

  // @deprecated
  onWalletContext(callback) {
    return this.registerCallback('walletContext', callback);
  }
  onChainChanged(callback) {
    return this.registerCallback('chainChanged', callback);
  }
  onDefaultChainIdChanged(callback) {
    return this.registerCallback('chainChanged', callback);
  }
  getChainId() {
    return this.defaultChainId.getDefaultChainId();
  }
  setDefaultChainId(chainId) {
    return this.defaultChainId.setDefaultChainId(chainId);
  }

  // Proxy transport methods

  async openWallet(path, intent) {
    this.transport.openWallet(path, intent, this.getChainId());
    await this.transport.waitUntilOpened();
    return this.isOpened();
  }
  closeWallet() {
    return this.transport.closeWallet();
  }
  isOpened() {
    return this.transport.isOpened();
  }
  isConnected() {
    return this.session.hasSession();
  }
  getSession() {
    return this.session.getSession();
  }

  // Basic API
  getAddress() {
    const session = this.session.connectedSession();
    return session.accountAddress;
  }
  async connect(options) {
    if ((options == null ? void 0 : options.authorizeVersion) === undefined) {
      // Populate default authorize version if not provided
      options.authorizeVersion = 2;
    }
    if ((options == null ? void 0 : options.refresh) === true) {
      this.disconnect();
    }
    options.projectAccessKey = this.projectAccessKey;
    if (options) {
      if (options.authorize) {
        if (!options.app) {
          throw new Error(`connecting with 'authorize' option also requires 'app' to be set`);
        }
        if (options.authorizeVersion === undefined) {
          options.authorizeVersion = 2;
        }
      }
    }
    await this.openWallet(undefined, {
      type: 'connect',
      options: _extends({}, options, {
        networkId: this.getChainId(),
        clientVersion: core.VERSION
      })
    });
    const connectDetails = await this.transport.waitUntilConnected().catch(error => {
      if (error instanceof Error) {
        return {
          connected: false,
          error: error.message
        };
      } else {
        return {
          connected: false,
          error: JSON.stringify(error)
        };
      }
    });

    // Normalize chainId into a decimal string
    // TODO: Remove this once wallet-webapp returns chainId as a string
    if (connectDetails.chainId) {
      connectDetails.chainId = BigInt(connectDetails.chainId).toString();
    }
    if (connectDetails.connected) {
      var _connectDetails$sessi;
      if (!connectDetails.session) {
        throw new Error('impossible state, connect response is missing session');
      }
      this.session.setSession(connectDetails.session);
      if ((_connectDetails$sessi = connectDetails.session) != null && _connectDetails$sessi.accountAddress) {
        var _this$analytics2;
        (_this$analytics2 = this.analytics) == null || _this$analytics2.identify(connectDetails.session.accountAddress.toLowerCase());
      }
    }
    return connectDetails;
  }
  disconnect() {
    var _this$analytics3;
    if (this.isOpened()) {
      this.closeWallet();
    }
    (_this$analytics3 = this.analytics) == null || _this$analytics3.reset();
    return this.session.clearSession();
  }

  // Higher level API

  async request(request) {
    // Internally when sending requests we use `legacy_sign`
    // to avoid the default EIP6492 behavior overriding an explicit
    // "legacy sign" request, so we map the method here.
    request.method = this.mapSignMethod(request.method);
    const result = await this.transport.request(request);

    // We may need to unwrap the response if it's a JSON-RPC response. ie. older universal wallet versions
    return unwrapJsonRpcResponse(result);
  }
  async getNetworks(pull) {
    const connectedSession = this.session.connectedSession();
    if (pull) {
      connectedSession.networks = await this.request({
        method: 'sequence_getNetworks'
      });
      this.session.setSession(connectedSession);
    }
    return connectedSession.networks;
  }

  // NOTICE: `legacy_sign` will get overriden by `send`
  // it is done this way to ensure that:
  //  - `send` handles `personal_sign` as a request for the default sign method
  //  - explicit `personal_sign` is not replaced by `sequence_sign` (if default is EI6492)
  signMethod(options) {
    if ((options == null ? void 0 : options.eip6492) === undefined) {
      return 'personal_sign';
    }
    return options.eip6492 ? 'sequence_sign' : 'legacy_sign';
  }
  signTypedDataMethod(options) {
    if ((options == null ? void 0 : options.eip6492) === undefined) {
      return 'eth_signTypedData_v4';
    }
    return options.eip6492 ? 'sequence_signTypedData_v4' : 'legacy_signTypedData_v4';
  }
  mapSignMethod(method) {
    if (method === 'personal_sign') {
      if (this.defaultEIP6492) {
        return 'sequence_sign';
      } else {
        return 'personal_sign';
      }
    }
    if (method === 'eth_signTypedData_v4') {
      if (this.defaultEIP6492) {
        return 'sequence_signTypedData_v4';
      } else {
        return 'eth_signTypedData_v4';
      }
    }
    if (method === 'legacy_sign') {
      return 'personal_sign';
    }
    if (method === 'legacy_signTypedData_v4') {
      return 'eth_signTypedData_v4';
    }
    return method;
  }
  async signMessage(message, options) {
    var _this$analytics4;
    const method = this.signMethod(options);
    (_this$analytics4 = this.analytics) == null || _this$analytics4.track({
      event: 'SIGN_MESSAGE_REQUEST',
      props: {
        chainId: `${(options == null ? void 0 : options.chainId) || this.getChainId()}`
      }
    });
    message = ethers.ethers.hexlify(messageToBytes(message));

    // Address is ignored by the wallet webapp
    return this.request({
      method,
      params: [message, this.getAddress()],
      chainId: options == null ? void 0 : options.chainId
    });
  }
  async signTypedData(typedData, options) {
    var _this$analytics5;
    const method = this.signTypedDataMethod(options);

    // TODO: Stop using ethers for this, this is the only place where we use it
    // and it makes the client depend on ethers.
    const encoded = ethers.ethers.TypedDataEncoder.getPayload(typedData.domain, typedData.types, typedData.message);

    // The sign typed data will use one of the following chainIds, in order:
    // - The one provided in the options
    // - The one provided in the typedData.domain.chainId
    // - The default chainId

    (_this$analytics5 = this.analytics) == null || _this$analytics5.track({
      event: 'SIGN_TYPED_DATA_REQUEST',
      props: {
        chainId: `${(options == null ? void 0 : options.chainId) || this.getChainId()}`
      }
    });
    return this.request({
      method,
      params: [this.getAddress(), encoded],
      chainId: (options == null ? void 0 : options.chainId) || typedData.domain.chainId && Number(typedData.domain.chainId) || this.getChainId()
    });
  }
  async sendTransaction(tx, options) {
    var _this$analytics6;
    const sequenceTxs = Array.isArray(tx) ? tx : [tx];
    const extendedTxs = toExtended(sequenceTxs);
    (_this$analytics6 = this.analytics) == null || _this$analytics6.track({
      event: 'SEND_TRANSACTION_REQUEST',
      props: {
        chainId: `${(options == null ? void 0 : options.chainId) || this.getChainId()}`
      }
    });
    return this.request({
      method: 'eth_sendTransaction',
      params: [extendedTxs],
      chainId: options == null ? void 0 : options.chainId
    });
  }
  async getWalletContext() {
    return this.request({
      method: 'sequence_getWalletContext'
    });
  }
  async getOnchainWalletConfig(options) {
    // NOTICE: sequence_getWalletConfig sends the chainId as a param
    const res = await this.request({
      method: 'sequence_getWalletConfig',
      params: [(options == null ? void 0 : options.chainId) || this.getChainId()],
      chainId: options == null ? void 0 : options.chainId
    });
    return Array.isArray(res) ? res[0] : res;
  }

  // NOTICE: We are leaving out all the "regular" methods os a tipical
  // JSON RPC Provider (eth_getBlockByNumber, eth_call, etc)
  // wallet-webapp does implement them, but this client is meant to be
  // exclusively used for Sequence specific methods
}

// Unwrap a JsonRpcResponse result
const unwrapJsonRpcResponse = response => {
  if (response && typeof response === 'object' && 'jsonrpc' in response && 'result' in response) {
    return response.result;
  }
  return response;
};

const DefaultProviderConfig = {
  transports: {
    walletAppURL: 'https://sequence.app',
    windowTransport: {
      enabled: true
    },
    proxyTransport: {
      enabled: false
    }
  },
  defaultNetwork: 1,
  analytics: true
};
let sequenceWalletProvider;

/**
 * Initializes a wallet with the provided project access key and optional configuration.
 *
 * @param projectAccessKey - Access key for the project that can be obtained from Sequence Builder on sequence.build
 * @param partialConfig - Optional partial configuration for the wallet.
 * @returns The initialized wallet provider.
 * @throws Error if projectAccessKey is not provided, empty string or is not string.
 */
const initWallet = (projectAccessKey, partialConfig) => {
  var _config$networks$filt, _config$networks, _findNetworkConfig;
  if (!projectAccessKey || typeof projectAccessKey !== 'string') {
    throw new Error('Please pass a projectAccessKey in initWallet.');
  }
  if (sequenceWalletProvider) {
    return sequenceWalletProvider;
  }

  // Combine both the provided config and the default config
  const config = _extends({}, DefaultProviderConfig, partialConfig, {
    transports: _extends({}, DefaultProviderConfig.transports, partialConfig == null ? void 0 : partialConfig.transports)
  });
  const rpcProviders = {};

  // Find any new networks that aren't already defined in sequence.js
  // and add them to the list of networks, (they must have a rpcUrl and chainId)
  const newNetworks = (_config$networks$filt = (_config$networks = config.networks) == null ? void 0 : _config$networks.filter(n => {
    n.rpcUrl !== undefined && n.chainId !== undefined && !network.allNetworks.find(an => an.chainId === n.chainId);
  })) != null ? _config$networks$filt : [];

  // Override any information about the networks using the config
  const combinedNetworks = network.allNetworks.map(n => {
    var _config$networks2;
    const network = (_config$networks2 = config.networks) == null ? void 0 : _config$networks2.find(cn => cn.chainId === n.chainId);
    return network ? _extends({}, n, network) : n;
  }).concat(newNetworks).map(network => {
    // don't double-append in the case the user has already included their access key in the rpc URL
    if (network.rpcUrl.includes(projectAccessKey)) {
      return network;
    }

    // this will probably break non-sequence RPC provider URLs.
    network.rpcUrl = network.rpcUrl + `/${projectAccessKey}`;
    return network;
  });

  // This builds a "public rpc" on demand, we build them on demand because we don't want to
  // generate a bunch of providers for networks that aren't used.
  const providerForChainId = chainId => {
    if (!rpcProviders[chainId]) {
      var _combinedNetworks$fin;
      const rpcUrl = (_combinedNetworks$fin = combinedNetworks.find(n => n.chainId === chainId)) == null ? void 0 : _combinedNetworks$fin.rpcUrl;
      if (!rpcUrl) {
        throw new Error(`no rpcUrl found for chainId: ${chainId}`);
      }
      rpcProviders[chainId] = new network.JsonRpcProvider(rpcUrl, {
        middlewares: [network.loggingProviderMiddleware, network.exceptionProviderMiddleware, new network.CachedProvider()]
      }, {
        cacheTimeout: -1
      });
    }
    return rpcProviders[chainId];
  };

  // This is the starting default network (as defined by the config)
  // it can be later be changed using `wallet_switchEthereumChain` or some
  // of the other methods on the provider.
  const defaultNetwork = config.defaultNetwork ? (_findNetworkConfig = network.findNetworkConfig(combinedNetworks, config.defaultNetwork)) == null ? void 0 : _findNetworkConfig.chainId : undefined;
  if (!defaultNetwork && config.defaultNetwork) {
    throw new Error(`defaultNetwork not found for chainId: ${config.defaultNetwork}`);
  }

  // Generate ItemStore
  const itemStore = config.localStorage || useBestStore();

  // Create client, provider and return signer
  const client = new SequenceClient(config.transports, itemStore, {
    defaultChainId: defaultNetwork,
    defaultEIP6492: config.defaultEIP6492,
    projectAccessKey: projectAccessKey,
    analytics: config.analytics
  });
  sequenceWalletProvider = new SequenceProvider(client, providerForChainId);
  return sequenceWalletProvider;
};
const unregisterWallet = () => {
  if (!sequenceWalletProvider) return;
  sequenceWalletProvider.client.closeWallet();
  sequenceWalletProvider.client.transport.unregister();
  sequenceWalletProvider = undefined;
};
const getWallet = () => {
  if (!sequenceWalletProvider) {
    throw new Error('Wallet has not been initialized, call sequence.initWallet(config) first.');
  }
  return sequenceWalletProvider;
};

exports.BaseInjectedTransport = BaseInjectedTransport;
exports.BaseProviderTransport = BaseProviderTransport;
exports.BaseWalletTransport = BaseWalletTransport;
exports.CHANNEL_ID = CHANNEL_ID;
exports.DefaultChainIdTracker = DefaultChainIdTracker;
exports.DefaultProviderConfig = DefaultProviderConfig;
exports.ErrSignedInRequired = ErrSignedInRequired;
exports.EventType = EventType;
exports.ExtensionMessageHandler = ExtensionMessageHandler;
exports.ExtensionMessageProvider = ExtensionMessageProvider;
exports.InitState = InitState;
exports.LocalStorage = LocalStorage;
exports.MemoryItemStore = MemoryItemStore;
exports.MuxMessageProvider = MuxMessageProvider;
exports.OpenState = OpenState;
exports.PROVIDER_OPEN_TIMEOUT = PROVIDER_OPEN_TIMEOUT;
exports.ProviderError = ProviderError;
exports.ProxyMessageChannel = ProxyMessageChannel;
exports.ProxyMessageChannelPort = ProxyMessageChannelPort;
exports.ProxyMessageHandler = ProxyMessageHandler;
exports.ProxyMessageProvider = ProxyMessageProvider;
exports.SequenceClient = SequenceClient;
exports.SequenceClientSession = SequenceClientSession;
exports.SequenceProvider = SequenceProvider;
exports.SequenceSigner = SequenceSigner;
exports.SingleNetworkSequenceProvider = SingleNetworkSequenceProvider;
exports.SingleNetworkSequenceSigner = SingleNetworkSequenceSigner;
exports.UnrealMessageHandler = UnrealMessageHandler;
exports.UnrealMessageProvider = UnrealMessageProvider;
exports.WalletRequestHandler = WalletRequestHandler;
exports.WindowMessageHandler = WindowMessageHandler;
exports.WindowMessageProvider = WindowMessageProvider;
exports.WindowSessionParams = WindowSessionParams;
exports.getWallet = getWallet;
exports.initWallet = initWallet;
exports.isBrowserExtension = isBrowserExtension;
exports.isMuxTransportTemplate = isMuxTransportTemplate;
exports.isProviderTransport = isProviderTransport;
exports.isUnityPlugin = isUnityPlugin;
exports.isValidMessageSignature = isValidMessageSignature;
exports.isValidSignature = isValidSignature;
exports.isValidTypedDataSignature = isValidTypedDataSignature;
exports.isWalletUpToDate = isWalletUpToDate;
exports.messageToBytes = messageToBytes;
exports.nextMessageIdx = nextMessageIdx;
exports.prefixEIP191Message = prefixEIP191Message;
exports.resolveArrayProperties = resolveArrayProperties;
exports.trimEIP191Prefix = trimEIP191Prefix;
exports.unregisterWallet = unregisterWallet;
exports.useBestStore = useBestStore;
exports.validateTransactionRequest = validateTransactionRequest;
