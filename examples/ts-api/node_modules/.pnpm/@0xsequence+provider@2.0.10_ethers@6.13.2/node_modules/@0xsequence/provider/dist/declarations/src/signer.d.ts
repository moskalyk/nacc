import { ethers } from 'ethers';
import { SequenceProvider, SingleNetworkSequenceProvider } from "./provider.js";
import { SequenceClient } from "./client.js";
import { commons } from '@0xsequence/core';
import { ChainIdLike, NetworkConfig } from '@0xsequence/network';
import { WalletUtils } from "./utils/index.js";
import { OptionalChainIdLike, OptionalEIP6492 } from "./types.js";
export interface ISequenceSigner extends Omit<ethers.Signer, 'connect'> {
    getProvider(): SequenceProvider;
    getProvider(chainId: ChainIdLike): SingleNetworkSequenceProvider;
    getProvider(chainId?: ChainIdLike): SequenceProvider | SingleNetworkSequenceProvider;
    getSigner(): SequenceSigner;
    getSigner(chainId: ChainIdLike): SingleNetworkSequenceSigner;
    getSigner(chainId?: ChainIdLike): SequenceSigner | SingleNetworkSequenceSigner;
    getWalletConfig(chainId?: ChainIdLike): Promise<commons.config.Config>;
    getNetworks(): Promise<NetworkConfig[]>;
    connect: (provider: SequenceProvider) => SequenceSigner;
    signMessage(message: ethers.BytesLike, options?: OptionalChainIdLike & OptionalEIP6492): Promise<string>;
    signTypedData(domain: ethers.TypedDataDomain, types: Record<string, Array<ethers.TypedDataField>>, message: Record<string, any>, options?: OptionalChainIdLike & OptionalEIP6492): Promise<string>;
    sendTransaction(transaction: ethers.TransactionRequest[] | ethers.TransactionRequest, options?: OptionalChainIdLike): Promise<commons.transaction.TransactionResponse>;
    utils: WalletUtils;
}
export declare class SequenceSigner implements ISequenceSigner {
    client: SequenceClient;
    provider: SequenceProvider;
    private readonly singleNetworkSigners;
    readonly _isSequenceSigner: boolean;
    get utils(): WalletUtils;
    constructor(client: SequenceClient, provider: SequenceProvider);
    getAddress(): Promise<string>;
    connect(provider: ethers.Provider): SequenceSigner;
    getSigner(): SequenceSigner;
    getSigner(chainId: ChainIdLike): SingleNetworkSequenceSigner;
    getSigner(chainId?: ChainIdLike): SingleNetworkSequenceSigner | SequenceSigner;
    /**
     *  Resolves the chainId to use for the given request. If no chainId is provided,
     *  it uses the chainId defined by the client (default chainId). This can be
     *  overriden to build a single-network SequenceProvider.
     */
    protected useChainId(chainId?: ChainIdLike): number;
    signMessage(message: ethers.BytesLike, options?: OptionalChainIdLike & OptionalEIP6492): Promise<string>;
    signTypedData(domain: ethers.TypedDataDomain, types: Record<string, Array<ethers.TypedDataField>>, message: Record<string, any>, options?: OptionalChainIdLike & OptionalEIP6492): Promise<string>;
    getProvider(): SequenceProvider;
    getProvider(chainId: ChainIdLike): SingleNetworkSequenceProvider;
    getProvider(chainId?: ChainIdLike): SingleNetworkSequenceProvider | SequenceProvider;
    sendTransaction(transaction: ethers.TransactionRequest[] | ethers.TransactionRequest, options?: OptionalChainIdLike): Promise<ethers.TransactionResponse>;
    getWalletConfig(chainId?: ChainIdLike | undefined): Promise<commons.config.Config>;
    getNetworks(): Promise<NetworkConfig[]>;
    getBalance(blockTag?: ethers.BlockTag | undefined, optionals?: OptionalChainIdLike): Promise<bigint>;
    estimateGas(transaction: ethers.TransactionRequest, optionals?: OptionalChainIdLike): Promise<bigint>;
    call(transaction: ethers.TransactionRequest, optionals?: OptionalChainIdLike): Promise<string>;
    getChainId(): Promise<number>;
    getFeeData(optionals?: OptionalChainIdLike): Promise<ethers.FeeData>;
    resolveName(name: string): Promise<string>;
    _checkProvider(_operation?: string | undefined): void;
    getNonce(_blockTag?: ethers.BlockTag): Promise<number>;
    populateCall(_transaction: ethers.TransactionRequest): Promise<ethers.TransactionLike<string>>;
    populateTransaction(_transaction: ethers.TransactionRequest): Promise<ethers.TransactionLike<string>>;
    checkTransaction(_transaction: ethers.TransactionRequest): ethers.TransactionRequest;
    getTransactionCount(_blockTag?: ethers.BlockTag): Promise<number>;
    signTransaction(_transaction: commons.transaction.Transactionish): Promise<string>;
    static is(cand: any): cand is SequenceSigner;
}
/**
 *  This is the same provider, but it only allows a single network at a time.
 *  the network defined by the constructor is the only one that can be used.
 *
 *  Attempting to call any method with a different network will throw an error.
 *  Attempting to change the network of this provider will throw an error.
 *
 *  NOTICE: These networks won't support ENS unless they are the mainnet.
 */
export declare class SingleNetworkSequenceSigner extends SequenceSigner {
    readonly chainId: ChainIdLike;
    readonly _isSingleNetworkSequenceSigner = true;
    constructor(client: SequenceClient, provider: SequenceProvider, chainId: ChainIdLike);
    private _useChainId;
    protected useChainId(chainId?: ChainIdLike): number;
    getChainId(): Promise<number>;
    /**
     *  Override getProvider and getSigner so they always use `useChainId`
     *  this way they can't return providers and signers that can switch networks,
     *  or that don't match the chainId of this signer.
     */
    getProvider(chainId?: ChainIdLike): SingleNetworkSequenceProvider;
    getSigner(chainId?: ChainIdLike | undefined): SingleNetworkSequenceSigner;
    static is(cand: any): cand is SingleNetworkSequenceSigner;
}
