import { NetworkConfig } from '@0xsequence/network';
import { ConnectDetails, ConnectOptions, ItemStore, MuxTransportTemplate, OpenWalletIntent, OptionalChainId, OptionalEIP6492, ProviderTransport, WalletEventTypes, WalletSession } from "./index.js";
import { commons } from '@0xsequence/core';
import { TypedData } from '@0xsequence/utils';
import { Analytics } from "./analytics.js";
import { ethers } from 'ethers';
/**
 *  This session class is meant to persist the state of the wallet connection
 *  whitin the dapp. This enables the client to retain the wallet address (and some more)
 *  even if the user refreshes the page. Otherwise we would have to open the popup again.
 */
export declare class SequenceClientSession {
    private store;
    static readonly SESSION_LOCALSTORE_KEY = "@sequence.session";
    constructor(store: ItemStore);
    connectedSession(): Required<WalletSession>;
    hasSession(): boolean;
    setSession(session: WalletSession): void;
    getSession(): WalletSession | undefined;
    clearSession(): Promise<void>;
}
/**
 *  The wallet webapp doesn't really care what's the "default chain" for the user.
 *  so we don't even bother to send this information to the wallet. Instead, we
 *  track it locally using storage, that way the data stays always in sync.
 */
export declare class DefaultChainIdTracker {
    private store;
    private startingChainId;
    static readonly SESSION_CHAIN_ID_KEY = "@sequence.session.defaultChainId";
    callbacks: ((chainId: number) => void)[];
    constructor(store: ItemStore, startingChainId?: number);
    onDefaultChainIdChanged(callback: (chainId: number) => void): () => void;
    setDefaultChainId(chainId: number): void;
    getDefaultChainId(): number;
}
export type SequenceClientOptions = {
    defaultChainId?: number;
    defaultEIP6492?: boolean;
    projectAccessKey?: string;
    analytics?: boolean;
};
/**
 *  This is a wallet client for sequence wallet-webapp. It connects using *some* transport
 *  and it allows to perform all sequence specific (or write) operations related to the wallet.
 *s
 *  It doesn't implement a full ethereum Provider, it doesn't include read-only methods.
 */
export declare class SequenceClient {
    private readonly session;
    private readonly defaultChainId;
    private readonly callbacks;
    readonly transport: ProviderTransport;
    readonly defaultEIP6492: boolean;
    readonly projectAccessKey?: string;
    readonly analytics?: Analytics;
    constructor(transport: ProviderTransport | MuxTransportTemplate, store: ItemStore, options?: SequenceClientOptions);
    registerCallback<K extends keyof WalletEventTypes>(eventName: K, callback: WalletEventTypes[K]): () => void;
    onOpen(callback: WalletEventTypes['open']): () => void;
    onClose(callback: WalletEventTypes['close']): () => void;
    onConnect(callback: WalletEventTypes['connect']): () => void;
    onDisconnect(callback: WalletEventTypes['disconnect']): () => void;
    onNetworks(callback: WalletEventTypes['networks']): () => void;
    onAccountsChanged(callback: WalletEventTypes['accountsChanged']): () => void;
    onWalletContext(callback: WalletEventTypes['walletContext']): () => void;
    onChainChanged(callback: WalletEventTypes['chainChanged']): () => void;
    onDefaultChainIdChanged(callback: WalletEventTypes['chainChanged']): () => void;
    getChainId(): number;
    setDefaultChainId(chainId: number): void;
    openWallet(path?: string, intent?: OpenWalletIntent): Promise<boolean>;
    closeWallet(): void;
    isOpened(): boolean;
    isConnected(): boolean;
    getSession(): WalletSession | undefined;
    getAddress(): string;
    connect(options: ConnectOptions): Promise<ConnectDetails>;
    disconnect(): Promise<void>;
    request(request: {
        method: string;
        params?: any[];
        chainId?: number;
    }): Promise<any>;
    getNetworks(pull?: boolean): Promise<NetworkConfig[]>;
    private signMethod;
    private signTypedDataMethod;
    private mapSignMethod;
    signMessage(message: ethers.BytesLike, options?: OptionalEIP6492 & OptionalChainId): Promise<string>;
    signTypedData(typedData: TypedData, options?: OptionalEIP6492 & OptionalChainId): Promise<string>;
    sendTransaction(tx: ethers.TransactionRequest[] | ethers.TransactionRequest, options?: OptionalChainId): Promise<string>;
    getWalletContext(): Promise<commons.context.VersionedContext>;
    getOnchainWalletConfig(options?: OptionalChainId): Promise<commons.config.Config>;
}
